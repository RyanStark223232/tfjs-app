{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../engine';\nimport { MaxPoolBackprop } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\n/**\r\n * Computes the backprop of a 2D max pool.\r\n *\r\n * @param dy The dy error, of rank 4 or rank 3 of shape\r\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\r\n * assumed.\r\n * @param input The original input image, of rank 4, of shape\r\n *     [batchSize, height, width, channels].\r\n * @param output The original output image, of rank 4, of shape\r\n *     [batchSize, outHeight, outWidth, channels].\r\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\r\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\r\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\r\n *     `strides` is a single number, then `strideHeight == strideWidth`.\r\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\r\n *     used in the forward prop of the op.\r\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\r\n *     rounding mode used when computing output dimensions if pad is a\r\n *     number. If none is provided, it will not round and error if the output\r\n *     is of fractional size.\r\n */\n\nfunction maxPoolBackprop_(dy, input, output, filterSize, strides, pad, dimRoundingMode) {\n  const $dy = convertToTensor(dy, 'dy', 'maxPoolBackprop');\n  const $input = convertToTensor(input, 'input', 'maxPoolBackprop');\n  const $output = convertToTensor(output, 'output', 'maxPoolBackprop');\n  util.assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy ` + `(${$dy.rank})`);\n  util.assert($dy.rank === 4, () => `Error in maxPoolBackprop: dy must be rank 4 but got rank ` + `${$dy.rank}.`);\n  util.assert($input.rank === 4, () => `Error in maxPoolBackprop: input must be rank 4 but got rank ` + `${$input.rank}.`);\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in maxPoolBackprop: pad must be an integer when using, ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const forward = backend => {\n    const convInfo = conv_util.computePool2DInfo($input.shape, filterSize, strides, 1\n    /* dilations */\n    , pad, dimRoundingMode);\n    return backend.maxPoolBackprop($dy, $input, $output, convInfo);\n  };\n\n  const inputs = {\n    dy: $dy,\n    input: $input,\n    output: $output\n  };\n  const attrs = {\n    filterSize,\n    strides,\n    pad,\n    dimRoundingMode\n  };\n  return ENGINE.runKernelFunc(forward, inputs, null, MaxPoolBackprop, attrs);\n}\n\nexport const maxPoolBackprop = op({\n  maxPoolBackprop_\n});","map":{"version":3,"sources":["../../src/ops/max_pool_backprop.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,QAAkC,WAAlC;AACA,SAAQ,eAAR,QAA2E,iBAA3E;AAIA,SAAQ,eAAR,QAA8B,oBAA9B;AAEA,OAAO,KAAK,IAAZ,MAAsB,SAAtB;AAEA,OAAO,KAAK,SAAZ,MAA2B,aAA3B;AACA,SAAQ,EAAR,QAAiB,aAAjB;AAEA;;;;;;;;;;;;;;;;;;;;AAoBG;;AACH,SAAS,gBAAT,CACI,EADJ,EAC6B,KAD7B,EAEI,MAFJ,EAEiC,UAFjC,EAGI,OAHJ,EAGsC,GAHtC,EAII,eAJJ,EAI4C;AAC1C,QAAM,GAAG,GAAG,eAAe,CAAC,EAAD,EAAK,IAAL,EAAW,iBAAX,CAA3B;AACA,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,iBAAjB,CAA9B;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,iBAAnB,CAA/B;AAEA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,GAAG,CAAC,IADxB,EAEI,MAAM,kBAAkB,MAAM,CAAC,IAAI,8BAA7B,GACF,IAAI,GAAG,CAAC,IAAI,GAHpB;AAKA,EAAA,IAAI,CAAC,MAAL,CACI,GAAG,CAAC,IAAJ,KAAa,CADjB,EAEI,MAAM,2DAAA,GACF,GAAG,GAAG,CAAC,IAAI,GAHnB;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,CADpB,EAEI,MAAM,8DAAA,GACF,GAAG,MAAM,CAAC,IAAI,GAHtB;;AAIA,MAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,IAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,KAAL,CAAW,GAAX,CADJ,EAEI,MAAM,+DAAA,GACF,mBAAmB,eAAe,gBAAgB,GAAG,GAH7D;AAID;;AAED,QAAM,OAAO,GAAwB,OAAO,IAAG;AAC7C,UAAM,QAAQ,GAAG,SAAS,CAAC,iBAAV,CACb,MAAM,CAAC,KADM,EACC,UADD,EACa,OADb,EACsB;AAAE;AADxB,MACyC,GADzC,EAEb,eAFa,CAAjB;AAIA,WAAO,OAAO,CAAC,eAAR,CAAwB,GAAxB,EAA6B,MAA7B,EAAqC,OAArC,EAA8C,QAA9C,CAAP;AACD,GAND;;AAQA,QAAM,MAAM,GACgB;AAAC,IAAA,EAAE,EAAE,GAAL;AAAU,IAAA,KAAK,EAAE,MAAjB;AAAyB,IAAA,MAAM,EAAE;AAAjC,GAD5B;AAGA,QAAM,KAAK,GACgB;AAAC,IAAA,UAAD;AAAa,IAAA,OAAb;AAAsB,IAAA,GAAtB;AAA2B,IAAA;AAA3B,GAD3B;AAGA,SAAO,MAAM,CAAC,aAAP,CACI,OADJ,EACa,MADb,EAC6C,IAD7C,EACmD,eADnD,EAEI,KAFJ,CAAP;AAGD;;AAED,OAAO,MAAM,eAAe,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAA1B","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../engine';\r\nimport { MaxPoolBackprop } from '../kernel_names';\r\nimport { convertToTensor } from '../tensor_util_env';\r\nimport * as util from '../util';\r\nimport * as conv_util from './conv_util';\r\nimport { op } from './operation';\r\n/**\r\n * Computes the backprop of a 2D max pool.\r\n *\r\n * @param dy The dy error, of rank 4 or rank 3 of shape\r\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\r\n * assumed.\r\n * @param input The original input image, of rank 4, of shape\r\n *     [batchSize, height, width, channels].\r\n * @param output The original output image, of rank 4, of shape\r\n *     [batchSize, outHeight, outWidth, channels].\r\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\r\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\r\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\r\n *     `strides` is a single number, then `strideHeight == strideWidth`.\r\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\r\n *     used in the forward prop of the op.\r\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\r\n *     rounding mode used when computing output dimensions if pad is a\r\n *     number. If none is provided, it will not round and error if the output\r\n *     is of fractional size.\r\n */\r\nfunction maxPoolBackprop_(dy, input, output, filterSize, strides, pad, dimRoundingMode) {\r\n    const $dy = convertToTensor(dy, 'dy', 'maxPoolBackprop');\r\n    const $input = convertToTensor(input, 'input', 'maxPoolBackprop');\r\n    const $output = convertToTensor(output, 'output', 'maxPoolBackprop');\r\n    util.assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy ` +\r\n        `(${$dy.rank})`);\r\n    util.assert($dy.rank === 4, () => `Error in maxPoolBackprop: dy must be rank 4 but got rank ` +\r\n        `${$dy.rank}.`);\r\n    util.assert($input.rank === 4, () => `Error in maxPoolBackprop: input must be rank 4 but got rank ` +\r\n        `${$input.rank}.`);\r\n    if (dimRoundingMode != null) {\r\n        util.assert(util.isInt(pad), () => `Error in maxPoolBackprop: pad must be an integer when using, ` +\r\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\r\n    }\r\n    const forward = backend => {\r\n        const convInfo = conv_util.computePool2DInfo($input.shape, filterSize, strides, 1 /* dilations */, pad, dimRoundingMode);\r\n        return backend.maxPoolBackprop($dy, $input, $output, convInfo);\r\n    };\r\n    const inputs = { dy: $dy, input: $input, output: $output };\r\n    const attrs = { filterSize, strides, pad, dimRoundingMode };\r\n    return ENGINE.runKernelFunc(forward, inputs, null, MaxPoolBackprop, attrs);\r\n}\r\nexport const maxPoolBackprop = op({ maxPoolBackprop_ });\r\n//# sourceMappingURL=max_pool_backprop.js.map"]},"metadata":{},"sourceType":"module"}