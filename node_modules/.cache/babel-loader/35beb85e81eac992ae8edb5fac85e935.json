{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../engine';\nimport { SparseToDense } from '../kernel_names';\nimport * as sparse_to_dense from '../ops/sparse_to_dense_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\r\n * Converts a sparse representation into a dense tensor.\r\n *\r\n * Builds an array dense with shape outputShape such that:\r\n *\r\n * // If sparseIndices is scalar\r\n * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)\r\n *\r\n * // If sparseIndices is a vector, then for each i\r\n * dense[sparseIndices[i]] = sparseValues[i]\r\n *\r\n * // If sparseIndices is an n by d matrix, then for each i in [0, n)\r\n * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]\r\n * All other values in dense are set to defaultValue. If sparseValues is a\r\n * scalar, all sparse indices are set to this single value.\r\n *\r\n * If indices are repeated the final value is summed over all values for those\r\n * indices.\r\n *\r\n * ```js\r\n * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');\r\n * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');\r\n * const shape = [8];\r\n * tf.sparseToDense(indices, values, shape).print();\r\n * ```\r\n *\r\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\r\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\r\n * placed.\r\n * @param sparseValues A 0-D or 1-D Tensor. Values\r\n * corresponding to each row of sparseIndices, or a scalar value to be used for\r\n * all sparse indices.\r\n * @param outputShape Shape of the dense output tensor. the type is inferred.\r\n * @param defaultValue Scalar. Value to set for indices not specified in\r\n * sparseIndices. Defaults to zero.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Normalization'}\r\n */\n\nfunction sparseToDense_(sparseIndices, sparseValues, outputShape) {\n  var defaultValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var $sparseIndices = convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');\n  var $sparseValues = convertToTensor(sparseValues, 'sparseValues', 'sparseToDense');\n  var $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);\n  sparse_to_dense.validateInput($sparseIndices, $sparseValues, outputShape, $defaultValue);\n  var inputs = {\n    sparseIndices: $sparseIndices,\n    sparseValues: $sparseValues,\n    defaultValue: $defaultValue\n  };\n  var attrs = {\n    outputShape: outputShape\n  };\n  return ENGINE.runKernelFunc(function (backend) {\n    return backend.sparseToDense($sparseIndices, $sparseValues, outputShape, $defaultValue);\n  }, inputs, null\n  /* grad */\n  , SparseToDense, attrs);\n}\n\nexport var sparseToDense = op({\n  sparseToDense_: sparseToDense_\n});","map":{"version":3,"sources":["../../src/ops/sparse_to_dense.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,QAAqB,WAArB;AACA,SAAQ,aAAR,QAAqE,iBAArE;AAEA,OAAO,KAAK,eAAZ,MAAiC,6BAAjC;AAGA,SAAQ,eAAR,QAA8B,oBAA9B;AAGA,SAAQ,EAAR,QAAiB,aAAjB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCG;;AACH,SAAS,cAAT,CACI,aADJ,EACsC,YADtC,EAEI,WAFJ,EAEiE;AAAA,MAAnC,YAAmC,uEAAD,CAAC;AAC/D,MAAM,cAAc,GAChB,eAAe,CAAC,aAAD,EAAgB,eAAhB,EAAiC,eAAjC,EAAkD,OAAlD,CADnB;AAEA,MAAM,aAAa,GACf,eAAe,CAAC,YAAD,EAAe,cAAf,EAA+B,eAA/B,CADnB;AAEA,MAAM,aAAa,GAAG,eAAe,CACjC,YADiC,EACnB,cADmB,EACH,eADG,EACc,aAAa,CAAC,KAD5B,CAArC;AAGA,EAAA,eAAe,CAAC,aAAhB,CACI,cADJ,EACoB,aADpB,EACmC,WADnC,EACgD,aADhD;AAGA,MAAM,MAAM,GAAwB;AAClC,IAAA,aAAa,EAAE,cADmB;AAElC,IAAA,YAAY,EAAE,aAFoB;AAGlC,IAAA,YAAY,EAAE;AAHoB,GAApC;AAMA,MAAM,KAAK,GAAuB;AAAC,IAAA,WAAW,EAAX;AAAD,GAAlC;AAEA,SAAO,MAAM,CAAC,aAAP,CACH,UAAA,OAAO;AAAA,WAAI,OAAO,CAAC,aAAR,CACP,cADO,EACS,aADT,EACwB,WADxB,EACqC,aADrC,CAAJ;AAAA,GADJ,EAGH,MAHG,EAG6B;AAAK;AAHlC,IAG8C,aAH9C,EAIH,KAJG,CAAP;AAKD;;AAED,OAAO,IAAM,aAAa,GAAG,EAAE,CAAC;AAAC,EAAA,cAAc,EAAd;AAAD,CAAD,CAAxB","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../engine';\r\nimport { SparseToDense } from '../kernel_names';\r\nimport * as sparse_to_dense from '../ops/sparse_to_dense_util';\r\nimport { convertToTensor } from '../tensor_util_env';\r\nimport { op } from './operation';\r\n/**\r\n * Converts a sparse representation into a dense tensor.\r\n *\r\n * Builds an array dense with shape outputShape such that:\r\n *\r\n * // If sparseIndices is scalar\r\n * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)\r\n *\r\n * // If sparseIndices is a vector, then for each i\r\n * dense[sparseIndices[i]] = sparseValues[i]\r\n *\r\n * // If sparseIndices is an n by d matrix, then for each i in [0, n)\r\n * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]\r\n * All other values in dense are set to defaultValue. If sparseValues is a\r\n * scalar, all sparse indices are set to this single value.\r\n *\r\n * If indices are repeated the final value is summed over all values for those\r\n * indices.\r\n *\r\n * ```js\r\n * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');\r\n * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');\r\n * const shape = [8];\r\n * tf.sparseToDense(indices, values, shape).print();\r\n * ```\r\n *\r\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\r\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\r\n * placed.\r\n * @param sparseValues A 0-D or 1-D Tensor. Values\r\n * corresponding to each row of sparseIndices, or a scalar value to be used for\r\n * all sparse indices.\r\n * @param outputShape Shape of the dense output tensor. the type is inferred.\r\n * @param defaultValue Scalar. Value to set for indices not specified in\r\n * sparseIndices. Defaults to zero.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Normalization'}\r\n */\r\nfunction sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {\r\n    const $sparseIndices = convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');\r\n    const $sparseValues = convertToTensor(sparseValues, 'sparseValues', 'sparseToDense');\r\n    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);\r\n    sparse_to_dense.validateInput($sparseIndices, $sparseValues, outputShape, $defaultValue);\r\n    const inputs = {\r\n        sparseIndices: $sparseIndices,\r\n        sparseValues: $sparseValues,\r\n        defaultValue: $defaultValue\r\n    };\r\n    const attrs = { outputShape };\r\n    return ENGINE.runKernelFunc(backend => backend.sparseToDense($sparseIndices, $sparseValues, outputShape, $defaultValue), inputs, null /* grad */, SparseToDense, attrs);\r\n}\r\nexport const sparseToDense = op({ sparseToDense_ });\r\n//# sourceMappingURL=sparse_to_dense.js.map"]},"metadata":{},"sourceType":"module"}