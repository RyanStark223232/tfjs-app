{"ast":null,"code":"import { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { conv2d } from './conv2d';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\r\n * Computes a 1D convolution over the input x.\r\n *\r\n * @param x The input tensor, of rank 3 or rank 2, of shape\r\n *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\r\n * @param filter The filter, rank 3, of shape\r\n *     `[filterWidth, inDepth, outDepth]`.\r\n * @param stride The number of entries by which the filter is moved right at\r\n *     each step.\r\n * @param pad The type of padding algorithm.\r\n *    - `same` and stride 1: output will be of same size as input,\r\n *       regardless of filter size.\r\n *    - `valid`: output will be smaller than input if filter is larger\r\n *       than 1x1.\r\n *   - For more info, see this guide:\r\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\r\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\r\n * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\r\n *     the data is stored in the order of [batch, in_width, in_channels]. Only\r\n *     \"NWC\" is currently supported.\r\n * @param dilation The dilation rate in which we sample input values in\r\n *     atrous convolution. Defaults to `1`. If it is greater than 1, then\r\n *     stride must be `1`.\r\n * @param dimRoundingMode The rounding mode used when computing output\r\n *     dimensions if pad is a number. If none is provided, it will not round\r\n *     and error if the output is of fractional size.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Convolution'}\r\n */\n\nfunction conv1d_(x, filter, stride, pad) {\n  var dataFormat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'NWC';\n  var dilation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n  var dimRoundingMode = arguments.length > 6 ? arguments[6] : undefined;\n  var $x = convertToTensor(x, 'x', 'conv1d');\n  var $filter = convertToTensor(filter, 'filter', 'conv1d');\n  var x3D = $x;\n  var reshapedTo3D = false;\n\n  if ($x.rank === 2) {\n    reshapedTo3D = true;\n    x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);\n  }\n\n  util.assert(x3D.rank === 3, function () {\n    return \"Error in conv1d: input must be rank 3, but got rank \".concat(x3D.rank, \".\");\n  });\n  util.assert($filter.rank === 3, function () {\n    return \"Error in conv1d: filter must be rank 3, but got rank \" + \"\".concat($filter.rank, \".\");\n  });\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), function () {\n      return \"Error in conv1d: pad must be an integer when using, \" + \"dimRoundingMode \".concat(dimRoundingMode, \" but got pad \").concat(pad, \".\");\n    });\n  }\n\n  util.assert(x3D.shape[2] === $filter.shape[1], function () {\n    return \"Error in conv1d: depth of input (\".concat(x3D.shape[2], \") must match \") + \"input depth for filter \".concat($filter.shape[1], \".\");\n  });\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(stride, dilation), function () {\n    return 'Error in conv1D: Either stride or dilation must be 1. ' + \"Got stride \".concat(stride, \" and dilation '\").concat(dilation, \"'\");\n  });\n  util.assert(dataFormat === 'NWC', function () {\n    return \"Error in conv1d: got dataFormat of \".concat(dataFormat, \" but only NWC is currently supported.\");\n  });\n  var filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);\n  var input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);\n  var strides = [1, stride];\n  var dilations = [1, dilation];\n  var conv2dDataFormat = 'NHWC';\n  var res = conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);\n\n  if (reshapedTo3D) {\n    return reshape(res, [res.shape[2], res.shape[3]]);\n  }\n\n  return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);\n}\n\nexport var conv1d = op({\n  conv1d_: conv1d_\n});","map":{"version":3,"sources":["../../src/ops/conv1d.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { convertToTensor } from '../tensor_util_env';\r\nimport * as util from '../util';\r\nimport { conv2d } from './conv2d';\r\nimport * as conv_util from './conv_util';\r\nimport { op } from './operation';\r\nimport { reshape } from './reshape';\r\n/**\r\n * Computes a 1D convolution over the input x.\r\n *\r\n * @param x The input tensor, of rank 3 or rank 2, of shape\r\n *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\r\n * @param filter The filter, rank 3, of shape\r\n *     `[filterWidth, inDepth, outDepth]`.\r\n * @param stride The number of entries by which the filter is moved right at\r\n *     each step.\r\n * @param pad The type of padding algorithm.\r\n *    - `same` and stride 1: output will be of same size as input,\r\n *       regardless of filter size.\r\n *    - `valid`: output will be smaller than input if filter is larger\r\n *       than 1x1.\r\n *   - For more info, see this guide:\r\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\r\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\r\n * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\r\n *     the data is stored in the order of [batch, in_width, in_channels]. Only\r\n *     \"NWC\" is currently supported.\r\n * @param dilation The dilation rate in which we sample input values in\r\n *     atrous convolution. Defaults to `1`. If it is greater than 1, then\r\n *     stride must be `1`.\r\n * @param dimRoundingMode The rounding mode used when computing output\r\n *     dimensions if pad is a number. If none is provided, it will not round\r\n *     and error if the output is of fractional size.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Convolution'}\r\n */\r\nfunction conv1d_(x, filter, stride, pad, dataFormat = 'NWC', dilation = 1, dimRoundingMode) {\r\n    const $x = convertToTensor(x, 'x', 'conv1d');\r\n    const $filter = convertToTensor(filter, 'filter', 'conv1d');\r\n    let x3D = $x;\r\n    let reshapedTo3D = false;\r\n    if ($x.rank === 2) {\r\n        reshapedTo3D = true;\r\n        x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);\r\n    }\r\n    util.assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);\r\n    util.assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ` +\r\n        `${$filter.rank}.`);\r\n    if (dimRoundingMode != null) {\r\n        util.assert(util.isInt(pad), () => `Error in conv1d: pad must be an integer when using, ` +\r\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\r\n    }\r\n    util.assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match ` +\r\n        `input depth for filter ${$filter.shape[1]}.`);\r\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(stride, dilation), () => 'Error in conv1D: Either stride or dilation must be 1. ' +\r\n        `Got stride ${stride} and dilation '${dilation}'`);\r\n    util.assert(dataFormat === 'NWC', () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);\r\n    const filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);\r\n    const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);\r\n    const strides = [1, stride];\r\n    const dilations = [1, dilation];\r\n    const conv2dDataFormat = 'NHWC';\r\n    const res = conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);\r\n    if (reshapedTo3D) {\r\n        return reshape(res, [res.shape[2], res.shape[3]]);\r\n    }\r\n    return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);\r\n}\r\nexport const conv1d = op({ conv1d_ });\r\n//# sourceMappingURL=conv1d.js.map"]},"metadata":{},"sourceType":"module"}