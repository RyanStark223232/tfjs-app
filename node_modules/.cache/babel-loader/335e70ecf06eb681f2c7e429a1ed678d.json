{"ast":null,"code":"import _classCallCheck from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { assert } from './util';\n/**\r\n * Serializable defines the serialization contract.\r\n *\r\n * TFJS requires serializable classes to return their className when asked\r\n * to avoid issues with minification.\r\n */\n\nexport var Serializable = /*#__PURE__*/function () {\n  function Serializable() {\n    _classCallCheck(this, Serializable);\n  }\n\n  _createClass(Serializable, [{\n    key: \"getClassName\",\n\n    /**\r\n     * Return the class name for this class to use in serialization contexts.\r\n     *\r\n     * Generally speaking this will be the same thing that constructor.name\r\n     * would have returned.  However, the class name needs to be robust\r\n     * against minification for serialization/deserialization to work properly.\r\n     *\r\n     * There's also places such as initializers.VarianceScaling, where\r\n     * implementation details between different languages led to different\r\n     * class hierarchies and a non-leaf node is used for serialization purposes.\r\n     */\n    value: function getClassName() {\n      return this.constructor.className;\n    }\n    /**\r\n     * Creates an instance of T from a ConfigDict.\r\n     *\r\n     * This works for most descendants of serializable.  A few need to\r\n     * provide special handling.\r\n     * @param cls A Constructor for the class to instantiate.\r\n     * @param config The Configuration for the object.\r\n     */\n\n    /** @nocollapse */\n\n  }], [{\n    key: \"fromConfig\",\n    value: function fromConfig(cls, config) {\n      return new cls(config);\n    }\n  }]);\n\n  return Serializable;\n}();\n/**\r\n * Maps string keys to class constructors.\r\n *\r\n * Used during (de)serialization from the cross-language JSON format, which\r\n * requires the class name in the serialization format matches the class\r\n * names as used in Python, should it exist.\r\n */\n\nexport var SerializationMap = /*#__PURE__*/function () {\n  function SerializationMap() {\n    _classCallCheck(this, SerializationMap);\n\n    this.classNameMap = {};\n  }\n  /**\r\n   * Returns the singleton instance of the map.\r\n   */\n\n\n  _createClass(SerializationMap, null, [{\n    key: \"getMap\",\n    value: function getMap() {\n      if (SerializationMap.instance == null) {\n        SerializationMap.instance = new SerializationMap();\n      }\n\n      return SerializationMap.instance;\n    }\n    /**\r\n     * Registers the class as serializable.\r\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(cls) {\n      SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];\n    }\n  }]);\n\n  return SerializationMap;\n}();\n/**\r\n * Register a class with the serialization map of TensorFlow.js.\r\n *\r\n * This is often used for registering custom Layers, so they can be\r\n * serialized and deserialized.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * class MyCustomLayer extends tf.layers.Layer {\r\n *   static className = 'MyCustomLayer';\r\n *\r\n *   constructor(config) {\r\n *     super(config);\r\n *   }\r\n * }\r\n * tf.serialization.registerClass(MyCustomLayer);\r\n * ```\r\n *\r\n * @param cls The class to be registered. It must have a public static member\r\n *   called `className` defined and the value must be a non-empty string.\r\n *\r\n * @doc {heading: 'Models', subheading: 'Serialization', ignoreCI: true}\r\n */\n\nexport function registerClass(cls) {\n  assert(cls.className != null, function () {\n    return \"Class being registered does not have the static className \" + \"property defined.\";\n  });\n  assert(typeof cls.className === 'string', function () {\n    return \"className is required to be a string, but got type \" + typeof cls.className;\n  });\n  assert(cls.className.length > 0, function () {\n    return \"Class being registered has an empty-string as its className, \" + \"which is disallowed.\";\n  });\n  SerializationMap.register(cls);\n}","map":{"version":3,"sources":["../src/serialization.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,QAAqB,QAArB;AAuCA;;;;;AAKG;;AACH,WAAsB,YAAtB;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACE;;;;;;;;;;AAUG;AAXL,mCAYc;AACV,aAAQ,KAAK,WAAL,CACH,SADL;AAED;AAOD;;;;;;;AAOG;;AACH;;AA9BF;AAAA;AAAA,+BAgCM,GAhCN,EAgCuC,MAhCvC,EAgCyD;AACrD,aAAO,IAAI,GAAJ,CAAQ,MAAR,CAAP;AACD;AAlCH;;AAAA;AAAA;AAqCA;;;;;;AAMG;;AACH,WAAa,gBAAb;AAOE,8BAAA;AAAA;;AACE,SAAK,YAAL,GAAoB,EAApB;AACD;AAED;;AAEG;;;AAbL;AAAA;AAAA,6BAce;AACX,UAAI,gBAAgB,CAAC,QAAjB,IAA6B,IAAjC,EAAuC;AACrC,QAAA,gBAAgB,CAAC,QAAjB,GAA4B,IAAI,gBAAJ,EAA5B;AACD;;AACD,aAAO,gBAAgB,CAAC,QAAxB;AACD;AAED;;AAEG;;AAvBL;AAAA;AAAA,6BAwB0C,GAxB1C,EAwByE;AACrE,MAAA,gBAAgB,CAAC,MAAjB,GAA0B,YAA1B,CAAuC,GAAG,CAAC,SAA3C,IACI,CAAC,GAAD,EAAM,GAAG,CAAC,UAAV,CADJ;AAED;AA3BH;;AAAA;AAAA;AA8BA;;;;;;;;;;;;;;;;;;;;;;;AAuBG;;AACH,OAAM,SAAU,aAAV,CACF,GADE,EAC6B;AACjC,EAAA,MAAM,CACF,GAAG,CAAC,SAAJ,IAAiB,IADf,EAEF;AAAA,WAAM,kFAAN;AAAA,GAFE,CAAN;AAIA,EAAA,MAAM,CACF,OAAO,GAAG,CAAC,SAAX,KAAyB,QADvB,EAEF;AAAA,WAAM,wDACF,OAAO,GAAG,CAAC,SADf;AAAA,GAFE,CAAN;AAIA,EAAA,MAAM,CACF,GAAG,CAAC,SAAJ,CAAc,MAAd,GAAuB,CADrB,EAEF;AAAA,WAAM,wFAAN;AAAA,GAFE,CAAN;AAKA,EAAA,gBAAgB,CAAC,QAAjB,CAA0B,GAA1B;AACD","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { assert } from './util';\r\n/**\r\n * Serializable defines the serialization contract.\r\n *\r\n * TFJS requires serializable classes to return their className when asked\r\n * to avoid issues with minification.\r\n */\r\nexport class Serializable {\r\n    /**\r\n     * Return the class name for this class to use in serialization contexts.\r\n     *\r\n     * Generally speaking this will be the same thing that constructor.name\r\n     * would have returned.  However, the class name needs to be robust\r\n     * against minification for serialization/deserialization to work properly.\r\n     *\r\n     * There's also places such as initializers.VarianceScaling, where\r\n     * implementation details between different languages led to different\r\n     * class hierarchies and a non-leaf node is used for serialization purposes.\r\n     */\r\n    getClassName() {\r\n        return this.constructor\r\n            .className;\r\n    }\r\n    /**\r\n     * Creates an instance of T from a ConfigDict.\r\n     *\r\n     * This works for most descendants of serializable.  A few need to\r\n     * provide special handling.\r\n     * @param cls A Constructor for the class to instantiate.\r\n     * @param config The Configuration for the object.\r\n     */\r\n    /** @nocollapse */\r\n    static fromConfig(cls, config) {\r\n        return new cls(config);\r\n    }\r\n}\r\n/**\r\n * Maps string keys to class constructors.\r\n *\r\n * Used during (de)serialization from the cross-language JSON format, which\r\n * requires the class name in the serialization format matches the class\r\n * names as used in Python, should it exist.\r\n */\r\nexport class SerializationMap {\r\n    constructor() {\r\n        this.classNameMap = {};\r\n    }\r\n    /**\r\n     * Returns the singleton instance of the map.\r\n     */\r\n    static getMap() {\r\n        if (SerializationMap.instance == null) {\r\n            SerializationMap.instance = new SerializationMap();\r\n        }\r\n        return SerializationMap.instance;\r\n    }\r\n    /**\r\n     * Registers the class as serializable.\r\n     */\r\n    static register(cls) {\r\n        SerializationMap.getMap().classNameMap[cls.className] =\r\n            [cls, cls.fromConfig];\r\n    }\r\n}\r\n/**\r\n * Register a class with the serialization map of TensorFlow.js.\r\n *\r\n * This is often used for registering custom Layers, so they can be\r\n * serialized and deserialized.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * class MyCustomLayer extends tf.layers.Layer {\r\n *   static className = 'MyCustomLayer';\r\n *\r\n *   constructor(config) {\r\n *     super(config);\r\n *   }\r\n * }\r\n * tf.serialization.registerClass(MyCustomLayer);\r\n * ```\r\n *\r\n * @param cls The class to be registered. It must have a public static member\r\n *   called `className` defined and the value must be a non-empty string.\r\n *\r\n * @doc {heading: 'Models', subheading: 'Serialization', ignoreCI: true}\r\n */\r\nexport function registerClass(cls) {\r\n    assert(cls.className != null, () => `Class being registered does not have the static className ` +\r\n        `property defined.`);\r\n    assert(typeof cls.className === 'string', () => `className is required to be a string, but got type ` +\r\n        typeof cls.className);\r\n    assert(cls.className.length > 0, () => `Class being registered has an empty-string as its className, ` +\r\n        `which is disallowed.`);\r\n    SerializationMap.register(cls);\r\n}\r\n//# sourceMappingURL=serialization.js.map"]},"metadata":{},"sourceType":"module"}