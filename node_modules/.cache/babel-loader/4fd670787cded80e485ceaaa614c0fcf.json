{"ast":null,"code":"/**\r\n * ExecutionContext captures the runtime environment of the node. It keeps\r\n * track of the current frame and iteration for the control flow ops.\r\n *\r\n * For example, typical Dynamic RNN model may contain loops, for which\r\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\r\n * current execution frame, and NextIteration Nodes for iteration id increment.\r\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\r\n */\nexport class ExecutionContext {\n  constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n\n  newFrame(id, frameName) {\n    return {\n      id,\n      frameName,\n      iterationId: 0\n    };\n  }\n  /**\r\n   * Set the current context\r\n   * @param contexts: ExecutionContextInfo[] the current path of execution\r\n   * frames\r\n   */\n\n\n  set currentContext(contexts) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext() {\n    return this.contexts;\n  }\n  /**\r\n   * Returns the current context in string format.\r\n   */\n\n\n  get currentContextId() {\n    return this._currentContextIds[0];\n  }\n  /**\r\n   * Returns the current context and all parent contexts in string format.\r\n   * This allow access to the nodes in the current and parent frames.\r\n   */\n\n\n  get currentContextIds() {\n    return this._currentContextIds;\n  }\n\n  generateCurrentContextIds() {\n    const names = [];\n\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  contextIdforContexts(contexts) {\n    return contexts ? contexts.map(context => context.id === 0 && context.iterationId === 0 ? '' : `${context.frameName}-${context.iterationId}`).join('/') : '';\n  }\n  /**\r\n   * Enter a new frame, a new context is pushed on the current context list.\r\n   * @param frameId new frame id\r\n   */\n\n\n  enterFrame(frameId) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n  /**\r\n   * Exit the current frame, the last context is removed from the current\r\n   * context list.\r\n   */\n\n\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n  /**\r\n   * Enter the next iteration of a loop, the iteration id of last context is\r\n   * increased.\r\n   */\n\n\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n\n      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name) {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id) {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id) {\n    return this.tensorListMap[id];\n  }\n\n  dispose(keepIds) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../src/executor/execution_context.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * ExecutionContext captures the runtime environment of the node. It keeps\r\n * track of the current frame and iteration for the control flow ops.\r\n *\r\n * For example, typical Dynamic RNN model may contain loops, for which\r\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\r\n * current execution frame, and NextIteration Nodes for iteration id increment.\r\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\r\n */\r\nexport class ExecutionContext {\r\n    constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {\r\n        this.weightMap = weightMap;\r\n        this.tensorArrayMap = tensorArrayMap;\r\n        this.tensorListMap = tensorListMap;\r\n        this.functionMap = functionMap;\r\n        this.rootContext = { id: 0, frameName: '', iterationId: 0 };\r\n        this.contexts = [this.rootContext];\r\n        this.lastId = 0;\r\n        this.generateCurrentContextIds();\r\n    }\r\n    newFrame(id, frameName) {\r\n        return { id, frameName, iterationId: 0 };\r\n    }\r\n    /**\r\n     * Set the current context\r\n     * @param contexts: ExecutionContextInfo[] the current path of execution\r\n     * frames\r\n     */\r\n    set currentContext(contexts) {\r\n        if (this.contexts !== contexts) {\r\n            this.contexts = contexts;\r\n            this.generateCurrentContextIds();\r\n        }\r\n    }\r\n    get currentContext() {\r\n        return this.contexts;\r\n    }\r\n    /**\r\n     * Returns the current context in string format.\r\n     */\r\n    get currentContextId() {\r\n        return this._currentContextIds[0];\r\n    }\r\n    /**\r\n     * Returns the current context and all parent contexts in string format.\r\n     * This allow access to the nodes in the current and parent frames.\r\n     */\r\n    get currentContextIds() {\r\n        return this._currentContextIds;\r\n    }\r\n    generateCurrentContextIds() {\r\n        const names = [];\r\n        for (let i = 0; i < this.contexts.length - 1; i++) {\r\n            const contexts = this.contexts.slice(0, this.contexts.length - i);\r\n            names.push(this.contextIdforContexts(contexts));\r\n        }\r\n        names.push('');\r\n        this._currentContextIds = names;\r\n    }\r\n    contextIdforContexts(contexts) {\r\n        return contexts ?\r\n            contexts\r\n                .map(context => (context.id === 0 && context.iterationId === 0) ?\r\n                '' :\r\n                `${context.frameName}-${context.iterationId}`)\r\n                .join('/') :\r\n            '';\r\n    }\r\n    /**\r\n     * Enter a new frame, a new context is pushed on the current context list.\r\n     * @param frameId new frame id\r\n     */\r\n    enterFrame(frameId) {\r\n        if (this.contexts) {\r\n            this.lastId++;\r\n            this.contexts = this.contexts.slice();\r\n            this.contexts.push(this.newFrame(this.lastId, frameId));\r\n            this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\r\n        }\r\n    }\r\n    /**\r\n     * Exit the current frame, the last context is removed from the current\r\n     * context list.\r\n     */\r\n    exitFrame() {\r\n        if (this.contexts && this.contexts.length > 1) {\r\n            this.contexts = this.contexts.slice();\r\n            this.contexts.splice(-1);\r\n            this.currentContextIds.shift();\r\n        }\r\n        else {\r\n            throw new Error('Cannot exit frame, the context is empty');\r\n        }\r\n    }\r\n    /**\r\n     * Enter the next iteration of a loop, the iteration id of last context is\r\n     * increased.\r\n     */\r\n    nextIteration() {\r\n        if (this.contexts && this.contexts.length > 0) {\r\n            this.contexts = this.contexts.slice();\r\n            this.lastId++;\r\n            const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\r\n            context.iterationId += 1;\r\n            context.id = this.lastId;\r\n            this.contexts.splice(-1, 1, context);\r\n            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\r\n        }\r\n        else {\r\n            throw new Error('Cannot increase frame iteration, the context is empty');\r\n        }\r\n    }\r\n    getWeight(name) {\r\n        return this.weightMap[name];\r\n    }\r\n    addTensorArray(tensorArray) {\r\n        this.tensorArrayMap[tensorArray.id] = tensorArray;\r\n    }\r\n    getTensorArray(id) {\r\n        return this.tensorArrayMap[id];\r\n    }\r\n    addTensorList(tensorList) {\r\n        this.tensorListMap[tensorList.id] = tensorList;\r\n    }\r\n    getTensorList(id) {\r\n        return this.tensorListMap[id];\r\n    }\r\n    dispose(keepIds) {\r\n        for (const key in this.tensorArrayMap) {\r\n            this.tensorArrayMap[key].clearAndClose(keepIds);\r\n        }\r\n        for (const key in this.tensorListMap) {\r\n            this.tensorListMap[key].clearAndClose(keepIds);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=execution_context.js.map"]},"metadata":{},"sourceType":"module"}