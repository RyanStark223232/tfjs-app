{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../engine';\nimport { Conv2DBackpropFilter } from '../kernel_names';\nimport * as util from '../util';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\r\n * Computes the derivative of the filter of a 2D convolution.\r\n *\r\n * @param x The input tensor, of rank 4 or rank 3 of shape\r\n *     [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.\r\n * @param dy The dy image, of rank 4 or rank 3, of shape\r\n *     [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.\r\n * @param filterShape The shape of the filter, length 4,\r\n *     [filterHeight, filterWidth, inDepth, outDepth].\r\n * @param strides The strides of the convolution: [strideHeight,\r\n * strideWidth].\r\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\r\n *     used in the forward prop of the op.\r\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\r\n *     \"NHWC\". Specify the data format of the input and output data. With the\r\n *     default format \"NHWC\", the data is stored in the order of: [batch,\r\n *     height, width, channels].\r\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\r\n *     rounding mode used when computing output dimensions if pad is a\r\n *     number. If none is provided, it will not round and error if the output\r\n *     is of fractional size.\r\n */\n\nfunction conv2DBackpropFilter_(x, dy, filterShape, strides, pad) {\n  var dataFormat = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'NHWC';\n  var dimRoundingMode = arguments.length > 6 ? arguments[6] : undefined;\n  var x4D = x;\n\n  if (x.rank === 3) {\n    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);\n  }\n\n  var dy4D = dy;\n\n  if (dy4D.rank === 3) {\n    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);\n  }\n\n  util.assert(x4D.rank === 4, function () {\n    return \"Error in conv2dDerFilter: input must be rank 4, but got shape \" + \"\".concat(x4D.shape, \".\");\n  });\n  util.assert(dy4D.rank === 4, function () {\n    return \"Error in conv2dDerFilter: dy must be rank 4, but got shape \" + \"\".concat(dy4D.shape, \".\");\n  });\n  util.assert(filterShape.length === 4, function () {\n    return \"Error in conv2dDerFilter: filterShape must be length 4, but got \" + \"\".concat(filterShape, \".\");\n  });\n  var inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\n  var outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];\n  util.assert(inDepth === filterShape[2], function () {\n    return \"Error in conv2dDerFilter: depth of input \".concat(inDepth, \") must \") + \"match input depth in filter (\".concat(filterShape[2], \".\");\n  });\n  util.assert(outDepth === filterShape[3], function () {\n    return \"Error in conv2dDerFilter: depth of dy (\".concat(outDepth, \") must \") + \"match output depth for filter (\".concat(filterShape[3], \").\");\n  });\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), function () {\n      return \"Error in conv2dDerFilter: pad must be an integer when using, \" + \"dimRoundingMode \".concat(dimRoundingMode, \" but got pad \").concat(pad, \".\");\n    });\n  }\n\n  var forward = function forward(backend) {\n    var dilations = 1;\n    var $dataFormat = conv_util.convertConv2DDataFormat(dataFormat);\n    var convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);\n    return backend.conv2dDerFilter(x4D, dy4D, convInfo);\n  };\n\n  var inputs = {\n    x: x4D,\n    dy: dy4D\n  };\n  var attrs = {\n    strides: strides,\n    pad: pad,\n    dataFormat: dataFormat,\n    dimRoundingMode: dimRoundingMode,\n    filterShape: filterShape\n  };\n  return ENGINE.runKernelFunc(forward, inputs, null, Conv2DBackpropFilter, attrs);\n}\n\nexport var conv2DBackpropFilter = op({\n  conv2DBackpropFilter_: conv2DBackpropFilter_\n});","map":{"version":3,"sources":["../../src/ops/conv2d_backprop_filter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../engine';\r\nimport { Conv2DBackpropFilter } from '../kernel_names';\r\nimport * as util from '../util';\r\nimport * as conv_util from './conv_util';\r\nimport { op } from './operation';\r\nimport { reshape } from './reshape';\r\n/**\r\n * Computes the derivative of the filter of a 2D convolution.\r\n *\r\n * @param x The input tensor, of rank 4 or rank 3 of shape\r\n *     [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.\r\n * @param dy The dy image, of rank 4 or rank 3, of shape\r\n *     [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.\r\n * @param filterShape The shape of the filter, length 4,\r\n *     [filterHeight, filterWidth, inDepth, outDepth].\r\n * @param strides The strides of the convolution: [strideHeight,\r\n * strideWidth].\r\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\r\n *     used in the forward prop of the op.\r\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\r\n *     \"NHWC\". Specify the data format of the input and output data. With the\r\n *     default format \"NHWC\", the data is stored in the order of: [batch,\r\n *     height, width, channels].\r\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\r\n *     rounding mode used when computing output dimensions if pad is a\r\n *     number. If none is provided, it will not round and error if the output\r\n *     is of fractional size.\r\n */\r\nfunction conv2DBackpropFilter_(x, dy, filterShape, strides, pad, dataFormat = 'NHWC', dimRoundingMode) {\r\n    let x4D = x;\r\n    if (x.rank === 3) {\r\n        x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);\r\n    }\r\n    let dy4D = dy;\r\n    if (dy4D.rank === 3) {\r\n        dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);\r\n    }\r\n    util.assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ` +\r\n        `${x4D.shape}.`);\r\n    util.assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ` +\r\n        `${dy4D.shape}.`);\r\n    util.assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ` +\r\n        `${filterShape}.`);\r\n    const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\r\n    const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];\r\n    util.assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must ` +\r\n        `match input depth in filter (${filterShape[2]}.`);\r\n    util.assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must ` +\r\n        `match output depth for filter (${filterShape[3]}).`);\r\n    if (dimRoundingMode != null) {\r\n        util.assert(util.isInt(pad), () => `Error in conv2dDerFilter: pad must be an integer when using, ` +\r\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\r\n    }\r\n    const forward = backend => {\r\n        const dilations = 1;\r\n        const $dataFormat = conv_util.convertConv2DDataFormat(dataFormat);\r\n        const convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);\r\n        return backend.conv2dDerFilter(x4D, dy4D, convInfo);\r\n    };\r\n    const inputs = { x: x4D, dy: dy4D };\r\n    const attrs = { strides, pad, dataFormat, dimRoundingMode, filterShape };\r\n    return ENGINE.runKernelFunc(forward, inputs, null, Conv2DBackpropFilter, attrs);\r\n}\r\nexport const conv2DBackpropFilter = op({ conv2DBackpropFilter_ });\r\n//# sourceMappingURL=conv2d_backprop_filter.js.map"]},"metadata":{},"sourceType":"module"}