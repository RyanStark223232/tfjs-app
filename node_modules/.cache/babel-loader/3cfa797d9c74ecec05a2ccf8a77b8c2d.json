{"ast":null,"code":"import { env } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nexport var CHECK_NAN_SNIPPET_UNARY = \"if (isnan(x)) return x;\";\nexport var CHECK_NAN_SNIPPET_BINARY = \"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\";\nexport var CHECK_NAN_SNIPPET_BINARY_PACKED = \"\\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\";\n/**\r\n * Template that creates a `KernelFunc` for unary ops.\r\n * @param opSnippets Op snippet to create `UnaryOpProgram`.\r\n */\n\nexport function unaryKernelFunc(opSnippet) {\n  return function (_ref) {\n    var inputs = _ref.inputs,\n        backend = _ref.backend;\n    var x = inputs.x;\n    var webglBackend = backend;\n    var program = new UnaryOpProgram(x.shape, opSnippet);\n    return webglBackend.runWebGLProgram(program, [x], x.dtype);\n  };\n}\n/**\r\n * Template that creates a `KernelFunc` for binary ops.\r\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\r\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\r\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\r\n *     when creating BinaryOpPackedProgram.\r\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\r\n *     result has the same dtype as the first input. This is mainly used in\r\n *     comparison kernels, such as Equal, Less, Greater, etc.\r\n */\n\nexport function binaryKernelFunc(opSnippet, packedOpSnippet, checkOutOfBoundsForPackedProgram, dtype) {\n  // TODO(jingjin): handle complex64.\n  return function (_ref2) {\n    var inputs = _ref2.inputs,\n        backend = _ref2.backend;\n    var a = inputs.a,\n        b = inputs.b;\n    var webglBackend = backend;\n    var program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ? new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, !!checkOutOfBoundsForPackedProgram) : new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    var $dtype = dtype || a.dtype;\n    var output = webglBackend.runWebGLProgram(program, [a, b], $dtype);\n    return output;\n  };\n}","map":{"version":3,"sources":["../../src/kernel_utils/kernel_funcs_utils.ts"],"names":[],"mappings":"AAAA,SAAgC,GAAhC,QAAmE,uBAAnE;AAGA,SAAQ,eAAR,QAA8B,iBAA9B;AACA,SAAQ,qBAAR,QAAoC,wBAApC;AACA,SAAQ,cAAR,QAA6B,gBAA7B;AAEA,OAAO,IAAM,uBAAuB,4BAA7B;AAEP,OAAO,IAAM,wBAAwB,6DAA9B;AAKP,OAAO,IAAM,+BAA+B,2LAArC;AAOP;;;AAGG;;AACH,OAAM,SAAU,eAAV,CAA0B,SAA1B,EAA2C;AAC/C,SAAO,gBAAsB;AAAA,QAApB,MAAoB,QAApB,MAAoB;AAAA,QAAZ,OAAY,QAAZ,OAAY;AAAA,QACpB,CADoB,GACf,MADe,CACpB,CADoB;AAE3B,QAAM,YAAY,GAAG,OAArB;AACA,QAAM,OAAO,GAAG,IAAI,cAAJ,CAAmB,CAAC,CAAC,KAArB,EAA4B,SAA5B,CAAhB;AACA,WAAO,YAAY,CAAC,eAAb,CAA6B,OAA7B,EAAsC,CAAC,CAAD,CAAtC,EAA2C,CAAC,CAAC,KAA7C,CAAP;AACD,GALD;AAMD;AAED;;;;;;;;;AASG;;AACH,OAAM,SAAU,gBAAV,CACF,SADE,EACiB,eADjB,EAEF,gCAFE,EAE0C,KAF1C,EAE0D;AAC9D;AAEA,SAAO,iBAAsB;AAAA,QAApB,MAAoB,SAApB,MAAoB;AAAA,QAAZ,OAAY,SAAZ,OAAY;AAAA,QACpB,CADoB,GACZ,MADY,CACpB,CADoB;AAAA,QACjB,CADiB,GACZ,MADY,CACjB,CADiB;AAE3B,QAAM,YAAY,GAAG,OAArB;AACA,QAAM,OAAO,GAAG,GAAG,GAAG,OAAN,CAAc,8BAAd,IACZ,IAAI,qBAAJ,CACI,eADJ,EACqB,CAAC,CAAC,KADvB,EAC8B,CAAC,CAAC,KADhC,EAEI,CAAC,CAAC,gCAFN,CADY,GAIZ,IAAI,eAAJ,CAAoB,SAApB,EAA+B,CAAC,CAAC,KAAjC,EAAwC,CAAC,CAAC,KAA1C,CAJJ;AAKA,QAAM,MAAM,GAAG,KAAK,IAAI,CAAC,CAAC,KAA1B;AACA,QAAM,MAAM,GAAG,YAAY,CAAC,eAAb,CAA6B,OAA7B,EAAsC,CAAC,CAAD,EAAI,CAAJ,CAAtC,EAA8C,MAA9C,CAAf;AACA,WAAO,MAAP;AACD,GAXD;AAYD","sourceRoot":"","sourcesContent":["import { env } from '@tensorflow/tfjs-core';\r\nimport { BinaryOpProgram } from '../binaryop_gpu';\r\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\r\nimport { UnaryOpProgram } from '../unaryop_gpu';\r\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\r\nexport const CHECK_NAN_SNIPPET_BINARY = `\r\n  if (isnan(a)) return a;\r\n  if (isnan(b)) return b;\r\n`;\r\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\r\n  result.r = isNaN.r > 0. ? NAN : result.r;\r\n  result.g = isNaN.g > 0. ? NAN : result.g;\r\n  result.b = isNaN.b > 0. ? NAN : result.b;\r\n  result.a = isNaN.a > 0. ? NAN : result.a;\r\n`;\r\n/**\r\n * Template that creates a `KernelFunc` for unary ops.\r\n * @param opSnippets Op snippet to create `UnaryOpProgram`.\r\n */\r\nexport function unaryKernelFunc(opSnippet) {\r\n    return ({ inputs, backend }) => {\r\n        const { x } = inputs;\r\n        const webglBackend = backend;\r\n        const program = new UnaryOpProgram(x.shape, opSnippet);\r\n        return webglBackend.runWebGLProgram(program, [x], x.dtype);\r\n    };\r\n}\r\n/**\r\n * Template that creates a `KernelFunc` for binary ops.\r\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\r\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\r\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\r\n *     when creating BinaryOpPackedProgram.\r\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\r\n *     result has the same dtype as the first input. This is mainly used in\r\n *     comparison kernels, such as Equal, Less, Greater, etc.\r\n */\r\nexport function binaryKernelFunc(opSnippet, packedOpSnippet, checkOutOfBoundsForPackedProgram, dtype) {\r\n    // TODO(jingjin): handle complex64.\r\n    return ({ inputs, backend }) => {\r\n        const { a, b } = inputs;\r\n        const webglBackend = backend;\r\n        const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\r\n            new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, !!checkOutOfBoundsForPackedProgram) :\r\n            new BinaryOpProgram(opSnippet, a.shape, b.shape);\r\n        const $dtype = dtype || a.dtype;\r\n        const output = webglBackend.runWebGLProgram(program, [a, b], $dtype);\r\n        return output;\r\n    };\r\n}\r\n//# sourceMappingURL=kernel_funcs_utils.js.map"]},"metadata":{},"sourceType":"module"}