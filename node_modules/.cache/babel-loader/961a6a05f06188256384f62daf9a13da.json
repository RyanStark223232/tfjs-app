{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../engine';\nimport { Concat } from '../kernel_names';\nimport { convertToTensorArray } from '../tensor_util_env';\nimport { assert, parseAxisParam, sizeFromShape } from '../util';\nimport { assertParamsConsistent, computeOutShape } from './concat_util';\nimport { op } from './operation';\nimport { tensor } from './tensor';\n/**\r\n * Concatenates a list of `tf.Tensor`s along a given axis.\r\n *\r\n * The tensors ranks and types must match, and their sizes must match in all\r\n * dimensions except `axis`.\r\n *\r\n * Also available are stricter rank-specific methods that assert that\r\n * `tensors` are of the given rank:\r\n *   - `tf.concat1d`\r\n *   - `tf.concat2d`\r\n *   - `tf.concat3d`\r\n *   - `tf.concat4d`\r\n *\r\n * Except `tf.concat1d` (which does not have axis param), all methods have\r\n * same signature as this method.\r\n *\r\n * ```js\r\n * const a = tf.tensor1d([1, 2]);\r\n * const b = tf.tensor1d([3, 4]);\r\n * a.concat(b).print();  // or a.concat(b)\r\n * ```\r\n *\r\n * ```js\r\n * const a = tf.tensor1d([1, 2]);\r\n * const b = tf.tensor1d([3, 4]);\r\n * const c = tf.tensor1d([5, 6]);\r\n * tf.concat([a, b, c]).print();\r\n * ```\r\n *\r\n * ```js\r\n * const a = tf.tensor2d([[1, 2], [10, 20]]);\r\n * const b = tf.tensor2d([[3, 4], [30, 40]]);\r\n * const axis = 1;\r\n * tf.concat([a, b], axis).print();\r\n * ```\r\n * @param tensors A list of tensors to concatenate.\r\n * @param axis The axis to concate along. Defaults to 0 (the first dim).\r\n *\r\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\r\n */\n\nfunction concat_(tensors) {\n  var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  assert(tensors.length >= 1, function () {\n    return 'Pass at least one tensor to concat';\n  });\n  var $tensors = convertToTensorArray(tensors, 'tensors', 'concat');\n\n  if ($tensors[0].dtype === 'complex64') {\n    $tensors.forEach(function (tensor) {\n      if (tensor.dtype !== 'complex64') {\n        throw new Error(\"Cannot concatenate complex64 tensors with a tensor\\n          with dtype \".concat(tensor.dtype, \". \"));\n      }\n    });\n  }\n\n  var forward = function forward(backend, save) {\n    var $axis = parseAxisParam(axis, $tensors[0].shape)[0];\n    var outShape = computeOutShape($tensors.map(function (t) {\n      return t.shape;\n    }), $axis);\n\n    if (sizeFromShape(outShape) === 0) {\n      return tensor([], outShape);\n    } // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n\n\n    $tensors = $tensors.filter(function (t) {\n      return t.size > 0;\n    });\n\n    if ($tensors.length === 1) {\n      return $tensors[0];\n    }\n\n    var shapes = $tensors.map(function (t) {\n      return t.shape;\n    });\n    assertParamsConsistent(shapes, $axis);\n    var res = backend.concat($tensors, $axis);\n    save($tensors);\n    return res;\n  };\n\n  var inputs = $tensors;\n  var attr = {\n    axis: axis\n  };\n  return ENGINE.runKernelFunc(forward, inputs, null\n  /* grad */\n  , Concat, attr);\n}\n\nexport var concat = op({\n  concat_: concat_\n});","map":{"version":3,"sources":["../../src/ops/concat.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AACH,SAAQ,MAAR,QAAkC,WAAlC;AACA,SAAQ,MAAR,QAAgD,iBAAhD;AAIA,SAAQ,oBAAR,QAAmC,oBAAnC;AAEA,SAAQ,MAAR,EAAgB,cAAhB,EAAgC,aAAhC,QAAoD,SAApD;AAEA,SAAQ,sBAAR,EAAgC,eAAhC,QAAsD,eAAtD;AACA,SAAQ,EAAR,QAAiB,aAAjB;AACA,SAAQ,MAAR,QAAqB,UAArB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCG;;AACH,SAAS,OAAT,CAAmC,OAAnC,EAAyE;AAAA,MAAR,IAAQ,uEAAD,CAAC;AACvE,EAAA,MAAM,CAAC,OAAO,CAAC,MAAR,IAAkB,CAAnB,EAAsB;AAAA,WAAM,oCAAN;AAAA,GAAtB,CAAN;AAEA,MAAI,QAAQ,GAAG,oBAAoB,CAAC,OAAD,EAAU,SAAV,EAAqB,QAArB,CAAnC;;AAEA,MAAI,QAAQ,CAAC,CAAD,CAAR,CAAY,KAAZ,KAAsB,WAA1B,EAAuC;AACrC,IAAA,QAAQ,CAAC,OAAT,CAAiB,UAAA,MAAM,EAAG;AACxB,UAAI,MAAM,CAAC,KAAP,KAAiB,WAArB,EAAkC;AAChC,cAAM,IAAI,KAAJ,oFACS,MAAM,CAAC,KADhB,QAAN;AAED;AACF,KALD;AAMD;;AAED,MAAM,OAAO,GAAwB,SAA/B,OAA+B,CAAC,OAAD,EAAU,IAAV,EAAkB;AACrD,QAAM,KAAK,GAAG,cAAc,CAAC,IAAD,EAAO,QAAQ,CAAC,CAAD,CAAR,CAAY,KAAnB,CAAd,CAAwC,CAAxC,CAAd;AACA,QAAM,QAAQ,GAAG,eAAe,CAAC,QAAQ,CAAC,GAAT,CAAa,UAAA,CAAC;AAAA,aAAI,CAAC,CAAC,KAAN;AAAA,KAAd,CAAD,EAA6B,KAA7B,CAAhC;;AACA,QAAI,aAAa,CAAC,QAAD,CAAb,KAA4B,CAAhC,EAAmC;AACjC,aAAO,MAAM,CAAC,EAAD,EAAK,QAAL,CAAb;AACD,KALoD,CAMrD;;;AACA,IAAA,QAAQ,GAAG,QAAQ,CAAC,MAAT,CAAgB,UAAA,CAAC;AAAA,aAAI,CAAC,CAAC,IAAF,GAAS,CAAb;AAAA,KAAjB,CAAX;;AACA,QAAI,QAAQ,CAAC,MAAT,KAAoB,CAAxB,EAA2B;AACzB,aAAO,QAAQ,CAAC,CAAD,CAAf;AACD;;AAED,QAAM,MAAM,GAAG,QAAQ,CAAC,GAAT,CAAa,UAAA,CAAC;AAAA,aAAI,CAAC,CAAC,KAAN;AAAA,KAAd,CAAf;AACA,IAAA,sBAAsB,CAAC,MAAD,EAAS,KAAT,CAAtB;AAEA,QAAM,GAAG,GAAG,OAAO,CAAC,MAAR,CAAe,QAAf,EAAyB,KAAzB,CAAZ;AACA,IAAA,IAAI,CAAC,QAAD,CAAJ;AACA,WAAO,GAAP;AACD,GAlBD;;AAoBA,MAAM,MAAM,GAAiB,QAA7B;AACA,MAAM,IAAI,GAAgB;AAAC,IAAA,IAAI,EAAJ;AAAD,GAA1B;AAEA,SAAO,MAAM,CAAC,aAAP,CACI,OADJ,EACa,MADb,EAC6C;AAAK;AADlD,IAC8D,MAD9D,EAEI,IAFJ,CAAP;AAGD;;AAED,OAAO,IAAM,MAAM,GAAG,EAAE,CAAC;AAAC,EAAA,OAAO,EAAP;AAAD,CAAD,CAAjB","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../engine';\r\nimport { Concat } from '../kernel_names';\r\nimport { convertToTensorArray } from '../tensor_util_env';\r\nimport { assert, parseAxisParam, sizeFromShape } from '../util';\r\nimport { assertParamsConsistent, computeOutShape } from './concat_util';\r\nimport { op } from './operation';\r\nimport { tensor } from './tensor';\r\n/**\r\n * Concatenates a list of `tf.Tensor`s along a given axis.\r\n *\r\n * The tensors ranks and types must match, and their sizes must match in all\r\n * dimensions except `axis`.\r\n *\r\n * Also available are stricter rank-specific methods that assert that\r\n * `tensors` are of the given rank:\r\n *   - `tf.concat1d`\r\n *   - `tf.concat2d`\r\n *   - `tf.concat3d`\r\n *   - `tf.concat4d`\r\n *\r\n * Except `tf.concat1d` (which does not have axis param), all methods have\r\n * same signature as this method.\r\n *\r\n * ```js\r\n * const a = tf.tensor1d([1, 2]);\r\n * const b = tf.tensor1d([3, 4]);\r\n * a.concat(b).print();  // or a.concat(b)\r\n * ```\r\n *\r\n * ```js\r\n * const a = tf.tensor1d([1, 2]);\r\n * const b = tf.tensor1d([3, 4]);\r\n * const c = tf.tensor1d([5, 6]);\r\n * tf.concat([a, b, c]).print();\r\n * ```\r\n *\r\n * ```js\r\n * const a = tf.tensor2d([[1, 2], [10, 20]]);\r\n * const b = tf.tensor2d([[3, 4], [30, 40]]);\r\n * const axis = 1;\r\n * tf.concat([a, b], axis).print();\r\n * ```\r\n * @param tensors A list of tensors to concatenate.\r\n * @param axis The axis to concate along. Defaults to 0 (the first dim).\r\n *\r\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\r\n */\r\nfunction concat_(tensors, axis = 0) {\r\n    assert(tensors.length >= 1, () => 'Pass at least one tensor to concat');\r\n    let $tensors = convertToTensorArray(tensors, 'tensors', 'concat');\r\n    if ($tensors[0].dtype === 'complex64') {\r\n        $tensors.forEach(tensor => {\r\n            if (tensor.dtype !== 'complex64') {\r\n                throw new Error(`Cannot concatenate complex64 tensors with a tensor\r\n          with dtype ${tensor.dtype}. `);\r\n            }\r\n        });\r\n    }\r\n    const forward = (backend, save) => {\r\n        const $axis = parseAxisParam(axis, $tensors[0].shape)[0];\r\n        const outShape = computeOutShape($tensors.map(t => t.shape), $axis);\r\n        if (sizeFromShape(outShape) === 0) {\r\n            return tensor([], outShape);\r\n        }\r\n        // Keep only non-empty tensors (ignore tensors with 0 in their shape).\r\n        $tensors = $tensors.filter(t => t.size > 0);\r\n        if ($tensors.length === 1) {\r\n            return $tensors[0];\r\n        }\r\n        const shapes = $tensors.map(t => t.shape);\r\n        assertParamsConsistent(shapes, $axis);\r\n        const res = backend.concat($tensors, $axis);\r\n        save($tensors);\r\n        return res;\r\n    };\r\n    const inputs = $tensors;\r\n    const attr = { axis };\r\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, Concat, attr);\r\n}\r\nexport const concat = op({ concat_ });\r\n//# sourceMappingURL=concat.js.map"]},"metadata":{},"sourceType":"module"}