{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../engine';\nimport { StridedSlice } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\nimport { reshape } from './reshape';\nimport { slice } from './slice';\nimport { computeOutShape, getNormalizedAxes, maskToAxes } from './slice_util';\n/**\r\n * Extracts a strided slice of a tensor.\r\n *\r\n * Roughly speaking, this op extracts a slice of size (end-begin)/stride from\r\n * the given input tensor (x). Starting at the location specified by begin the\r\n * slice continues by adding stride to the index until all dimensions are not\r\n * less than end. Note that a stride can be negative, which causes a reverse\r\n * slice.\r\n *\r\n * ```js\r\n * const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],\r\n *    [3, 2, 3]);\r\n * t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]\r\n * t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],\r\n *                                                     // [4, 4, 4]]]\r\n * t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],\r\n *                                                     // [3, 3, 3]]]\r\n * ```\r\n *\r\n * @param x The tensor to stride slice.\r\n * @param begin The coordinates to start the slice from.\r\n * @param end: The coordinates to end the slice at.\r\n * @param strides: The size of the slice.\r\n * @param beginMask: If the ith bit of beginMask is set, begin[i] is ignored\r\n *      and the fullest possible range in that dimension is used instead.\r\n * @param endMask: If the ith bit of endMask is set, end[i] is ignored\r\n *      and the fullest possible range in that dimension is used instead.\r\n * @param shrinkAxisMask: a bitmask where bit i implies that\r\n * the ith specification should shrink the dimensionality. begin and end must\r\n * imply a slice of size 1 in the dimension.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\r\n */\n\nfunction stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {\n  let $x = convertToTensor(x, 'x', 'stridedSlice');\n\n  const forward = backend => {\n    if (strides == null) {\n      strides = new Array(begin.length);\n    }\n\n    const ellipsisAxes = maskToAxes(ellipsisMask);\n\n    if (ellipsisAxes.length > 1) {\n      throw new Error('Multiple ellipses in slice is not allowed.');\n    }\n\n    if (ellipsisMask !== 0 && newAxisMask !== 0) {\n      throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n    }\n\n    if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n      throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n    }\n\n    const numInterpolatedAxes = $x.rank - begin.length; // Expand the dims of x based on the newAxisMask.\n\n    const expandAxes = maskToAxes(newAxisMask);\n    const newShape = $x.shape.slice();\n    expandAxes.forEach(axis => {\n      begin[axis] = 0;\n      end[axis] = 1;\n      newShape.splice(axis, 0, 1);\n    });\n    $x = reshape($x, newShape);\n    const {\n      begin: normalizedBegin,\n      end: normalizedEnd,\n      strides: normalizedStrides\n    } = getNormalizedAxes($x.shape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask);\n    begin = normalizedBegin;\n    end = normalizedEnd;\n    strides = normalizedStrides;\n    const shrinkAxes = maskToAxes(shrinkAxisMask); // Adjust the ends based on the shrink mask.\n\n    shrinkAxes.forEach(axis => {\n      end[axis] = begin[axis] + 1;\n      strides[axis] = 1;\n    }); // Figure out the output shape.\n\n    const size = computeOutShape(begin, end, strides); // Remove the axes based on shrinkMask.\n\n    const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n    const nonStrided = strides.every(v => v === 1);\n\n    if (nonStrided) {\n      return reshape(slice($x, begin, size), outShape);\n    }\n\n    const res = backend.stridedSlice($x, begin, end, strides);\n    return reshape(res, outShape);\n  };\n\n  const inputs = {\n    x: $x\n  };\n  const attrs = {\n    begin,\n    end,\n    strides,\n    beginMask,\n    endMask,\n    ellipsisMask,\n    newAxisMask,\n    shrinkAxisMask\n  };\n  return ENGINE.runKernelFunc(forward, inputs, null\n  /* grad */\n  , StridedSlice, attrs);\n}\n\nexport const stridedSlice = op({\n  stridedSlice_\n});","map":{"version":3,"sources":["../../src/ops/strided_slice.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../engine';\r\nimport { StridedSlice } from '../kernel_names';\r\nimport { convertToTensor } from '../tensor_util_env';\r\nimport { op } from './operation';\r\nimport { reshape } from './reshape';\r\nimport { slice } from './slice';\r\nimport { computeOutShape, getNormalizedAxes, maskToAxes } from './slice_util';\r\n/**\r\n * Extracts a strided slice of a tensor.\r\n *\r\n * Roughly speaking, this op extracts a slice of size (end-begin)/stride from\r\n * the given input tensor (x). Starting at the location specified by begin the\r\n * slice continues by adding stride to the index until all dimensions are not\r\n * less than end. Note that a stride can be negative, which causes a reverse\r\n * slice.\r\n *\r\n * ```js\r\n * const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],\r\n *    [3, 2, 3]);\r\n * t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]\r\n * t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],\r\n *                                                     // [4, 4, 4]]]\r\n * t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],\r\n *                                                     // [3, 3, 3]]]\r\n * ```\r\n *\r\n * @param x The tensor to stride slice.\r\n * @param begin The coordinates to start the slice from.\r\n * @param end: The coordinates to end the slice at.\r\n * @param strides: The size of the slice.\r\n * @param beginMask: If the ith bit of beginMask is set, begin[i] is ignored\r\n *      and the fullest possible range in that dimension is used instead.\r\n * @param endMask: If the ith bit of endMask is set, end[i] is ignored\r\n *      and the fullest possible range in that dimension is used instead.\r\n * @param shrinkAxisMask: a bitmask where bit i implies that\r\n * the ith specification should shrink the dimensionality. begin and end must\r\n * imply a slice of size 1 in the dimension.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\r\n */\r\nfunction stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {\r\n    let $x = convertToTensor(x, 'x', 'stridedSlice');\r\n    const forward = (backend) => {\r\n        if (strides == null) {\r\n            strides = new Array(begin.length);\r\n        }\r\n        const ellipsisAxes = maskToAxes(ellipsisMask);\r\n        if (ellipsisAxes.length > 1) {\r\n            throw new Error('Multiple ellipses in slice is not allowed.');\r\n        }\r\n        if (ellipsisMask !== 0 && newAxisMask !== 0) {\r\n            throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\r\n        }\r\n        if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\r\n            throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\r\n        }\r\n        const numInterpolatedAxes = $x.rank - begin.length;\r\n        // Expand the dims of x based on the newAxisMask.\r\n        const expandAxes = maskToAxes(newAxisMask);\r\n        const newShape = $x.shape.slice();\r\n        expandAxes.forEach(axis => {\r\n            begin[axis] = 0;\r\n            end[axis] = 1;\r\n            newShape.splice(axis, 0, 1);\r\n        });\r\n        $x = reshape($x, newShape);\r\n        const { begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides } = getNormalizedAxes($x.shape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask);\r\n        begin = normalizedBegin;\r\n        end = normalizedEnd;\r\n        strides = normalizedStrides;\r\n        const shrinkAxes = maskToAxes(shrinkAxisMask);\r\n        // Adjust the ends based on the shrink mask.\r\n        shrinkAxes.forEach(axis => {\r\n            end[axis] = begin[axis] + 1;\r\n            strides[axis] = 1;\r\n        });\r\n        // Figure out the output shape.\r\n        const size = computeOutShape(begin, end, strides);\r\n        // Remove the axes based on shrinkMask.\r\n        const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\r\n        const nonStrided = strides.every(v => v === 1);\r\n        if (nonStrided) {\r\n            return reshape(slice($x, begin, size), outShape);\r\n        }\r\n        const res = backend.stridedSlice($x, begin, end, strides);\r\n        return reshape(res, outShape);\r\n    };\r\n    const inputs = { x: $x };\r\n    const attrs = {\r\n        begin,\r\n        end,\r\n        strides,\r\n        beginMask,\r\n        endMask,\r\n        ellipsisMask,\r\n        newAxisMask,\r\n        shrinkAxisMask\r\n    };\r\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, StridedSlice, attrs);\r\n}\r\nexport const stridedSlice = op({ stridedSlice_ });\r\n//# sourceMappingURL=strided_slice.js.map"]},"metadata":{},"sourceType":"module"}