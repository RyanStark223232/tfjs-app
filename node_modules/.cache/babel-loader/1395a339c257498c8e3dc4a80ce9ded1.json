{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nexport var Rank;\n\n(function (Rank) {\n  Rank[\"R0\"] = \"R0\";\n  Rank[\"R1\"] = \"R1\";\n  Rank[\"R2\"] = \"R2\";\n  Rank[\"R3\"] = \"R3\";\n  Rank[\"R4\"] = \"R4\";\n  Rank[\"R5\"] = \"R5\";\n  Rank[\"R6\"] = \"R6\";\n})(Rank || (Rank = {})); // Looks for upcasting types. Used, for example, in operations with mixed dtype\n// inputs.\n\n\nvar UpcastInt32AndMap;\n\n(function (UpcastInt32AndMap) {\n  UpcastInt32AndMap[\"float32\"] = \"float32\";\n  UpcastInt32AndMap[\"int32\"] = \"int32\";\n  UpcastInt32AndMap[\"bool\"] = \"int32\";\n  UpcastInt32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));\n\nvar UpcastBoolAndMap;\n\n(function (UpcastBoolAndMap) {\n  UpcastBoolAndMap[\"float32\"] = \"float32\";\n  UpcastBoolAndMap[\"int32\"] = \"int32\";\n  UpcastBoolAndMap[\"bool\"] = \"bool\";\n  UpcastBoolAndMap[\"complex64\"] = \"complex64\";\n})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));\n\nvar UpcastFloat32AndMap;\n\n(function (UpcastFloat32AndMap) {\n  UpcastFloat32AndMap[\"float32\"] = \"float32\";\n  UpcastFloat32AndMap[\"int32\"] = \"float32\";\n  UpcastFloat32AndMap[\"bool\"] = \"float32\";\n  UpcastFloat32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));\n\nvar UpcastComplex64AndMap;\n\n(function (UpcastComplex64AndMap) {\n  UpcastComplex64AndMap[\"float32\"] = \"complex64\";\n  UpcastComplex64AndMap[\"int32\"] = \"complex64\";\n  UpcastComplex64AndMap[\"bool\"] = \"complex64\";\n  UpcastComplex64AndMap[\"complex64\"] = \"complex64\";\n})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));\n\nconst upcastTypeMap = {\n  'float32': UpcastFloat32AndMap,\n  'int32': UpcastInt32AndMap,\n  'bool': UpcastBoolAndMap,\n  'complex64': UpcastComplex64AndMap\n};\nexport function upcastType(typeA, typeB) {\n  if (typeA === 'string' || typeB === 'string') {\n    if (typeA === 'string' && typeB === 'string') {\n      return 'string';\n    }\n\n    throw new Error(`Can not upcast ${typeA} with ${typeB}`);\n  }\n\n  return upcastTypeMap[typeA][typeB];\n}\n/** Returns the output type after summation. */\n\nexport function sumOutType(type) {\n  return upcastType(type, 'int32');\n}","map":{"version":3,"sources":["../src/types.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAiDH,OAAA,IAAY,IAAZ;;AAAA,CAAA,UAAY,IAAZ,EAAgB;AACd,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACD,CARD,EAAY,IAAI,KAAJ,IAAI,GAAA,EAAA,CAAhB,E,CAmBA;AACA;;;AACA,IAAK,iBAAL;;AAAA,CAAA,UAAK,iBAAL,EAAsB;AACpB,EAAA,iBAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AACA,EAAA,iBAAA,CAAA,OAAA,CAAA,GAAA,OAAA;AACA,EAAA,iBAAA,CAAA,MAAA,CAAA,GAAA,OAAA;AACA,EAAA,iBAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACD,CALD,EAAK,iBAAiB,KAAjB,iBAAiB,GAAA,EAAA,CAAtB;;AAOA,IAAK,gBAAL;;AAAA,CAAA,UAAK,gBAAL,EAAqB;AACnB,EAAA,gBAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AACA,EAAA,gBAAA,CAAA,OAAA,CAAA,GAAA,OAAA;AACA,EAAA,gBAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AACA,EAAA,gBAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACD,CALD,EAAK,gBAAgB,KAAhB,gBAAgB,GAAA,EAAA,CAArB;;AAOA,IAAK,mBAAL;;AAAA,CAAA,UAAK,mBAAL,EAAwB;AACtB,EAAA,mBAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AACA,EAAA,mBAAA,CAAA,OAAA,CAAA,GAAA,SAAA;AACA,EAAA,mBAAA,CAAA,MAAA,CAAA,GAAA,SAAA;AACA,EAAA,mBAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACD,CALD,EAAK,mBAAmB,KAAnB,mBAAmB,GAAA,EAAA,CAAxB;;AAOA,IAAK,qBAAL;;AAAA,CAAA,UAAK,qBAAL,EAA0B;AACxB,EAAA,qBAAA,CAAA,SAAA,CAAA,GAAA,WAAA;AACA,EAAA,qBAAA,CAAA,OAAA,CAAA,GAAA,WAAA;AACA,EAAA,qBAAA,CAAA,MAAA,CAAA,GAAA,WAAA;AACA,EAAA,qBAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACD,CALD,EAAK,qBAAqB,KAArB,qBAAqB,GAAA,EAAA,CAA1B;;AAOA,MAAM,aAAa,GAAG;AACpB,aAAW,mBADS;AAEpB,WAAS,iBAFW;AAGpB,UAAQ,gBAHY;AAIpB,eAAa;AAJO,CAAtB;AAOA,OAAM,SAAU,UAAV,CAAqB,KAArB,EAAsC,KAAtC,EAAqD;AACzD,MAAI,KAAK,KAAK,QAAV,IAAsB,KAAK,KAAK,QAApC,EAA8C;AAC5C,QAAI,KAAK,KAAK,QAAV,IAAsB,KAAK,KAAK,QAApC,EAA8C;AAC5C,aAAO,QAAP;AACD;;AACD,UAAM,IAAI,KAAJ,CAAU,kBAAkB,KAAK,SAAS,KAAK,EAA/C,CAAN;AACD;;AACD,SAAO,aAAa,CAAC,KAAD,CAAb,CAAqB,KAArB,CAAP;AACD;AAED;;AACA,OAAM,SAAU,UAAV,CAAqB,IAArB,EAAmC;AACvC,SAAO,UAAU,CAAC,IAAD,EAAO,OAAP,CAAjB;AACD","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nexport var Rank;\r\n(function (Rank) {\r\n    Rank[\"R0\"] = \"R0\";\r\n    Rank[\"R1\"] = \"R1\";\r\n    Rank[\"R2\"] = \"R2\";\r\n    Rank[\"R3\"] = \"R3\";\r\n    Rank[\"R4\"] = \"R4\";\r\n    Rank[\"R5\"] = \"R5\";\r\n    Rank[\"R6\"] = \"R6\";\r\n})(Rank || (Rank = {}));\r\n// Looks for upcasting types. Used, for example, in operations with mixed dtype\r\n// inputs.\r\nvar UpcastInt32AndMap;\r\n(function (UpcastInt32AndMap) {\r\n    UpcastInt32AndMap[\"float32\"] = \"float32\";\r\n    UpcastInt32AndMap[\"int32\"] = \"int32\";\r\n    UpcastInt32AndMap[\"bool\"] = \"int32\";\r\n    UpcastInt32AndMap[\"complex64\"] = \"complex64\";\r\n})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));\r\nvar UpcastBoolAndMap;\r\n(function (UpcastBoolAndMap) {\r\n    UpcastBoolAndMap[\"float32\"] = \"float32\";\r\n    UpcastBoolAndMap[\"int32\"] = \"int32\";\r\n    UpcastBoolAndMap[\"bool\"] = \"bool\";\r\n    UpcastBoolAndMap[\"complex64\"] = \"complex64\";\r\n})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));\r\nvar UpcastFloat32AndMap;\r\n(function (UpcastFloat32AndMap) {\r\n    UpcastFloat32AndMap[\"float32\"] = \"float32\";\r\n    UpcastFloat32AndMap[\"int32\"] = \"float32\";\r\n    UpcastFloat32AndMap[\"bool\"] = \"float32\";\r\n    UpcastFloat32AndMap[\"complex64\"] = \"complex64\";\r\n})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));\r\nvar UpcastComplex64AndMap;\r\n(function (UpcastComplex64AndMap) {\r\n    UpcastComplex64AndMap[\"float32\"] = \"complex64\";\r\n    UpcastComplex64AndMap[\"int32\"] = \"complex64\";\r\n    UpcastComplex64AndMap[\"bool\"] = \"complex64\";\r\n    UpcastComplex64AndMap[\"complex64\"] = \"complex64\";\r\n})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));\r\nconst upcastTypeMap = {\r\n    'float32': UpcastFloat32AndMap,\r\n    'int32': UpcastInt32AndMap,\r\n    'bool': UpcastBoolAndMap,\r\n    'complex64': UpcastComplex64AndMap\r\n};\r\nexport function upcastType(typeA, typeB) {\r\n    if (typeA === 'string' || typeB === 'string') {\r\n        if (typeA === 'string' && typeB === 'string') {\r\n            return 'string';\r\n        }\r\n        throw new Error(`Can not upcast ${typeA} with ${typeB}`);\r\n    }\r\n    return upcastTypeMap[typeA][typeB];\r\n}\r\n/** Returns the output type after summation. */\r\nexport function sumOutType(type) {\r\n    return upcastType(type, 'int32');\r\n}\r\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"module"}