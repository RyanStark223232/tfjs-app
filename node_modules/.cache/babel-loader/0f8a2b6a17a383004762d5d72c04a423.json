{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nconst CHECK_NAN_SNIPPET = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\nexport const ADD = 'return a + b;';\nexport const SUB = 'return a - b;';\nexport const MUL = 'return a * b;'; // We use native integer division to deal with floating point imprecision. Since\n// we implement floor division and glsl implements truncated division, we\n// correct for this by subtracting 1 from result when the result is negative and\n// there is a remainder.\n\nexport const INT_DIV = `\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`;\nexport const POW = `\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;\nexport const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\nexport const EQUAL = `return float(a == b);`;\nexport const NOT_EQUAL = `return float(a != b);`;\nexport const LESS = `return float(a < b);`;\nexport const LESS_EQUAL = `return float(a <= b);`;\nexport const GREATER = `return float(a > b);`;\nexport const GREATER_EQUAL = `return float(a >= b);`;\nexport const LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;\nexport const LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;\nexport const MAX = CHECK_NAN_SNIPPET + `\n  return max(a, b);\n`;\nexport const MIN = CHECK_NAN_SNIPPET + `\n  return min(a, b);\n`;\nexport const MOD = `if (b == 0.0) return NAN;\n  return mod(a, b);`;\nexport const ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;\nexport const PRELU = `return (a < 0.) ? b * a : a;`;\nexport class BinaryOpProgram {\n  constructor(op, aShape, bShape) {\n    this.variableNames = ['A', 'B'];\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${op}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `;\n  }\n\n}","map":{"version":3,"sources":["../src/binaryop_gpu.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,YAAR,QAA2B,uBAA3B;AAIA,MAAM,iBAAiB,GAAG;;;AAGzB,CAHD;AAKA,OAAO,MAAM,GAAG,GAAG,eAAZ;AACP,OAAO,MAAM,GAAG,GAAG,eAAZ;AACP,OAAO,MAAM,GAAG,GAAG,eAAZ,C,CAEP;AACA;AACA;AACA;;AACA,OAAO,MAAM,OAAO,GAAG;;;;;;;;;;AAUtB,CAVM;AAYP,OAAO,MAAM,GAAG,GAAG;;;;;;;;;AASlB,CATM;AAUP,OAAO,MAAM,kBAAkB,GAAG,2BAA3B;AAEP,OAAO,MAAM,KAAK,GAAG,uBAAd;AAEP,OAAO,MAAM,SAAS,GAAG,uBAAlB;AAEP,OAAO,MAAM,IAAI,GAAG,sBAAb;AAEP,OAAO,MAAM,UAAU,GAAG,uBAAnB;AAEP,OAAO,MAAM,OAAO,GAAG,sBAAhB;AAEP,OAAO,MAAM,aAAa,GAAG,uBAAtB;AAEP,OAAO,MAAM,WAAW,GAAG,qCAApB;AAEP,OAAO,MAAM,UAAU,GAAG,qCAAnB;AAEP,OAAO,MAAM,GAAG,GAAG,iBAAiB,GAAG;;AAEtC,CAFM;AAGP,OAAO,MAAM,GAAG,GAAG,iBAAiB,GAAG;;AAEtC,CAFM;AAGP,OAAO,MAAM,GAAG,GAAG;AACC,oBADb;AAGP,OAAO,MAAM,OAAO,GAAG,wCAAhB;AAEP,OAAO,MAAM,KAAK,GAAG,8BAAd;AAEP,OAAM,MAAO,eAAP,CAAsB;AAK1B,EAAA,WAAA,CAAY,EAAZ,EAAwB,MAAxB,EAA0C,MAA1C,EAA0D;AAJ1D,SAAA,aAAA,GAAgB,CAAC,GAAD,EAAM,GAAN,CAAhB;AAKE,SAAK,WAAL,GAAmB,YAAY,CAAC,0BAAb,CAAwC,MAAxC,EAAgD,MAAhD,CAAnB;AACA,SAAK,QAAL,GAAgB;;UAEV,EAAE;;;;;;;;AAQP,KAVD;AAWD;;AAlByB","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { backend_util } from '@tensorflow/tfjs-core';\r\nconst CHECK_NAN_SNIPPET = `\r\n  if (isnan(a)) return a;\r\n  if (isnan(b)) return b;\r\n`;\r\nexport const ADD = 'return a + b;';\r\nexport const SUB = 'return a - b;';\r\nexport const MUL = 'return a * b;';\r\n// We use native integer division to deal with floating point imprecision. Since\r\n// we implement floor division and glsl implements truncated division, we\r\n// correct for this by subtracting 1 from result when the result is negative and\r\n// there is a remainder.\r\nexport const INT_DIV = `\r\n  float s = sign(a) * sign(b);\r\n  int ia = round(a);\r\n  int ib = round(b);\r\n  if (ib != 0) {\r\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\r\n    return float(idiv(ia, ib, s));\r\n  } else {\r\n    return NAN;\r\n  }\r\n`;\r\nexport const POW = `\r\nif(a < 0.0 && floor(b) < b){\r\n  return NAN;\r\n}\r\nif (b == 0.0) {\r\n  return 1.0;\r\n}\r\nreturn (round(mod(b, 2.0)) != 1) ?\r\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\r\n`;\r\nexport const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\r\nexport const EQUAL = `return float(a == b);`;\r\nexport const NOT_EQUAL = `return float(a != b);`;\r\nexport const LESS = `return float(a < b);`;\r\nexport const LESS_EQUAL = `return float(a <= b);`;\r\nexport const GREATER = `return float(a > b);`;\r\nexport const GREATER_EQUAL = `return float(a >= b);`;\r\nexport const LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;\r\nexport const LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;\r\nexport const MAX = CHECK_NAN_SNIPPET + `\r\n  return max(a, b);\r\n`;\r\nexport const MIN = CHECK_NAN_SNIPPET + `\r\n  return min(a, b);\r\n`;\r\nexport const MOD = `if (b == 0.0) return NAN;\r\n  return mod(a, b);`;\r\nexport const ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;\r\nexport const PRELU = `return (a < 0.) ? b * a : a;`;\r\nexport class BinaryOpProgram {\r\n    constructor(op, aShape, bShape) {\r\n        this.variableNames = ['A', 'B'];\r\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\r\n        this.userCode = `\r\n      float binaryOperation(float a, float b) {\r\n        ${op}\r\n      }\r\n\r\n      void main() {\r\n        float a = getAAtOutCoords();\r\n        float b = getBAtOutCoords();\r\n        setOutput(binaryOperation(a, b));\r\n      }\r\n    `;\r\n    }\r\n}\r\n//# sourceMappingURL=binaryop_gpu.js.map"]},"metadata":{},"sourceType":"module"}