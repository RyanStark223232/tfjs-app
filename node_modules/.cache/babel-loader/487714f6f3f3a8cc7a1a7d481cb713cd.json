{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"C:\\\\Users\\\\wongh\\\\finger\\\\src\\\\App.js\";\nimport React from \"react\";\nimport * as handpose from \"@tensorflow-models/handpose\"; //import * as tf from '@tensorflow/tfjs';\n\nimport Webcam from \"react-webcam\";\nimport \"./App.css\";\nimport { drawHand } from \"./utilities\";\nimport { sqrt, pow } from \"mathjs\";\nimport { Line } from 'react-chartjs-2';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.sleep = milliseconds => {\n      return new Promise(resolve => setTimeout(resolve, milliseconds));\n    };\n\n    this.record_estimateHands = async (img, net) => {\n      const hand = await net.estimateHands(img);\n      if (hand.length > 0) console.log(\"On Screen\");else console.log(\"Off Screen\");\n    };\n\n    this.state = {\n      ID: 0,\n      tap_count: [],\n      rotate_count: [],\n      fist_count: [],\n      index_passed: 0,\n      rotate_passed: 0,\n      last_pressed: 0,\n      real_time_inferencing: false,\n      recording: false,\n      button_mode: false,\n      chart_ready: false,\n      finger_done: false,\n      rotate_done: false,\n      fist_done: false,\n      dist_array: [],\n      dist_time_array: [],\n      dist_record: [],\n      dist_time_record: [],\n      rotate_array: [],\n      rotate_time_array: [],\n      rotate_record: [],\n      rotate_time_record: [],\n      fist_array: [],\n      fist_time_array: [],\n      fist_record: [],\n      fist_time_record: [],\n      chart_data1: null,\n      chart_data2: null,\n      chart_data3: null,\n      wait: false,\n      startAt: Date.now(),\n      dead_frame: 0\n    };\n    this.webcamRef = /*#__PURE__*/React.createRef(null);\n    this.canvasRef = /*#__PURE__*/React.createRef(null);\n    this.runHandpose = this.runHandpose.bind(this);\n    this.stop_real_time_inference = this.stop_real_time_inference.bind(this);\n    this.stop_tapping = this.stop_tapping.bind(this);\n    this.stop_rotating = this.stop_rotating.bind(this);\n    this.stop_record = this.stop_record.bind(this);\n    this.record_video = this.record_video.bind(this);\n    this.concat_frame = this.concat_frame.bind(this);\n    this.inference = this.inference.bind(this);\n    this.reset_counter = this.reset_counter.bind(this);\n    this.increment_tap1 = this.increment_tap1.bind(this);\n    this.increment_tap2 = this.increment_tap2.bind(this);\n    this.switch_button = this.switch_button.bind(this);\n    this.compose_chart = this.compose_chart.bind(this);\n  }\n\n  compose_chart() {\n    let time_array_1 = [];\n    let count_array_1 = [];\n    let start = this.state.dist_time_array[0];\n    let end = this.state.dist_time_array[this.state.dist_time_array.length - 1];\n\n    while (start + 1.0 < end) {\n      time_array_1 = [...time_array_1, start];\n      let count = 0,\n          temp_max = 0;\n\n      for (let i = 0; i < this.state.dist_array.length; i++) {\n        if (this.state.dist_time_array[i] >= start && this.state.dist_time_array[i] < start + 1.0) {\n          if (temp_max < this.state.dist_array[i]) temp_max = this.state.dist_array[i];\n\n          if (this.state.tap_count.includes(this.state.dist_time_array[i])) {\n            count += temp_max;\n            temp_max = 0;\n          }\n        }\n      }\n      /*\n      \n      let time_value = 0;\n      for (let tc in this.state.tap_count){\n        time_value = this.state.tap_count[tc];\n        if (time_value >= start && time_value < (start + 1.0)){\n          count += 1;\n        }\n      }\n      */\n\n\n      count_array_1 = [...count_array_1, count];\n      start += 0.1;\n    }\n\n    const data1 = {\n      labels: time_array_1,\n      datasets: [{\n        label: 'Tapping',\n        fill: false,\n        lineTension: 0.3,\n        backgroundColor: 'rgba(75,192,192,0.4)',\n        borderColor: 'rgba(75,192,192,1)',\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0.0,\n        borderJoinStyle: 'miter',\n        pointBorderColor: 'rgba(75,192,192,1)',\n        pointBackgroundColor: '#fff',\n        pointBorderWidth: 1,\n        pointHoverRadius: 5,\n        pointHoverBackgroundColor: 'rgba(75,192,192,1)',\n        pointHoverBorderColor: 'rgba(220,220,220,1)',\n        pointHoverBorderWidth: 2,\n        pointRadius: 1,\n        pointHitRadius: 10,\n        data: count_array_1\n      }]\n    };\n    let time_array_2 = [];\n    let count_array_2 = [];\n    start = this.state.rotate_time_array[0];\n    end = this.state.rotate_time_array[this.state.rotate_time_array.length - 1];\n\n    while (start + 5.0 < end) {\n      time_array_2 = [...time_array_2, start + 2.5];\n      let count = 0;\n      let time_value = 0;\n\n      for (let tc in this.state.rotate_count) {\n        time_value = this.state.rotate_count[tc];\n\n        if (time_value >= start && time_value < start + 5.0) {\n          count += 1;\n        }\n      }\n\n      count_array_2 = [...count_array_2, count];\n      start += 0.1;\n    }\n\n    const data2 = {\n      labels: time_array_2,\n      datasets: [{\n        label: 'Rotation',\n        fill: false,\n        lineTension: 0.1,\n        backgroundColor: 'rgba(192,75,192,0.4)',\n        borderColor: 'rgba(192,75,192,1)',\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0.0,\n        borderJoinStyle: 'miter',\n        pointBorderColor: 'rgba(192,75,192,1)',\n        pointBackgroundColor: '#fff',\n        pointBorderWidth: 1,\n        pointHoverRadius: 5,\n        pointHoverBackgroundColor: 'rgba(192,75,192,1)',\n        pointHoverBorderColor: 'rgba(220,220,220,1)',\n        pointHoverBorderWidth: 2,\n        pointRadius: 1,\n        pointHitRadius: 10,\n        data: count_array_2\n      }]\n    };\n    let time_array_3 = [];\n    let count_array_3 = [];\n    start = this.state.fist_time_array[0];\n    end = this.state.fist_time_array[this.state.fist_time_array.length - 1];\n\n    while (start + 5.0 < end) {\n      time_array_3 = [...time_array_3, start + 2.5];\n      let count = 0;\n      let time_value = 0;\n\n      for (let tc in this.state.fist_count) {\n        time_value = this.state.fist_count[tc];\n\n        if (time_value >= start && time_value < start + 5.0) {\n          count += 1;\n        }\n      }\n\n      count_array_3 = [...count_array_3, count];\n      start += 0.1;\n    }\n\n    const data3 = {\n      labels: time_array_3,\n      datasets: [{\n        label: 'Fist',\n        fill: false,\n        lineTension: 0.1,\n        backgroundColor: 'rgba(192,192,75,0.4)',\n        borderColor: 'rgba(192,192,75,1)',\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0.0,\n        borderJoinStyle: 'miter',\n        pointBorderColor: 'rgba(192,192,75,1)',\n        pointBackgroundColor: '#fff',\n        pointBorderWidth: 1,\n        pointHoverRadius: 5,\n        pointHoverBackgroundColor: 'rgba(192,192,75,1)',\n        pointHoverBorderColor: 'rgba(220,220,220,1)',\n        pointHoverBorderWidth: 2,\n        pointRadius: 1,\n        pointHitRadius: 10,\n        data: count_array_3\n      }]\n    };\n    this.setState({\n      chart_data1: data1\n    });\n    this.setState({\n      chart_data2: data2\n    });\n    this.setState({\n      chart_data3: data3\n    });\n    this.setState({\n      chart_ready: true\n    });\n  }\n\n  switch_button() {\n    if (this.state.button_mode === true) {\n      this.setState({\n        button_mode: false\n      });\n    } else {\n      this.setState({\n        button_mode: true\n      });\n    }\n  }\n\n  increment_tap1() {\n    if (this.state.last_pressed !== 1) {\n      this.setState({\n        last_pressed: 1\n      });\n      this.setState({\n        count: this.state.count + 1\n      });\n    }\n  }\n\n  increment_tap2() {\n    if (this.state.last_pressed !== 2) {\n      this.setState({\n        last_pressed: 2\n      });\n      this.setState({\n        count: this.state.count + 1\n      });\n    }\n  }\n\n  norm(lm1, lm2) {\n    return sqrt(pow(lm1[0] - lm2[0], 2) + pow(lm1[1] - lm2[1], 2));\n  }\n\n  reset_counter() {\n    clearInterval(this.state.ID);\n    this.setState({\n      ID: 0,\n      tap_count: [],\n      rotate_count: [],\n      fist_count: [],\n      index_passed: 0,\n      rotate_passed: 0,\n      fist_passed: 0,\n      last_pressed: 0,\n      real_time_inferencing: false,\n      recording: false,\n      button_mode: false,\n      chart_ready: false,\n      finger_done: false,\n      rotate_done: false,\n      fist_done: false,\n      record: [],\n      dist_time_array: [],\n      dist_array: [],\n      rotate_time_array: [],\n      rotate_array: [],\n      fist_time_array: [],\n      fist_array: [],\n      chart_data1: null,\n      chart_data2: null,\n      chart_data3: null,\n      startAt: Date.now(),\n      dead_frame: 0\n    });\n  }\n\n  async runHandpose() {\n    require('@tensorflow/tfjs-backend-cpu'); //const uploadJSONInput = document.getElementById('upload-json');\n    //const uploadWeightsInput = document.getElementById('upload-weights');\n    //const model = await tf.loadLayersModel(tf.io.browserFiles([uploadJSONInput.files[0], uploadWeightsInput.files[0]]));\n\n\n    const net = await handpose.load();\n    console.log(\"Handpose model loaded.\");\n    this.setState({\n      startAt: Date.now()\n    });\n    const Interval_ID = setInterval(() => {\n      this.read_time_inference(net);\n    }, 50);\n    this.setState({\n      ID: Interval_ID\n    });\n    this.setState({\n      real_time_inferencing: true\n    });\n  }\n\n  async read_time_inference(net) {\n    if (this.state.wait) {\n      await this.sleep(3000);\n      this.setState({\n        wait: false\n      });\n    }\n\n    if (typeof this.webcamRef.current !== \"undefined\" && this.webcamRef.current !== null && this.webcamRef.current.video.readyState === 4) {\n      const video = this.webcamRef.current.video;\n      const videoWidth = this.webcamRef.current.video.videoWidth;\n      const videoHeight = this.webcamRef.current.video.videoHeight;\n      this.webcamRef.current.video.width = videoWidth;\n      this.webcamRef.current.video.height = videoHeight;\n      this.canvasRef.current.width = videoWidth;\n      this.canvasRef.current.height = videoHeight;\n      const hand = await net.estimateHands(video);\n\n      if (hand.length > 0) {\n        hand.forEach(prediction => {\n          this.setState({\n            dead_frame: 0\n          });\n          const landmarks = prediction.landmarks;\n          let pawn_dist = this.norm(landmarks[0], landmarks[2]);\n          let current_moment = (Date.now() - this.state.startAt) / 1000;\n\n          if (this.state.finger_done === false) {\n            let index_dist = this.norm(landmarks[4], landmarks[8]);\n            index_dist = index_dist / pawn_dist;\n            this.setState({\n              dist_array: [...this.state.dist_array, index_dist]\n            });\n            this.setState({\n              dist_time_array: [...this.state.dist_time_array, current_moment]\n            });\n\n            if (index_dist >= 0.5) {\n              this.setState({\n                index_passed: 1\n              });\n            }\n\n            if (index_dist < 0.5 && this.state.index_passed === 1) {\n              this.setState({\n                index_passed: 0\n              });\n              this.setState({\n                tap_count: [...this.state.tap_count, current_moment]\n              });\n            }\n          }\n\n          if (this.state.finger_done === true && this.state.rotate_done === false) {\n            let rotate_dist = (landmarks[2][0] - landmarks[17][0]) / pawn_dist;\n            this.setState({\n              rotate_array: [...this.state.rotate_array, rotate_dist]\n            });\n            this.setState({\n              rotate_time_array: [...this.state.rotate_time_array, current_moment]\n            });\n\n            if (this.state.rotate_passed === 0) {\n              if (rotate_dist >= 0.5) this.setState({\n                rotate_passed: 1\n              });\n              if (rotate_dist <= -0.5) this.setState({\n                rotate_passed: -1\n              });\n            }\n\n            if (this.state.rotate_passed === 1 && rotate_dist <= -0.5) {\n              this.setState({\n                rotate_passed: -1\n              });\n            }\n\n            if (this.state.rotate_passed === -1 && rotate_dist >= 0.5) {\n              this.setState({\n                rotate_passed: 1\n              });\n              this.setState({\n                rotate_count: [...this.state.rotate_count, current_moment]\n              });\n            }\n          }\n\n          if (this.state.rotate_done === true && this.state.fist_done === false) {\n            let fist_dist = (landmarks[8][1] - landmarks[5][1] + (landmarks[12][1] - landmarks[9][1]) + (landmarks[16][1] - landmarks[13][1]) + (landmarks[20][1] - landmarks[17][1])) / (4 * pawn_dist);\n            this.setState({\n              fist_array: [...this.state.fist_array, fist_dist]\n            });\n            this.setState({\n              fist_time_array: [...this.state.fist_time_array, current_moment]\n            });\n\n            if (fist_dist >= 0.0) {\n              this.setState({\n                fist_passed: 1\n              });\n            }\n\n            if (fist_dist < -0.4 && this.state.fist_passed === 1) {\n              this.setState({\n                fist_passed: 0\n              });\n              this.setState({\n                fist_count: [...this.state.fist_count, current_moment]\n              });\n            }\n          }\n\n          const ctx = this.canvasRef.current.getContext(\"2d\");\n          this.setState({\n            context: ctx\n          });\n          drawHand(hand, ctx);\n        });\n      }\n      /*\n      else{\n        if (this.state.dist_array.length !== 0){\n          this.setState({dead_frame: this.state.dead_frame+1});\n          if (this.state.dead_frame >= 10) this.stop_real_time_inference();\n        }\n      }\n      */\n\n    }\n  }\n\n  async stop_tapping() {\n    this.setState({\n      finger_done: true\n    });\n    this.setState({\n      wait: true\n    });\n  }\n\n  async stop_rotating() {\n    this.setState({\n      rotate_done: true\n    });\n    this.setState({\n      wait: true\n    });\n  }\n\n  stop_real_time_inference() {\n    clearInterval(this.state.ID);\n    this.setState({\n      real_time_inferencing: false,\n      finger_done: false,\n      rotate_done: false,\n      fist_done: false\n    });\n    this.compose_chart();\n  }\n\n  async record_video() {\n    this.setState({\n      startAt: Date.now()\n    });\n    let count = 0;\n\n    require('@tensorflow/tfjs-backend-cpu');\n\n    const net = await handpose.load();\n    console.log(\"Handpose model loaded.\");\n    const Interval_ID = setInterval(() => {\n      this.concat_frame(count, net);\n      count = (count + 1) % 20;\n    }, 50);\n    this.setState({\n      ID: Interval_ID\n    });\n    this.setState({\n      recording: true\n    });\n  }\n\n  async concat_frame(count, net) {\n    if (this.state.wait) {\n      await this.sleep(3000);\n      this.setState({\n        wait: false\n      });\n    }\n\n    if (typeof this.webcamRef.current !== \"undefined\" && this.webcamRef.current !== null && this.webcamRef.current.video.readyState === 4) {\n      let current_moment = (Date.now() - this.state.startAt) / 1000;\n      const image = this.webcamRef.current.getScreenshot();\n      var img = document.createElement(\"img\");\n\n      img.onload = function () {\n        if (this.state.finger_done === false) {\n          this.setState({\n            dist_record: [...this.state.dist_record, img]\n          });\n          this.setState({\n            dist_time_record: [...this.state.dist_time_record, current_moment]\n          });\n        } else if (this.state.finger_done === true && this.state.rotate_done === false) {\n          this.setState({\n            rotate_record: [...this.state.rotate_record, img]\n          });\n          this.setState({\n            rotate_time_record: [...this.state.rotate_time_record, current_moment]\n          });\n        } else if (this.state.rotate_done === true && this.state.fist_done === false) {\n          this.setState({\n            fist_record: [...this.state.fist_record, img]\n          });\n          this.setState({\n            fist_time_record: [...this.state.fist_time_record, current_moment]\n          });\n        }\n\n        if (count === 0) this.record_estimateHands(img, net);\n      }.bind(this);\n\n      img.src = image;\n    }\n  }\n\n  async inference() {\n    require('@tensorflow/tfjs-backend-cpu');\n\n    const net = await handpose.load();\n    console.log(\"Handpose model loaded.\"); // Run prediction on recorded tapping data\n\n    for (let i = 0; i < this.state.dist_record.length; i++) {\n      const hand = await net.estimateHands(this.state.dist_record[i]);\n\n      if (hand.length > 0) {\n        hand.forEach(prediction => {\n          const landmarks = prediction.landmarks;\n          let pawn_dist = this.norm(landmarks[0], landmarks[2]);\n          let index_dist = this.norm(landmarks[4], landmarks[8]);\n          index_dist = index_dist / pawn_dist;\n          this.setState({\n            dist_array: [...this.state.dist_array, index_dist]\n          });\n          this.setState({\n            dist_time_array: [...this.state.dist_time_array, this.state.dist_time_record[i]]\n          });\n\n          if (index_dist >= 0.5) {\n            this.setState({\n              index_passed: 1\n            });\n          }\n\n          if (index_dist < 0.5 && this.state.index_passed === 1) {\n            this.setState({\n              index_passed: 0\n            });\n            this.setState({\n              tap_count: [...this.state.tap_count, this.state.dist_time_record[i]]\n            });\n          }\n\n          console.log(\"INDEX COUNT:\", this.state.tap_count);\n        });\n      }\n    } // Run prediction on recorded rotation data\n\n\n    for (let i = 0; i < this.state.rotate_record.length; i++) {\n      const hand = await net.estimateHands(this.state.rotate_record[i]);\n\n      if (hand.length > 0) {\n        hand.forEach(prediction => {\n          const landmarks = prediction.landmarks;\n          let pawn_dist = this.norm(landmarks[0], landmarks[2]);\n          let rotate_dist = (landmarks[2][0] - landmarks[17][0]) / pawn_dist;\n          this.setState({\n            rotate_array: [...this.state.rotate_array, rotate_dist]\n          });\n          this.setState({\n            rotate_time_array: [...this.state.rotate_time_array, this.state.rotate_time_record[i]]\n          });\n\n          if (this.state.rotate_passed === 0) {\n            if (rotate_dist >= 0.5) this.setState({\n              rotate_passed: 1\n            });\n            if (rotate_dist <= -0.5) this.setState({\n              rotate_passed: -1\n            });\n          }\n\n          if (this.state.rotate_passed === 1 && rotate_dist <= -0.5) {\n            this.setState({\n              rotate_passed: -1\n            });\n          }\n\n          if (this.state.rotate_passed === -1 && rotate_dist >= 0.5) {\n            this.setState({\n              rotate_passed: 1\n            });\n            this.setState({\n              rotate_count: [...this.state.rotate_count, this.state.rotate_time_record[i]]\n            });\n          }\n\n          console.log(\"ROTATE COUNT:\", this.state.rotate_count);\n        });\n      }\n    } // Run prediction on recorded gripping data\n\n\n    for (let i = 0; i < this.state.fist_record.length; i++) {\n      const hand = await net.estimateHands(this.state.fist_record[i]);\n\n      if (hand.length > 0) {\n        hand.forEach(prediction => {\n          const landmarks = prediction.landmarks;\n          let pawn_dist = this.norm(landmarks[0], landmarks[2]);\n          let fist_dist = (landmarks[8][1] - landmarks[5][1] + (landmarks[12][1] - landmarks[9][1]) + (landmarks[16][1] - landmarks[13][1]) + (landmarks[20][1] - landmarks[17][1])) / (4 * pawn_dist);\n          this.setState({\n            fist_array: [...this.state.fist_array, fist_dist]\n          });\n          this.setState({\n            fist_time_array: [...this.state.fist_time_array, this.state.fist_time_record[i]]\n          });\n\n          if (fist_dist >= 0.0) {\n            this.setState({\n              fist_passed: 1\n            });\n          }\n\n          if (fist_dist < -0.4 && this.state.fist_passed === 1) {\n            this.setState({\n              fist_passed: 0\n            });\n            this.setState({\n              fist_count: [...this.state.fist_count, this.state.fist_time_record[i]]\n            });\n          }\n\n          console.log(\"FIST COUNT:\", this.state.fist_count);\n        });\n      }\n    }\n\n    this.setState({\n      record: []\n    });\n  }\n\n  async stop_record() {\n    clearInterval(this.state.ID);\n    await this.inference();\n    this.setState({\n      recording: false\n    });\n    this.compose_chart();\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App\",\n      children: [/*#__PURE__*/_jsxDEV(\"header\", {\n        className: \"App-header\",\n        children: [/*#__PURE__*/_jsxDEV(Webcam, {\n          ref: this.webcamRef,\n          style: {\n            position: \"absolute\",\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            left: 0,\n            right: 0,\n            textAlign: \"center\",\n            zindex: 9,\n            width: \"auto\",\n            height: \"auto\"\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 540,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n          ref: this.canvasRef,\n          style: {\n            position: \"absolute\",\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            left: 0,\n            right: 0,\n            textAlign: \"center\",\n            zindex: 9,\n            width: \"auto\",\n            height: \"auto\"\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 554,\n          columnNumber: 9\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 539,\n        columnNumber: 9\n      }, this), this.state.button_mode ? /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: this.increment_tap1,\n          id: \"button1\",\n          children: \"Index Finger\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 571,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: this.increment_tap2,\n          id: \"button2\",\n          children: \"Middle Finger\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 572,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 570,\n        columnNumber: 13\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 575,\n        columnNumber: 13\n      }, this), this.state.real_time_inferencing ? this.state.finger_done ? this.state.rotate_done ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.stop_real_time_inference,\n        children: \"Calculate Result\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 580,\n        columnNumber: 17\n      }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.stop_rotating,\n        children: \"Finish Rotating\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 582,\n        columnNumber: 17\n      }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.stop_tapping,\n        children: \"Finish Tapping\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 585,\n        columnNumber: 15\n      }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.runHandpose,\n        children: \"Starting Real Time Inference\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 588,\n        columnNumber: 11\n      }, this), this.state.recording ? this.state.finger_done ? this.state.rotate_done ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.stop_record,\n        children: \"Calculate Result\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 594,\n        columnNumber: 17\n      }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.stop_rotating,\n        children: \"Finish Rotating\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 596,\n        columnNumber: 17\n      }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.stop_tapping,\n        children: \"Finish Tapping\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 599,\n        columnNumber: 15\n      }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.record_video,\n        children: \"Starting Recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 602,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.reset_counter,\n        children: \"Reset Counter\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 605,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.switch_button,\n        children: \"Switch On/Off Button\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 606,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"h5\", {\n        children: [\"Finger Tapping Count: \", this.state.tap_count.length]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 607,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"h5\", {\n        children: [\"Rotate Count: \", this.state.rotate_count.length]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 608,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"h5\", {\n        children: [\"Gripping Count: \", this.state.fist_count.length]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 609,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [this.state.chart_ready ? /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [/*#__PURE__*/_jsxDEV(Line, {\n            data: this.state.chart_data1\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 613,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(Line, {\n            data: this.state.chart_data2\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 614,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(Line, {\n            data: this.state.chart_data3\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 615,\n            columnNumber: 17\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 612,\n          columnNumber: 15\n        }, this) : /*#__PURE__*/_jsxDEV(\"div\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 618,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: /*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"file\",\n            id: \"upload-json\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 621,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 620,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: /*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"file\",\n            id: \"upload-weights\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 624,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 623,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 610,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 538,\n      columnNumber: 7\n    }, this);\n  }\n\n}\n\nexport default App;","map":{"version":3,"sources":["C:/Users/wongh/finger/src/App.js"],"names":["React","handpose","Webcam","drawHand","sqrt","pow","Line","App","Component","constructor","props","sleep","milliseconds","Promise","resolve","setTimeout","record_estimateHands","img","net","hand","estimateHands","length","console","log","state","ID","tap_count","rotate_count","fist_count","index_passed","rotate_passed","last_pressed","real_time_inferencing","recording","button_mode","chart_ready","finger_done","rotate_done","fist_done","dist_array","dist_time_array","dist_record","dist_time_record","rotate_array","rotate_time_array","rotate_record","rotate_time_record","fist_array","fist_time_array","fist_record","fist_time_record","chart_data1","chart_data2","chart_data3","wait","startAt","Date","now","dead_frame","webcamRef","createRef","canvasRef","runHandpose","bind","stop_real_time_inference","stop_tapping","stop_rotating","stop_record","record_video","concat_frame","inference","reset_counter","increment_tap1","increment_tap2","switch_button","compose_chart","time_array_1","count_array_1","start","end","count","temp_max","i","includes","data1","labels","datasets","label","fill","lineTension","backgroundColor","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","pointBorderColor","pointBackgroundColor","pointBorderWidth","pointHoverRadius","pointHoverBackgroundColor","pointHoverBorderColor","pointHoverBorderWidth","pointRadius","pointHitRadius","data","time_array_2","count_array_2","time_value","tc","data2","time_array_3","count_array_3","data3","setState","norm","lm1","lm2","clearInterval","fist_passed","record","require","load","Interval_ID","setInterval","read_time_inference","current","video","readyState","videoWidth","videoHeight","width","height","forEach","prediction","landmarks","pawn_dist","current_moment","index_dist","rotate_dist","fist_dist","ctx","getContext","context","image","getScreenshot","document","createElement","onload","src","render","position","marginLeft","marginRight","left","right","textAlign","zindex"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport * as handpose from \"@tensorflow-models/handpose\";\n//import * as tf from '@tensorflow/tfjs';\nimport Webcam from \"react-webcam\";\nimport \"./App.css\";\nimport { drawHand } from \"./utilities\";\nimport { sqrt, pow } from \"mathjs\"\nimport {Line} from 'react-chartjs-2';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      ID : 0,\n      tap_count : [],\n      rotate_count : [],\n      fist_count : [],\n      index_passed : 0,\n      rotate_passed : 0,\n      last_pressed:0,\n      real_time_inferencing:false,\n      recording:false,\n      button_mode:false,\n      chart_ready:false,\n      finger_done : false,\n      rotate_done : false,\n      fist_done : false,\n      dist_array : [],\n      dist_time_array : [],\n      dist_record : [],\n      dist_time_record : [],\n      rotate_array : [],\n      rotate_time_array : [],\n      rotate_record : [],\n      rotate_time_record : [],\n      fist_array : [],\n      fist_time_array : [],\n      fist_record : [],\n      fist_time_record : [],\n      chart_data1 : null,\n      chart_data2 : null,\n      chart_data3 : null,\n      wait : false,\n      startAt: Date.now(),\n      dead_frame: 0,\n    };\n    this.webcamRef = React.createRef(null);\n    this.canvasRef = React.createRef(null);\n    this.runHandpose = this.runHandpose.bind(this);\n    this.stop_real_time_inference = this.stop_real_time_inference.bind(this);\n    this.stop_tapping = this.stop_tapping.bind(this);\n    this.stop_rotating = this.stop_rotating.bind(this);\n    this.stop_record = this.stop_record.bind(this);\n    this.record_video = this.record_video.bind(this);\n    this.concat_frame = this.concat_frame.bind(this);\n    this.inference = this.inference.bind(this);\n    this.reset_counter = this.reset_counter.bind(this);\n    this.increment_tap1 = this.increment_tap1.bind(this);\n    this.increment_tap2 = this.increment_tap2.bind(this);\n    this.switch_button = this.switch_button.bind(this);\n    this.compose_chart = this.compose_chart.bind(this);\n  }\n\n  compose_chart(){\n    let time_array_1 = [];\n    let count_array_1 = [];\n    let start = this.state.dist_time_array[0];\n    let end = this.state.dist_time_array[this.state.dist_time_array.length - 1];\n    while (start + 1.0 < end){\n      time_array_1 = [...time_array_1, start];\n      let count = 0, temp_max = 0;\n      for (let i = 0; i < this.state.dist_array.length; i++){        \n        if (this.state.dist_time_array[i] >= start && this.state.dist_time_array[i] < (start + 1.0)){\n          if (temp_max < this.state.dist_array[i]) temp_max = this.state.dist_array[i];\n          if (this.state.tap_count.includes(this.state.dist_time_array[i])){\n            count += temp_max;\n            temp_max = 0;\n          }\n        }\n      }\n      /*\n      \n      let time_value = 0;\n      for (let tc in this.state.tap_count){\n        time_value = this.state.tap_count[tc];\n        if (time_value >= start && time_value < (start + 1.0)){\n          count += 1;\n        }\n      }\n      */\n      count_array_1 = [...count_array_1, count];\n      start += 0.1;\n    }\n    const data1 = {\n      labels: time_array_1,\n      datasets: [        \n        {\n          label: 'Tapping',\n          fill: false,\n          lineTension: 0.3,\n          backgroundColor: 'rgba(75,192,192,0.4)',\n          borderColor: 'rgba(75,192,192,1)',\n          borderCapStyle: 'butt',\n          borderDash: [],\n          borderDashOffset: 0.0,\n          borderJoinStyle: 'miter',\n          pointBorderColor: 'rgba(75,192,192,1)',\n          pointBackgroundColor: '#fff',\n          pointBorderWidth: 1,\n          pointHoverRadius: 5,\n          pointHoverBackgroundColor: 'rgba(75,192,192,1)',\n          pointHoverBorderColor: 'rgba(220,220,220,1)',\n          pointHoverBorderWidth: 2,\n          pointRadius: 1,\n          pointHitRadius: 10,\n          data: count_array_1\n        }\n      ]\n    };\n    let time_array_2 = [];\n    let count_array_2 = [];\n    start = this.state.rotate_time_array[0];\n    end = this.state.rotate_time_array[this.state.rotate_time_array.length - 1];\n    while (start + 5.0 < end){\n      time_array_2 = [...time_array_2, start + 2.5];\n      let count = 0;\n      let time_value = 0;\n      for (let tc in this.state.rotate_count){\n        time_value = this.state.rotate_count[tc];\n        if (time_value >= start && time_value < (start + 5.0)){\n          count += 1;\n        }\n      }\n      count_array_2 = [...count_array_2, count];\n      start += 0.1;\n    }\n    const data2 = {\n      labels: time_array_2,\n      datasets: [        \n        {\n          label: 'Rotation',\n          fill: false,\n          lineTension: 0.1,\n          backgroundColor: 'rgba(192,75,192,0.4)',\n          borderColor: 'rgba(192,75,192,1)',\n          borderCapStyle: 'butt',\n          borderDash: [],\n          borderDashOffset: 0.0,\n          borderJoinStyle: 'miter',\n          pointBorderColor: 'rgba(192,75,192,1)',\n          pointBackgroundColor: '#fff',\n          pointBorderWidth: 1,\n          pointHoverRadius: 5,\n          pointHoverBackgroundColor: 'rgba(192,75,192,1)',\n          pointHoverBorderColor: 'rgba(220,220,220,1)',\n          pointHoverBorderWidth: 2,\n          pointRadius: 1,\n          pointHitRadius: 10,\n          data: count_array_2 \n        },\n      ]\n    };\n    let time_array_3 = [];\n    let count_array_3 = [];\n    start = this.state.fist_time_array[0];\n    end = this.state.fist_time_array[this.state.fist_time_array.length - 1];\n    while (start + 5.0 < end){\n      time_array_3 = [...time_array_3, start + 2.5];\n      let count = 0;\n      let time_value = 0;\n      for (let tc in this.state.fist_count){\n        time_value = this.state.fist_count[tc];\n        if (time_value >= start && time_value < (start + 5.0)){\n          count += 1;\n        }\n      }\n      count_array_3 = [...count_array_3, count];\n      start += 0.1;\n    }\n    const data3 = {\n      labels: time_array_3,\n      datasets: [        \n        {\n          label: 'Fist',\n          fill: false,\n          lineTension: 0.1,\n          backgroundColor: 'rgba(192,192,75,0.4)',\n          borderColor: 'rgba(192,192,75,1)',\n          borderCapStyle: 'butt',\n          borderDash: [],\n          borderDashOffset: 0.0,\n          borderJoinStyle: 'miter',\n          pointBorderColor: 'rgba(192,192,75,1)',\n          pointBackgroundColor: '#fff',\n          pointBorderWidth: 1,\n          pointHoverRadius: 5,\n          pointHoverBackgroundColor: 'rgba(192,192,75,1)',\n          pointHoverBorderColor: 'rgba(220,220,220,1)',\n          pointHoverBorderWidth: 2,\n          pointRadius: 1,\n          pointHitRadius: 10,\n          data: count_array_3\n        }\n      ]\n    };\n    this.setState({chart_data1:data1});\n    this.setState({chart_data2:data2});\n    this.setState({chart_data3:data3});\n    this.setState({chart_ready:true});\n  }\n\n  switch_button(){\n    if (this.state.button_mode === true){\n      this.setState({button_mode:false})\n    }\n    else{\n      this.setState({button_mode:true})\n    }\n  }\n\n  increment_tap1(){\n    if (this.state.last_pressed !== 1){\n      this.setState({last_pressed:1})\n      this.setState({count:this.state.count+1});\n    }\n  }\n\n  increment_tap2(){\n    if (this.state.last_pressed !== 2){\n      this.setState({last_pressed:2})\n      this.setState({count:this.state.count+1});\n    }\n  }\n\n  norm(lm1, lm2){\n    return sqrt(pow(lm1[0]-lm2[0], 2)+pow(lm1[1]-lm2[1], 2))\n  }\n\n  reset_counter(){\n    clearInterval(this.state.ID);\n    this.setState({\n      ID : 0,\n      tap_count : [],\n      rotate_count : [],\n      fist_count : [],\n      index_passed : 0,\n      rotate_passed : 0,\n      fist_passed : 0,\n      last_pressed:0,\n      real_time_inferencing:false,\n      recording:false,\n      button_mode:false,\n      chart_ready:false,\n      finger_done : false,\n      rotate_done : false,\n      fist_done : false,\n      record : [],\n      dist_time_array : [],\n      dist_array : [],\n      rotate_time_array : [],\n      rotate_array : [],\n      fist_time_array : [],\n      fist_array : [],\n      chart_data1 : null,\n      chart_data2 : null,\n      chart_data3 : null,\n      startAt: Date.now(),\n      dead_frame: 0,\n    });\n  }\n\n  sleep = (milliseconds) => {\n    return new Promise(resolve => setTimeout(resolve, milliseconds))\n  }\n\n  async runHandpose() {\n    require('@tensorflow/tfjs-backend-cpu');\n    //const uploadJSONInput = document.getElementById('upload-json');\n    //const uploadWeightsInput = document.getElementById('upload-weights');\n    //const model = await tf.loadLayersModel(tf.io.browserFiles([uploadJSONInput.files[0], uploadWeightsInput.files[0]]));\n    const net = await handpose.load();\n    console.log(\"Handpose model loaded.\");\n    this.setState({startAt:Date.now()});\n    const Interval_ID = setInterval(() => {\n      this.read_time_inference(net);\n    }, 50);\n    this.setState({ID:Interval_ID});\n    this.setState({real_time_inferencing:true});\n  };\n\n  async read_time_inference(net) {    \n    if (this.state.wait){\n      await this.sleep(3000);\n      this.setState({wait:false});\n    }\n    if (\n      typeof this.webcamRef.current !== \"undefined\" &&\n      this.webcamRef.current !== null &&\n      this.webcamRef.current.video.readyState === 4\n    ) {\n      const video = this.webcamRef.current.video;\n      const videoWidth = this.webcamRef.current.video.videoWidth;\n      const videoHeight = this.webcamRef.current.video.videoHeight;\n      this.webcamRef.current.video.width = videoWidth;\n      this.webcamRef.current.video.height = videoHeight;\n      this.canvasRef.current.width = videoWidth;\n      this.canvasRef.current.height = videoHeight;\n      const hand = await net.estimateHands(video);\n      if (hand.length > 0){\n        hand.forEach((prediction) => {\n          this.setState({dead_frame: 0});\n          const landmarks = prediction.landmarks\n\n          let pawn_dist = this.norm(landmarks[0], landmarks[2]);\n          let current_moment = (Date.now() - this.state.startAt)/1000\n\n          if (this.state.finger_done === false){\n            let index_dist = this.norm(landmarks[4], landmarks[8]);\n            index_dist = index_dist/pawn_dist\n            this.setState({dist_array:[...this.state.dist_array, index_dist]});\n            this.setState({dist_time_array:[...this.state.dist_time_array, current_moment]});\n            if (index_dist >= 0.5){this.setState({index_passed:1})}\n            if (index_dist < 0.5 && this.state.index_passed === 1){\n              this.setState({index_passed:0});\n              this.setState({tap_count:[...this.state.tap_count, current_moment]});\n            }\n          }\n          \n          if (this.state.finger_done === true && this.state.rotate_done === false){\n            let rotate_dist = (landmarks[2][0] - landmarks[17][0]) / pawn_dist;\n            this.setState({rotate_array:[...this.state.rotate_array, rotate_dist]});\n            this.setState({rotate_time_array:[...this.state.rotate_time_array, current_moment]});\n            if (this.state.rotate_passed === 0){\n              if (rotate_dist >= 0.5) this.setState({rotate_passed:1});\n              if (rotate_dist <= -0.5) this.setState({rotate_passed:-1});\n            }\n            if (this.state.rotate_passed === 1 && rotate_dist <= -0.5){\n              this.setState({rotate_passed:-1});\n            }\n            if (this.state.rotate_passed === -1 && rotate_dist >= 0.5){\n              this.setState({rotate_passed:1});\n              this.setState({rotate_count:[...this.state.rotate_count, current_moment]});\n            }\n          }\n\n          if (this.state.rotate_done === true && this.state.fist_done === false){\n            let fist_dist =  ((landmarks[8][1] - landmarks[5][1])+\n                              (landmarks[12][1] - landmarks[9][1])+\n                              (landmarks[16][1] - landmarks[13][1])+\n                             (landmarks[20][1] - landmarks[17][1]))/\n                              (4*pawn_dist)\n            this.setState({fist_array:[...this.state.fist_array, fist_dist]});\n            this.setState({fist_time_array:[...this.state.fist_time_array, current_moment]});\n            if (fist_dist >= 0.0){this.setState({fist_passed:1})}\n            if (fist_dist < -0.4 && this.state.fist_passed === 1){\n              this.setState({fist_passed:0});\n              this.setState({fist_count:[...this.state.fist_count, current_moment]});\n            }\n          }           \n\n          const ctx = this.canvasRef.current.getContext(\"2d\");\n          this.setState({context:ctx});\n          drawHand(hand, ctx);\n        });\n      }\n      /*\n      else{\n        if (this.state.dist_array.length !== 0){\n          this.setState({dead_frame: this.state.dead_frame+1});\n          if (this.state.dead_frame >= 10) this.stop_real_time_inference();\n        }\n      }\n      */\n    }\n  };\n\n  async stop_tapping() {\n    this.setState({finger_done:true});\n    this.setState({wait:true});\n  }\n\n  async stop_rotating() {\n    this.setState({rotate_done:true});\n    this.setState({wait:true});\n  }\n\n  stop_real_time_inference() {\n    clearInterval(this.state.ID);\n    this.setState({real_time_inferencing:false,\n                   finger_done:false,\n                   rotate_done:false,\n                   fist_done:false});\n    this.compose_chart();\n  }\n\n  async record_video(){\n    this.setState({startAt:Date.now()});\n    let count = 0;\n    require('@tensorflow/tfjs-backend-cpu');\n    const net = await handpose.load();\n    console.log(\"Handpose model loaded.\");\n    const Interval_ID = setInterval(() => {\n      this.concat_frame(count, net);\n      count = (count + 1)%20;\n    }, 50);\n    this.setState({ID:Interval_ID});\n    this.setState({recording:true});\n  }\n\n  async concat_frame(count, net) {\n    if (this.state.wait){\n      await this.sleep(3000);\n      this.setState({wait:false});\n    }\n    if (\n      typeof this.webcamRef.current !== \"undefined\" &&\n      this.webcamRef.current !== null &&\n      this.webcamRef.current.video.readyState === 4\n    ) {\n      let current_moment = (Date.now() - this.state.startAt)/1000;\n      const image = this.webcamRef.current.getScreenshot();      \n      var img = document.createElement(\"img\");\n      img.onload = function(){\n        if (this.state.finger_done === false){\n          this.setState({dist_record:[...this.state.dist_record, img]});\n          this.setState({dist_time_record:[...this.state.dist_time_record, current_moment]});\n        }\n\n        else if (this.state.finger_done === true && this.state.rotate_done === false){\n          this.setState({rotate_record:[...this.state.rotate_record, img]});\n          this.setState({rotate_time_record:[...this.state.rotate_time_record, current_moment]});\n        }\n\n        else if (this.state.rotate_done === true && this.state.fist_done === false){\n          this.setState({fist_record:[...this.state.fist_record, img]});\n          this.setState({fist_time_record:[...this.state.fist_time_record, current_moment]});\n        }\n\n        if (count === 0) this.record_estimateHands(img, net);\n      }.bind(this)\n      img.src = image;\n    }\n  }\n\n  record_estimateHands = async(img, net) =>{\n    const hand = await net.estimateHands(img);\n    if (hand.length > 0) console.log(\"On Screen\");\n    else console.log(\"Off Screen\");\n  }\n\n  async inference() {\n    require('@tensorflow/tfjs-backend-cpu');\n    const net = await handpose.load();\n    console.log(\"Handpose model loaded.\");\n\n    // Run prediction on recorded tapping data\n    for (let i = 0; i<this.state.dist_record.length; i++){\n      const hand = await net.estimateHands(this.state.dist_record[i]);\n      if (hand.length > 0){\n        hand.forEach((prediction) => {\n          const landmarks = prediction.landmarks\n          let pawn_dist = this.norm(landmarks[0], landmarks[2]);\n          let index_dist = this.norm(landmarks[4], landmarks[8]);\n          index_dist = index_dist/pawn_dist\n          this.setState({dist_array:[...this.state.dist_array, index_dist]});\n          this.setState({dist_time_array:[...this.state.dist_time_array, this.state.dist_time_record[i]]});\n          if (index_dist >= 0.5){this.setState({index_passed:1})}\n          if (index_dist < 0.5 && this.state.index_passed === 1){\n            this.setState({index_passed:0});\n            this.setState({tap_count:[...this.state.tap_count, this.state.dist_time_record[i]]});\n          }\n          console.log(\"INDEX COUNT:\", this.state.tap_count);\n        });\n      }\n    }\n\n    // Run prediction on recorded rotation data\n    for (let i = 0; i<this.state.rotate_record.length; i++){\n      const hand = await net.estimateHands(this.state.rotate_record[i]);\n      if (hand.length > 0){\n        hand.forEach((prediction) => {\n          const landmarks = prediction.landmarks\n          let pawn_dist = this.norm(landmarks[0], landmarks[2]);\n          let rotate_dist = (landmarks[2][0] - landmarks[17][0]) / pawn_dist;\n          this.setState({rotate_array:[...this.state.rotate_array, rotate_dist]});\n          this.setState({rotate_time_array:[...this.state.rotate_time_array, this.state.rotate_time_record[i]]});\n          if (this.state.rotate_passed === 0){\n            if (rotate_dist >= 0.5) this.setState({rotate_passed:1});\n            if (rotate_dist <= -0.5) this.setState({rotate_passed:-1});\n          }\n          if (this.state.rotate_passed === 1 && rotate_dist <= -0.5){\n            this.setState({rotate_passed:-1});\n          }\n          if (this.state.rotate_passed === -1 && rotate_dist >= 0.5){\n            this.setState({rotate_passed:1});\n            this.setState({rotate_count:[...this.state.rotate_count, this.state.rotate_time_record[i]]});\n          }\n          console.log(\"ROTATE COUNT:\", this.state.rotate_count);\n        });\n      }\n    }\n\n    // Run prediction on recorded gripping data\n    for (let i = 0; i<this.state.fist_record.length; i++){\n      const hand = await net.estimateHands(this.state.fist_record[i]);\n      if (hand.length > 0){\n        hand.forEach((prediction) => {\n          const landmarks = prediction.landmarks\n          let pawn_dist = this.norm(landmarks[0], landmarks[2]);\n          let fist_dist =  ((landmarks[8][1] - landmarks[5][1])+\n            (landmarks[12][1] - landmarks[9][1])+\n            (landmarks[16][1] - landmarks[13][1])+\n            (landmarks[20][1] - landmarks[17][1]))/\n            (4*pawn_dist)\n          this.setState({fist_array:[...this.state.fist_array, fist_dist]});\n          this.setState({fist_time_array:[...this.state.fist_time_array, this.state.fist_time_record[i]]});\n          if (fist_dist >= 0.0){this.setState({fist_passed:1})}\n          if (fist_dist < -0.4 && this.state.fist_passed === 1){\n            this.setState({fist_passed:0});\n            this.setState({fist_count:[...this.state.fist_count, this.state.fist_time_record[i]]});\n          }\n          console.log(\"FIST COUNT:\", this.state.fist_count);\n        });\n      }\n    }\n    this.setState({record:[]});\n  }\n\n  async stop_record() {\n    clearInterval(this.state.ID);\n    await this.inference();\n    this.setState({recording:false});\n    this.compose_chart();\n  }\n\n  render(){\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n        <Webcam\n          ref={this.webcamRef}\n          style={{\n            position: \"absolute\",\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            left: 0,\n            right: 0,\n            textAlign: \"center\",\n            zindex: 9,\n            width: \"auto\",\n            height: \"auto\",\n          }}\n        />\n        <canvas\n          ref={this.canvasRef}\n          style={{\n            position: \"absolute\",\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            left: 0,\n            right: 0,\n            textAlign: \"center\",\n            zindex: 9,\n            width: \"auto\",\n            height: \"auto\",\n          }}\n        />\n        </header>\n          {this.state.button_mode ? (\n            <div>\n              <button onClick={this.increment_tap1} id=\"button1\">Index Finger</button>\n              <button onClick={this.increment_tap2} id=\"button2\">Middle Finger</button>\n            </div>\n          ) : (\n            <div></div>\n          )}     \n          {this.state.real_time_inferencing ? (\n            this.state.finger_done ? (\n              this.state.rotate_done ? (\n                <button onClick={this.stop_real_time_inference}>Calculate Result</button>\n              ):(\n                <button onClick={this.stop_rotating}>Finish Rotating</button>\n              )\n            ):(\n              <button onClick={this.stop_tapping}>Finish Tapping</button>\n            )            \n          ) : (\n          <button onClick={this.runHandpose}>Starting Real Time Inference</button>\n          )}\n\n          {this.state.recording ? (\n            this.state.finger_done ? (\n              this.state.rotate_done ? (\n                <button onClick={this.stop_record}>Calculate Result</button>\n              ):(\n                <button onClick={this.stop_rotating}>Finish Rotating</button>\n              )\n            ):(\n              <button onClick={this.stop_tapping}>Finish Tapping</button>\n            )            \n          ) : (\n          <button onClick={this.record_video}>Starting Recording</button>\n          )}\n\n          <button onClick={this.reset_counter}>Reset Counter</button>\n          <button onClick={this.switch_button}>Switch On/Off Button</button>       \n          <h5>Finger Tapping Count: {this.state.tap_count.length}</h5>\n          <h5>Rotate Count: {this.state.rotate_count.length}</h5>\n          <h5>Gripping Count: {this.state.fist_count.length}</h5>\n          <div>\n            {this.state.chart_ready ? (\n              <div>\n                <Line data={this.state.chart_data1} />\n                <Line data={this.state.chart_data2} />\n                <Line data={this.state.chart_data3} />\n              </div>\n            ) : (\n              <div/>\n            )}\n            <div>\n              <input type=\"file\" id=\"upload-json\"></input>\n            </div>\n            <div>\n              <input type=\"file\" id=\"upload-weights\"></input>\n            </div>\n          </div>\n      </div>\n    );\n  }\n}\n\nexport default App;"]},"metadata":{},"sourceType":"module"}