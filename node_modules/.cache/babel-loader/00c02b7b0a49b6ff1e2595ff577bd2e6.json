{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../engine';\nimport { Conv2DBackpropFilter } from '../kernel_names';\nimport * as util from '../util';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\r\n * Computes the derivative of the filter of a 2D convolution.\r\n *\r\n * @param x The input tensor, of rank 4 or rank 3 of shape\r\n *     [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.\r\n * @param dy The dy image, of rank 4 or rank 3, of shape\r\n *     [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.\r\n * @param filterShape The shape of the filter, length 4,\r\n *     [filterHeight, filterWidth, inDepth, outDepth].\r\n * @param strides The strides of the convolution: [strideHeight,\r\n * strideWidth].\r\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\r\n *     used in the forward prop of the op.\r\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\r\n *     \"NHWC\". Specify the data format of the input and output data. With the\r\n *     default format \"NHWC\", the data is stored in the order of: [batch,\r\n *     height, width, channels].\r\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\r\n *     rounding mode used when computing output dimensions if pad is a\r\n *     number. If none is provided, it will not round and error if the output\r\n *     is of fractional size.\r\n */\n\nfunction conv2DBackpropFilter_(x, dy, filterShape, strides, pad, dataFormat = 'NHWC', dimRoundingMode) {\n  let x4D = x;\n\n  if (x.rank === 3) {\n    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);\n  }\n\n  let dy4D = dy;\n\n  if (dy4D.rank === 3) {\n    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);\n  }\n\n  util.assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ` + `${x4D.shape}.`);\n  util.assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ` + `${dy4D.shape}.`);\n  util.assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ` + `${filterShape}.`);\n  const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\n  const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];\n  util.assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must ` + `match input depth in filter (${filterShape[2]}.`);\n  util.assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must ` + `match output depth for filter (${filterShape[3]}).`);\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in conv2dDerFilter: pad must be an integer when using, ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const forward = backend => {\n    const dilations = 1;\n    const $dataFormat = conv_util.convertConv2DDataFormat(dataFormat);\n    const convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);\n    return backend.conv2dDerFilter(x4D, dy4D, convInfo);\n  };\n\n  const inputs = {\n    x: x4D,\n    dy: dy4D\n  };\n  const attrs = {\n    strides,\n    pad,\n    dataFormat,\n    dimRoundingMode,\n    filterShape\n  };\n  return ENGINE.runKernelFunc(forward, inputs, null, Conv2DBackpropFilter, attrs);\n}\n\nexport const conv2DBackpropFilter = op({\n  conv2DBackpropFilter_\n});","map":{"version":3,"sources":["../../src/ops/conv2d_backprop_filter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../engine';\r\nimport { Conv2DBackpropFilter } from '../kernel_names';\r\nimport * as util from '../util';\r\nimport * as conv_util from './conv_util';\r\nimport { op } from './operation';\r\nimport { reshape } from './reshape';\r\n/**\r\n * Computes the derivative of the filter of a 2D convolution.\r\n *\r\n * @param x The input tensor, of rank 4 or rank 3 of shape\r\n *     [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.\r\n * @param dy The dy image, of rank 4 or rank 3, of shape\r\n *     [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.\r\n * @param filterShape The shape of the filter, length 4,\r\n *     [filterHeight, filterWidth, inDepth, outDepth].\r\n * @param strides The strides of the convolution: [strideHeight,\r\n * strideWidth].\r\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\r\n *     used in the forward prop of the op.\r\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\r\n *     \"NHWC\". Specify the data format of the input and output data. With the\r\n *     default format \"NHWC\", the data is stored in the order of: [batch,\r\n *     height, width, channels].\r\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\r\n *     rounding mode used when computing output dimensions if pad is a\r\n *     number. If none is provided, it will not round and error if the output\r\n *     is of fractional size.\r\n */\r\nfunction conv2DBackpropFilter_(x, dy, filterShape, strides, pad, dataFormat = 'NHWC', dimRoundingMode) {\r\n    let x4D = x;\r\n    if (x.rank === 3) {\r\n        x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);\r\n    }\r\n    let dy4D = dy;\r\n    if (dy4D.rank === 3) {\r\n        dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);\r\n    }\r\n    util.assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ` +\r\n        `${x4D.shape}.`);\r\n    util.assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ` +\r\n        `${dy4D.shape}.`);\r\n    util.assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ` +\r\n        `${filterShape}.`);\r\n    const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\r\n    const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];\r\n    util.assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must ` +\r\n        `match input depth in filter (${filterShape[2]}.`);\r\n    util.assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must ` +\r\n        `match output depth for filter (${filterShape[3]}).`);\r\n    if (dimRoundingMode != null) {\r\n        util.assert(util.isInt(pad), () => `Error in conv2dDerFilter: pad must be an integer when using, ` +\r\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\r\n    }\r\n    const forward = backend => {\r\n        const dilations = 1;\r\n        const $dataFormat = conv_util.convertConv2DDataFormat(dataFormat);\r\n        const convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);\r\n        return backend.conv2dDerFilter(x4D, dy4D, convInfo);\r\n    };\r\n    const inputs = { x: x4D, dy: dy4D };\r\n    const attrs = { strides, pad, dataFormat, dimRoundingMode, filterShape };\r\n    return ENGINE.runKernelFunc(forward, inputs, null, Conv2DBackpropFilter, attrs);\r\n}\r\nexport const conv2DBackpropFilter = op({ conv2DBackpropFilter_ });\r\n//# sourceMappingURL=conv2d_backprop_filter.js.map"]},"metadata":{},"sourceType":"module"}