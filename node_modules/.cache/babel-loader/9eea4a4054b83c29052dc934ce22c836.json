{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { isNode } from '../../utils/is';\nimport { keywords } from '../keywords';\nimport { deepStrictEqual, hasOwnProperty } from '../../utils/object';\nimport { factory } from '../../utils/factory';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var mathWithTransform = _ref.mathWithTransform;\n  /**\r\n   * Node\r\n   */\n\n  function Node() {\n    if (!(this instanceof Node)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n  }\n  /**\r\n   * Evaluate the node\r\n   * @param {Object} [scope]  Scope to read/write variables\r\n   * @return {*}              Returns the result\r\n   */\n\n\n  Node.prototype.evaluate = function (scope) {\n    return this.compile().evaluate(scope);\n  };\n\n  Node.prototype.type = 'Node';\n  Node.prototype.isNode = true;\n  Node.prototype.comment = '';\n  /**\r\n   * Compile the node into an optimized, evauatable JavaScript function\r\n   * @return {{evaluate: function([Object])}} object\r\n   *                Returns an object with a function 'evaluate',\r\n   *                which can be invoked as expr.evaluate([scope: Object]),\r\n   *                where scope is an optional object with\r\n   *                variables.\r\n   */\n\n  Node.prototype.compile = function () {\n    var expr = this._compile(mathWithTransform, {});\n\n    var args = {};\n    var context = null;\n\n    function evaluate(scope) {\n      var s = scope || {};\n\n      _validateScope(s);\n\n      return expr(s, args, context);\n    }\n\n    return {\n      evaluate: evaluate\n    };\n  };\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\n\n\n  Node.prototype._compile = function (math, argNames) {\n    throw new Error('Method _compile should be implemented by type ' + this.type);\n  };\n  /**\r\n   * Execute a callback for each of the child nodes of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\n\n\n  Node.prototype.forEach = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run forEach on a Node interface');\n  };\n  /**\r\n   * Create a new Node having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n   * @returns {OperatorNode} Returns a transformed copy of the node\r\n   */\n\n\n  Node.prototype.map = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run map on a Node interface');\n  };\n  /**\r\n   * Validate whether an object is a Node, for use with map\r\n   * @param {Node} node\r\n   * @returns {Node} Returns the input if it's a node, else throws an Error\r\n   * @protected\r\n   */\n\n\n  Node.prototype._ifNode = function (node) {\n    if (!isNode(node)) {\n      throw new TypeError('Callback function must return a Node');\n    }\n\n    return node;\n  };\n  /**\r\n   * Recursively traverse all nodes in a node tree. Executes given callback for\r\n   * this node and each of its child nodes.\r\n   * @param {function(node: Node, path: string, parent: Node)} callback\r\n   *          A callback called for every node in the node tree.\r\n   */\n\n\n  Node.prototype.traverse = function (callback) {\n    // execute callback for itself\n    callback(this, null, null); // eslint-disable-line standard/no-callback-literal\n    // recursively traverse over all childs of a node\n\n    function _traverse(node, callback) {\n      node.forEach(function (child, path, parent) {\n        callback(child, path, parent);\n\n        _traverse(child, callback);\n      });\n    }\n\n    _traverse(this, callback);\n  };\n  /**\r\n   * Recursively transform a node tree via a transform function.\r\n   *\r\n   * For example, to replace all nodes of type SymbolNode having name 'x' with a\r\n   * ConstantNode with value 2:\r\n   *\r\n   *     const res = Node.transform(function (node, path, parent) {\r\n   *       if (node && node.isSymbolNode) && (node.name === 'x')) {\r\n   *         return new ConstantNode(2)\r\n   *       }\r\n   *       else {\r\n   *         return node\r\n   *       }\r\n   *     })\r\n   *\r\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n   *          A mapping function accepting a node, and returning\r\n   *          a replacement for the node or the original node.\r\n   *          Signature: callback(node: Node, index: string, parent: Node) : Node\r\n   * @return {Node} Returns the original node or its replacement\r\n   */\n\n\n  Node.prototype.transform = function (callback) {\n    function _transform(child, path, parent) {\n      var replacement = callback(child, path, parent);\n\n      if (replacement !== child) {\n        // stop iterating when the node is replaced\n        return replacement;\n      }\n\n      return child.map(_transform);\n    }\n\n    return _transform(this, null, null);\n  };\n  /**\r\n   * Find any node in the node tree matching given filter function. For example, to\r\n   * find all nodes of type SymbolNode having name 'x':\r\n   *\r\n   *     const results = Node.filter(function (node) {\r\n   *       return (node && node.isSymbolNode) && (node.name === 'x')\r\n   *     })\r\n   *\r\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n   *            A test function returning true when a node matches, and false\r\n   *            otherwise. Function signature:\r\n   *            callback(node: Node, index: string, parent: Node) : boolean\r\n   * @return {Node[]} nodes       An array with nodes matching given filter criteria\r\n   */\n\n\n  Node.prototype.filter = function (callback) {\n    var nodes = [];\n    this.traverse(function (node, path, parent) {\n      if (callback(node, path, parent)) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  };\n  /**\r\n   * Create a shallow clone of this node\r\n   * @return {Node}\r\n   */\n\n\n  Node.prototype.clone = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot clone a Node interface');\n  };\n  /**\r\n   * Create a deep clone of this node\r\n   * @return {Node}\r\n   */\n\n\n  Node.prototype.cloneDeep = function () {\n    return this.map(function (node) {\n      return node.cloneDeep();\n    });\n  };\n  /**\r\n   * Deep compare this node with another node.\r\n   * @param {Node} other\r\n   * @return {boolean} Returns true when both nodes are of the same type and\r\n   *                   contain the same values (as do their childs)\r\n   */\n\n\n  Node.prototype.equals = function (other) {\n    return other ? deepStrictEqual(this, other) : false;\n  };\n  /**\r\n   * Get string representation. (wrapper function)\r\n   *\r\n   * This function can get an object of the following form:\r\n   * {\r\n   *    handler: //This can be a callback function of the form\r\n   *             // \"function callback(node, options)\"or\r\n   *             // a map that maps function names (used in FunctionNodes)\r\n   *             // to callbacks\r\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n   * }\r\n   *\r\n   * @param {Object} [options]\r\n   * @return {string}\r\n   */\n\n\n  Node.prototype.toString = function (options) {\n    var customString;\n\n    if (options && _typeof(options) === 'object') {\n      switch (_typeof(options.handler)) {\n        case 'object':\n        case 'undefined':\n          break;\n\n        case 'function':\n          customString = options.handler(this, options);\n          break;\n\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this._toString(options);\n  };\n  /**\r\n   * Get a JSON representation of the node\r\n   * Both .toJSON() and the static .fromJSON(json) should be implemented by all\r\n   * implementations of Node\r\n   * @returns {Object}\r\n   */\n\n\n  Node.prototype.toJSON = function () {\n    throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n  };\n  /**\r\n   * Get HTML representation. (wrapper function)\r\n   *\r\n   * This function can get an object of the following form:\r\n   * {\r\n   *    handler: //This can be a callback function of the form\r\n   *             // \"function callback(node, options)\" or\r\n   *             // a map that maps function names (used in FunctionNodes)\r\n   *             // to callbacks\r\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n   * }\r\n   *\r\n   * @param {Object} [options]\r\n   * @return {string}\r\n   */\n\n\n  Node.prototype.toHTML = function (options) {\n    var customString;\n\n    if (options && _typeof(options) === 'object') {\n      switch (_typeof(options.handler)) {\n        case 'object':\n        case 'undefined':\n          break;\n\n        case 'function':\n          customString = options.handler(this, options);\n          break;\n\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this.toHTML(options);\n  };\n  /**\r\n   * Internal function to generate the string output.\r\n   * This has to be implemented by every Node\r\n   *\r\n   * @throws {Error}\r\n   */\n\n\n  Node.prototype._toString = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toString not implemented for ' + this.type);\n  };\n  /**\r\n   * Get LaTeX representation. (wrapper function)\r\n   *\r\n   * This function can get an object of the following form:\r\n   * {\r\n   *    handler: //This can be a callback function of the form\r\n   *             // \"function callback(node, options)\"or\r\n   *             // a map that maps function names (used in FunctionNodes)\r\n   *             // to callbacks\r\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n   * }\r\n   *\r\n   * @param {Object} [options]\r\n   * @return {string}\r\n   */\n\n\n  Node.prototype.toTex = function (options) {\n    var customTex;\n\n    if (options && _typeof(options) === 'object') {\n      switch (_typeof(options.handler)) {\n        case 'object':\n        case 'undefined':\n          break;\n\n        case 'function':\n          customTex = options.handler(this, options);\n          break;\n\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    }\n\n    return this._toTex(options);\n  };\n  /**\r\n   * Internal function to generate the LaTeX output.\r\n   * This has to be implemented by every Node\r\n   *\r\n   * @param {Object} [options]\r\n   * @throws {Error}\r\n   */\n\n\n  Node.prototype._toTex = function (options) {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toTex not implemented for ' + this.type);\n  };\n  /**\r\n   * Get identifier.\r\n   * @return {string}\r\n   */\n\n\n  Node.prototype.getIdentifier = function () {\n    return this.type;\n  };\n  /**\r\n   * Get the content of the current Node.\r\n   * @return {Node} node\r\n   **/\n\n\n  Node.prototype.getContent = function () {\n    return this;\n  };\n  /**\r\n   * Validate the symbol names of a scope.\r\n   * Throws an error when the scope contains an illegal symbol.\r\n   * @param {Object} scope\r\n   */\n\n\n  function _validateScope(scope) {\n    for (var symbol in scope) {\n      if (hasOwnProperty(scope, symbol)) {\n        if (symbol in keywords) {\n          throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n        }\n      }\n    }\n  }\n\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/mathjs/es/expression/node/Node.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","isNode","keywords","deepStrictEqual","hasOwnProperty","factory","name","dependencies","createNode","_ref","mathWithTransform","Node","SyntaxError","evaluate","scope","compile","type","comment","expr","_compile","args","context","s","_validateScope","math","argNames","Error","forEach","callback","map","_ifNode","node","TypeError","traverse","_traverse","child","path","parent","transform","_transform","replacement","filter","nodes","push","clone","cloneDeep","equals","other","toString","options","customString","handler","_toString","toJSON","toHTML","toTex","customTex","_toTex","getIdentifier","getContent","symbol","isClass"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nimport { isNode } from '../../utils/is';\r\nimport { keywords } from '../keywords';\r\nimport { deepStrictEqual, hasOwnProperty } from '../../utils/object';\r\nimport { factory } from '../../utils/factory';\r\nvar name = 'Node';\r\nvar dependencies = ['mathWithTransform'];\r\nexport var createNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\r\n  var mathWithTransform = _ref.mathWithTransform;\r\n\r\n  /**\r\n   * Node\r\n   */\r\n  function Node() {\r\n    if (!(this instanceof Node)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n  }\r\n  /**\r\n   * Evaluate the node\r\n   * @param {Object} [scope]  Scope to read/write variables\r\n   * @return {*}              Returns the result\r\n   */\r\n\r\n\r\n  Node.prototype.evaluate = function (scope) {\r\n    return this.compile().evaluate(scope);\r\n  };\r\n\r\n  Node.prototype.type = 'Node';\r\n  Node.prototype.isNode = true;\r\n  Node.prototype.comment = '';\r\n  /**\r\n   * Compile the node into an optimized, evauatable JavaScript function\r\n   * @return {{evaluate: function([Object])}} object\r\n   *                Returns an object with a function 'evaluate',\r\n   *                which can be invoked as expr.evaluate([scope: Object]),\r\n   *                where scope is an optional object with\r\n   *                variables.\r\n   */\r\n\r\n  Node.prototype.compile = function () {\r\n    var expr = this._compile(mathWithTransform, {});\r\n\r\n    var args = {};\r\n    var context = null;\r\n\r\n    function evaluate(scope) {\r\n      var s = scope || {};\r\n\r\n      _validateScope(s);\r\n\r\n      return expr(s, args, context);\r\n    }\r\n\r\n    return {\r\n      evaluate: evaluate\r\n    };\r\n  };\r\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\r\n\r\n\r\n  Node.prototype._compile = function (math, argNames) {\r\n    throw new Error('Method _compile should be implemented by type ' + this.type);\r\n  };\r\n  /**\r\n   * Execute a callback for each of the child nodes of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\r\n\r\n\r\n  Node.prototype.forEach = function (callback) {\r\n    // must be implemented by each of the Node implementations\r\n    throw new Error('Cannot run forEach on a Node interface');\r\n  };\r\n  /**\r\n   * Create a new Node having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n   * @returns {OperatorNode} Returns a transformed copy of the node\r\n   */\r\n\r\n\r\n  Node.prototype.map = function (callback) {\r\n    // must be implemented by each of the Node implementations\r\n    throw new Error('Cannot run map on a Node interface');\r\n  };\r\n  /**\r\n   * Validate whether an object is a Node, for use with map\r\n   * @param {Node} node\r\n   * @returns {Node} Returns the input if it's a node, else throws an Error\r\n   * @protected\r\n   */\r\n\r\n\r\n  Node.prototype._ifNode = function (node) {\r\n    if (!isNode(node)) {\r\n      throw new TypeError('Callback function must return a Node');\r\n    }\r\n\r\n    return node;\r\n  };\r\n  /**\r\n   * Recursively traverse all nodes in a node tree. Executes given callback for\r\n   * this node and each of its child nodes.\r\n   * @param {function(node: Node, path: string, parent: Node)} callback\r\n   *          A callback called for every node in the node tree.\r\n   */\r\n\r\n\r\n  Node.prototype.traverse = function (callback) {\r\n    // execute callback for itself\r\n    callback(this, null, null); // eslint-disable-line standard/no-callback-literal\r\n    // recursively traverse over all childs of a node\r\n\r\n    function _traverse(node, callback) {\r\n      node.forEach(function (child, path, parent) {\r\n        callback(child, path, parent);\r\n\r\n        _traverse(child, callback);\r\n      });\r\n    }\r\n\r\n    _traverse(this, callback);\r\n  };\r\n  /**\r\n   * Recursively transform a node tree via a transform function.\r\n   *\r\n   * For example, to replace all nodes of type SymbolNode having name 'x' with a\r\n   * ConstantNode with value 2:\r\n   *\r\n   *     const res = Node.transform(function (node, path, parent) {\r\n   *       if (node && node.isSymbolNode) && (node.name === 'x')) {\r\n   *         return new ConstantNode(2)\r\n   *       }\r\n   *       else {\r\n   *         return node\r\n   *       }\r\n   *     })\r\n   *\r\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n   *          A mapping function accepting a node, and returning\r\n   *          a replacement for the node or the original node.\r\n   *          Signature: callback(node: Node, index: string, parent: Node) : Node\r\n   * @return {Node} Returns the original node or its replacement\r\n   */\r\n\r\n\r\n  Node.prototype.transform = function (callback) {\r\n    function _transform(child, path, parent) {\r\n      var replacement = callback(child, path, parent);\r\n\r\n      if (replacement !== child) {\r\n        // stop iterating when the node is replaced\r\n        return replacement;\r\n      }\r\n\r\n      return child.map(_transform);\r\n    }\r\n\r\n    return _transform(this, null, null);\r\n  };\r\n  /**\r\n   * Find any node in the node tree matching given filter function. For example, to\r\n   * find all nodes of type SymbolNode having name 'x':\r\n   *\r\n   *     const results = Node.filter(function (node) {\r\n   *       return (node && node.isSymbolNode) && (node.name === 'x')\r\n   *     })\r\n   *\r\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n   *            A test function returning true when a node matches, and false\r\n   *            otherwise. Function signature:\r\n   *            callback(node: Node, index: string, parent: Node) : boolean\r\n   * @return {Node[]} nodes       An array with nodes matching given filter criteria\r\n   */\r\n\r\n\r\n  Node.prototype.filter = function (callback) {\r\n    var nodes = [];\r\n    this.traverse(function (node, path, parent) {\r\n      if (callback(node, path, parent)) {\r\n        nodes.push(node);\r\n      }\r\n    });\r\n    return nodes;\r\n  };\r\n  /**\r\n   * Create a shallow clone of this node\r\n   * @return {Node}\r\n   */\r\n\r\n\r\n  Node.prototype.clone = function () {\r\n    // must be implemented by each of the Node implementations\r\n    throw new Error('Cannot clone a Node interface');\r\n  };\r\n  /**\r\n   * Create a deep clone of this node\r\n   * @return {Node}\r\n   */\r\n\r\n\r\n  Node.prototype.cloneDeep = function () {\r\n    return this.map(function (node) {\r\n      return node.cloneDeep();\r\n    });\r\n  };\r\n  /**\r\n   * Deep compare this node with another node.\r\n   * @param {Node} other\r\n   * @return {boolean} Returns true when both nodes are of the same type and\r\n   *                   contain the same values (as do their childs)\r\n   */\r\n\r\n\r\n  Node.prototype.equals = function (other) {\r\n    return other ? deepStrictEqual(this, other) : false;\r\n  };\r\n  /**\r\n   * Get string representation. (wrapper function)\r\n   *\r\n   * This function can get an object of the following form:\r\n   * {\r\n   *    handler: //This can be a callback function of the form\r\n   *             // \"function callback(node, options)\"or\r\n   *             // a map that maps function names (used in FunctionNodes)\r\n   *             // to callbacks\r\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n   * }\r\n   *\r\n   * @param {Object} [options]\r\n   * @return {string}\r\n   */\r\n\r\n\r\n  Node.prototype.toString = function (options) {\r\n    var customString;\r\n\r\n    if (options && _typeof(options) === 'object') {\r\n      switch (_typeof(options.handler)) {\r\n        case 'object':\r\n        case 'undefined':\r\n          break;\r\n\r\n        case 'function':\r\n          customString = options.handler(this, options);\r\n          break;\r\n\r\n        default:\r\n          throw new TypeError('Object or function expected as callback');\r\n      }\r\n    }\r\n\r\n    if (typeof customString !== 'undefined') {\r\n      return customString;\r\n    }\r\n\r\n    return this._toString(options);\r\n  };\r\n  /**\r\n   * Get a JSON representation of the node\r\n   * Both .toJSON() and the static .fromJSON(json) should be implemented by all\r\n   * implementations of Node\r\n   * @returns {Object}\r\n   */\r\n\r\n\r\n  Node.prototype.toJSON = function () {\r\n    throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\r\n  };\r\n  /**\r\n   * Get HTML representation. (wrapper function)\r\n   *\r\n   * This function can get an object of the following form:\r\n   * {\r\n   *    handler: //This can be a callback function of the form\r\n   *             // \"function callback(node, options)\" or\r\n   *             // a map that maps function names (used in FunctionNodes)\r\n   *             // to callbacks\r\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n   * }\r\n   *\r\n   * @param {Object} [options]\r\n   * @return {string}\r\n   */\r\n\r\n\r\n  Node.prototype.toHTML = function (options) {\r\n    var customString;\r\n\r\n    if (options && _typeof(options) === 'object') {\r\n      switch (_typeof(options.handler)) {\r\n        case 'object':\r\n        case 'undefined':\r\n          break;\r\n\r\n        case 'function':\r\n          customString = options.handler(this, options);\r\n          break;\r\n\r\n        default:\r\n          throw new TypeError('Object or function expected as callback');\r\n      }\r\n    }\r\n\r\n    if (typeof customString !== 'undefined') {\r\n      return customString;\r\n    }\r\n\r\n    return this.toHTML(options);\r\n  };\r\n  /**\r\n   * Internal function to generate the string output.\r\n   * This has to be implemented by every Node\r\n   *\r\n   * @throws {Error}\r\n   */\r\n\r\n\r\n  Node.prototype._toString = function () {\r\n    // must be implemented by each of the Node implementations\r\n    throw new Error('_toString not implemented for ' + this.type);\r\n  };\r\n  /**\r\n   * Get LaTeX representation. (wrapper function)\r\n   *\r\n   * This function can get an object of the following form:\r\n   * {\r\n   *    handler: //This can be a callback function of the form\r\n   *             // \"function callback(node, options)\"or\r\n   *             // a map that maps function names (used in FunctionNodes)\r\n   *             // to callbacks\r\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n   * }\r\n   *\r\n   * @param {Object} [options]\r\n   * @return {string}\r\n   */\r\n\r\n\r\n  Node.prototype.toTex = function (options) {\r\n    var customTex;\r\n\r\n    if (options && _typeof(options) === 'object') {\r\n      switch (_typeof(options.handler)) {\r\n        case 'object':\r\n        case 'undefined':\r\n          break;\r\n\r\n        case 'function':\r\n          customTex = options.handler(this, options);\r\n          break;\r\n\r\n        default:\r\n          throw new TypeError('Object or function expected as callback');\r\n      }\r\n    }\r\n\r\n    if (typeof customTex !== 'undefined') {\r\n      return customTex;\r\n    }\r\n\r\n    return this._toTex(options);\r\n  };\r\n  /**\r\n   * Internal function to generate the LaTeX output.\r\n   * This has to be implemented by every Node\r\n   *\r\n   * @param {Object} [options]\r\n   * @throws {Error}\r\n   */\r\n\r\n\r\n  Node.prototype._toTex = function (options) {\r\n    // must be implemented by each of the Node implementations\r\n    throw new Error('_toTex not implemented for ' + this.type);\r\n  };\r\n  /**\r\n   * Get identifier.\r\n   * @return {string}\r\n   */\r\n\r\n\r\n  Node.prototype.getIdentifier = function () {\r\n    return this.type;\r\n  };\r\n  /**\r\n   * Get the content of the current Node.\r\n   * @return {Node} node\r\n   **/\r\n\r\n\r\n  Node.prototype.getContent = function () {\r\n    return this;\r\n  };\r\n  /**\r\n   * Validate the symbol names of a scope.\r\n   * Throws an error when the scope contains an illegal symbol.\r\n   * @param {Object} scope\r\n   */\r\n\r\n\r\n  function _validateScope(scope) {\r\n    for (var symbol in scope) {\r\n      if (hasOwnProperty(scope, symbol)) {\r\n        if (symbol in keywords) {\r\n          throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return Node;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}