{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\r\n * Given graph inputs and desired outputs, find the minimal set of nodes\r\n * to execute in order to compute the outputs. In addition return other useful\r\n * info such:\r\n * - Missing inputs needed to compute the output.\r\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\r\n * - Alternative inputs in order to avoid async (dynamic op) execution.\r\n */\n\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  const usedNodes = new Set();\n  const missingInputs = [];\n  let dynamicNode = null;\n  let syncInputs = null; // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n\n  const seen = new Set();\n  const inputNodeNames = Object.keys(inputs).map(name => parseNodeName(name)[0]);\n  let initNodeNames = [];\n\n  if (initNodes != null) {\n    initNodeNames = initNodes.map(node => parseNodeName(node.name)[0]);\n  }\n\n  const frontier = [...outputs];\n\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n\n    if (isControlFlow(node) || isDynamicShape(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name).filter(name => usedNodes.has(name));\n      }\n    }\n\n    usedNodes.add(node.name); // Weights are dead end since we already have their values.\n\n    if (weightMap[node.name] != null) {\n      continue;\n    } // This node is a dead end since it's one of the user-provided inputs.\n\n\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    } // This node is a dead end since it doesn't have any inputs.\n\n\n    if (initNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n\n  return {\n    inputs,\n    outputs,\n    usedNodes,\n    missingInputs,\n    dynamicNode,\n    syncInputs\n  };\n}\n/**\r\n * Given the execution info, return a list of nodes in topological order that\r\n * need to be executed to compute the output.\r\n */\n\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n  const {\n    usedNodes,\n    inputs\n  } = executionInfo;\n  const frontier = [];\n  const inputNodes = Object.keys(inputs).map(name => parseNodeName(name)[0]).map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes;\n  inputNodes.forEach(input => {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(weight => {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n\n  if (initNodes != null) {\n    initNodes.forEach(node => {\n      if (usedNodes.has(node.name)) {\n        frontier.push(node);\n      }\n    });\n  }\n\n  const seen = new Set();\n  const orderedNodes = [];\n\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    seen.add(node.name);\n\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n\n    node.children.forEach(child => {\n      if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every(input => seen.has(input.name))) {\n        frontier.push(child);\n      }\n    });\n  }\n\n  return orderedNodes;\n}\nconst CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While'];\nconst DYNAMIC_SHAPE_OPS = ['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'];\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}","map":{"version":3,"sources":["../../src/executor/model_analysis.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { parseNodeName } from '../operations/executors/utils';\r\n/**\r\n * Given graph inputs and desired outputs, find the minimal set of nodes\r\n * to execute in order to compute the outputs. In addition return other useful\r\n * info such:\r\n * - Missing inputs needed to compute the output.\r\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\r\n * - Alternative inputs in order to avoid async (dynamic op) execution.\r\n */\r\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\r\n    const usedNodes = new Set();\r\n    const missingInputs = [];\r\n    let dynamicNode = null;\r\n    let syncInputs = null;\r\n    // Start with the outputs, going backwards and find all the nodes that are\r\n    // needed to compute those outputs.\r\n    const seen = new Set();\r\n    const inputNodeNames = Object.keys(inputs).map(name => parseNodeName(name)[0]);\r\n    let initNodeNames = [];\r\n    if (initNodes != null) {\r\n        initNodeNames = initNodes.map(node => parseNodeName(node.name)[0]);\r\n    }\r\n    const frontier = [...outputs];\r\n    while (frontier.length > 0) {\r\n        const node = frontier.pop();\r\n        if (isControlFlow(node) || isDynamicShape(node)) {\r\n            if (dynamicNode == null) {\r\n                dynamicNode = node;\r\n                syncInputs = dynamicNode.children.map(child => child.name)\r\n                    .filter(name => usedNodes.has(name));\r\n            }\r\n        }\r\n        usedNodes.add(node.name);\r\n        // Weights are dead end since we already have their values.\r\n        if (weightMap[node.name] != null) {\r\n            continue;\r\n        }\r\n        // This node is a dead end since it's one of the user-provided inputs.\r\n        if (inputNodeNames.indexOf(node.name) !== -1) {\r\n            continue;\r\n        }\r\n        // This node is a dead end since it doesn't have any inputs.\r\n        if (initNodeNames.indexOf(node.name) !== -1) {\r\n            continue;\r\n        }\r\n        if (node.inputs.length === 0) {\r\n            missingInputs.push(node.name);\r\n            continue;\r\n        }\r\n        node.inputs.forEach(input => {\r\n            // Don't add to the frontier if it is already there.\r\n            if (seen.has(input.name)) {\r\n                return;\r\n            }\r\n            seen.add(input.name);\r\n            frontier.push(input);\r\n        });\r\n    }\r\n    return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };\r\n}\r\n/**\r\n * Given the execution info, return a list of nodes in topological order that\r\n * need to be executed to compute the output.\r\n */\r\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\r\n    const { usedNodes, inputs } = executionInfo;\r\n    const frontier = [];\r\n    const inputNodes = Object.keys(inputs)\r\n        .map(name => parseNodeName(name)[0])\r\n        .map(name => graph.nodes[name]);\r\n    const initNodes = graph.initNodes;\r\n    inputNodes.forEach(input => {\r\n        if (usedNodes.has(input.name)) {\r\n            frontier.push(input);\r\n        }\r\n    });\r\n    graph.weights.forEach(weight => {\r\n        if (usedNodes.has(weight.name)) {\r\n            frontier.push(weight);\r\n        }\r\n    });\r\n    if (initNodes != null) {\r\n        initNodes.forEach(node => {\r\n            if (usedNodes.has(node.name)) {\r\n                frontier.push(node);\r\n            }\r\n        });\r\n    }\r\n    const seen = new Set();\r\n    const orderedNodes = [];\r\n    while (frontier.length > 0) {\r\n        const node = frontier.pop();\r\n        seen.add(node.name);\r\n        if (!weightMap[node.name]) {\r\n            orderedNodes.push(node);\r\n        }\r\n        node.children.forEach(child => {\r\n            if (!seen.has(child.name) && usedNodes.has(child.name) &&\r\n                child.inputs.every(input => seen.has(input.name))) {\r\n                frontier.push(child);\r\n            }\r\n        });\r\n    }\r\n    return orderedNodes;\r\n}\r\nconst CONTROL_FLOW_OPS = [\r\n    'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\r\n    'StatelessWhile', 'if', 'While'\r\n];\r\nconst DYNAMIC_SHAPE_OPS = [\r\n    'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\r\n];\r\nexport function isControlFlow(node) {\r\n    return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\r\n}\r\nexport function isDynamicShape(node) {\r\n    return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\r\n}\r\n//# sourceMappingURL=model_analysis.js.map"]},"metadata":{},"sourceType":"module"}