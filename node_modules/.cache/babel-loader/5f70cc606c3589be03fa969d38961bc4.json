{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../engine';\nimport { StridedSlice } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\nimport { reshape } from './reshape';\nimport { slice } from './slice';\nimport { computeOutShape, getNormalizedAxes, maskToAxes } from './slice_util';\n/**\r\n * Extracts a strided slice of a tensor.\r\n *\r\n * Roughly speaking, this op extracts a slice of size (end-begin)/stride from\r\n * the given input tensor (x). Starting at the location specified by begin the\r\n * slice continues by adding stride to the index until all dimensions are not\r\n * less than end. Note that a stride can be negative, which causes a reverse\r\n * slice.\r\n *\r\n * ```js\r\n * const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],\r\n *    [3, 2, 3]);\r\n * t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]\r\n * t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],\r\n *                                                     // [4, 4, 4]]]\r\n * t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],\r\n *                                                     // [3, 3, 3]]]\r\n * ```\r\n *\r\n * @param x The tensor to stride slice.\r\n * @param begin The coordinates to start the slice from.\r\n * @param end: The coordinates to end the slice at.\r\n * @param strides: The size of the slice.\r\n * @param beginMask: If the ith bit of beginMask is set, begin[i] is ignored\r\n *      and the fullest possible range in that dimension is used instead.\r\n * @param endMask: If the ith bit of endMask is set, end[i] is ignored\r\n *      and the fullest possible range in that dimension is used instead.\r\n * @param shrinkAxisMask: a bitmask where bit i implies that\r\n * the ith specification should shrink the dimensionality. begin and end must\r\n * imply a slice of size 1 in the dimension.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\r\n */\n\nfunction stridedSlice_(x, begin, end, strides) {\n  var beginMask = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var endMask = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var ellipsisMask = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var newAxisMask = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  var shrinkAxisMask = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n  var $x = convertToTensor(x, 'x', 'stridedSlice');\n\n  var forward = function forward(backend) {\n    if (strides == null) {\n      strides = new Array(begin.length);\n    }\n\n    var ellipsisAxes = maskToAxes(ellipsisMask);\n\n    if (ellipsisAxes.length > 1) {\n      throw new Error('Multiple ellipses in slice is not allowed.');\n    }\n\n    if (ellipsisMask !== 0 && newAxisMask !== 0) {\n      throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n    }\n\n    if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n      throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n    }\n\n    var numInterpolatedAxes = $x.rank - begin.length; // Expand the dims of x based on the newAxisMask.\n\n    var expandAxes = maskToAxes(newAxisMask);\n    var newShape = $x.shape.slice();\n    expandAxes.forEach(function (axis) {\n      begin[axis] = 0;\n      end[axis] = 1;\n      newShape.splice(axis, 0, 1);\n    });\n    $x = reshape($x, newShape);\n\n    var _getNormalizedAxes = getNormalizedAxes($x.shape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask),\n        normalizedBegin = _getNormalizedAxes.begin,\n        normalizedEnd = _getNormalizedAxes.end,\n        normalizedStrides = _getNormalizedAxes.strides;\n\n    begin = normalizedBegin;\n    end = normalizedEnd;\n    strides = normalizedStrides;\n    var shrinkAxes = maskToAxes(shrinkAxisMask); // Adjust the ends based on the shrink mask.\n\n    shrinkAxes.forEach(function (axis) {\n      end[axis] = begin[axis] + 1;\n      strides[axis] = 1;\n    }); // Figure out the output shape.\n\n    var size = computeOutShape(begin, end, strides); // Remove the axes based on shrinkMask.\n\n    var outShape = size.filter(function (_, axis) {\n      return shrinkAxes.indexOf(axis) === -1;\n    });\n    var nonStrided = strides.every(function (v) {\n      return v === 1;\n    });\n\n    if (nonStrided) {\n      return reshape(slice($x, begin, size), outShape);\n    }\n\n    var res = backend.stridedSlice($x, begin, end, strides);\n    return reshape(res, outShape);\n  };\n\n  var inputs = {\n    x: $x\n  };\n  var attrs = {\n    begin: begin,\n    end: end,\n    strides: strides,\n    beginMask: beginMask,\n    endMask: endMask,\n    ellipsisMask: ellipsisMask,\n    newAxisMask: newAxisMask,\n    shrinkAxisMask: shrinkAxisMask\n  };\n  return ENGINE.runKernelFunc(forward, inputs, null\n  /* grad */\n  , StridedSlice, attrs);\n}\n\nexport var stridedSlice = op({\n  stridedSlice_: stridedSlice_\n});","map":{"version":3,"sources":["../../src/ops/strided_slice.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../engine';\r\nimport { StridedSlice } from '../kernel_names';\r\nimport { convertToTensor } from '../tensor_util_env';\r\nimport { op } from './operation';\r\nimport { reshape } from './reshape';\r\nimport { slice } from './slice';\r\nimport { computeOutShape, getNormalizedAxes, maskToAxes } from './slice_util';\r\n/**\r\n * Extracts a strided slice of a tensor.\r\n *\r\n * Roughly speaking, this op extracts a slice of size (end-begin)/stride from\r\n * the given input tensor (x). Starting at the location specified by begin the\r\n * slice continues by adding stride to the index until all dimensions are not\r\n * less than end. Note that a stride can be negative, which causes a reverse\r\n * slice.\r\n *\r\n * ```js\r\n * const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],\r\n *    [3, 2, 3]);\r\n * t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]\r\n * t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],\r\n *                                                     // [4, 4, 4]]]\r\n * t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],\r\n *                                                     // [3, 3, 3]]]\r\n * ```\r\n *\r\n * @param x The tensor to stride slice.\r\n * @param begin The coordinates to start the slice from.\r\n * @param end: The coordinates to end the slice at.\r\n * @param strides: The size of the slice.\r\n * @param beginMask: If the ith bit of beginMask is set, begin[i] is ignored\r\n *      and the fullest possible range in that dimension is used instead.\r\n * @param endMask: If the ith bit of endMask is set, end[i] is ignored\r\n *      and the fullest possible range in that dimension is used instead.\r\n * @param shrinkAxisMask: a bitmask where bit i implies that\r\n * the ith specification should shrink the dimensionality. begin and end must\r\n * imply a slice of size 1 in the dimension.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\r\n */\r\nfunction stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {\r\n    let $x = convertToTensor(x, 'x', 'stridedSlice');\r\n    const forward = (backend) => {\r\n        if (strides == null) {\r\n            strides = new Array(begin.length);\r\n        }\r\n        const ellipsisAxes = maskToAxes(ellipsisMask);\r\n        if (ellipsisAxes.length > 1) {\r\n            throw new Error('Multiple ellipses in slice is not allowed.');\r\n        }\r\n        if (ellipsisMask !== 0 && newAxisMask !== 0) {\r\n            throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\r\n        }\r\n        if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\r\n            throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\r\n        }\r\n        const numInterpolatedAxes = $x.rank - begin.length;\r\n        // Expand the dims of x based on the newAxisMask.\r\n        const expandAxes = maskToAxes(newAxisMask);\r\n        const newShape = $x.shape.slice();\r\n        expandAxes.forEach(axis => {\r\n            begin[axis] = 0;\r\n            end[axis] = 1;\r\n            newShape.splice(axis, 0, 1);\r\n        });\r\n        $x = reshape($x, newShape);\r\n        const { begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides } = getNormalizedAxes($x.shape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask);\r\n        begin = normalizedBegin;\r\n        end = normalizedEnd;\r\n        strides = normalizedStrides;\r\n        const shrinkAxes = maskToAxes(shrinkAxisMask);\r\n        // Adjust the ends based on the shrink mask.\r\n        shrinkAxes.forEach(axis => {\r\n            end[axis] = begin[axis] + 1;\r\n            strides[axis] = 1;\r\n        });\r\n        // Figure out the output shape.\r\n        const size = computeOutShape(begin, end, strides);\r\n        // Remove the axes based on shrinkMask.\r\n        const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\r\n        const nonStrided = strides.every(v => v === 1);\r\n        if (nonStrided) {\r\n            return reshape(slice($x, begin, size), outShape);\r\n        }\r\n        const res = backend.stridedSlice($x, begin, end, strides);\r\n        return reshape(res, outShape);\r\n    };\r\n    const inputs = { x: $x };\r\n    const attrs = {\r\n        begin,\r\n        end,\r\n        strides,\r\n        beginMask,\r\n        endMask,\r\n        ellipsisMask,\r\n        newAxisMask,\r\n        shrinkAxisMask\r\n    };\r\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, StridedSlice, attrs);\r\n}\r\nexport const stridedSlice = op({ stridedSlice_ });\r\n//# sourceMappingURL=strided_slice.js.map"]},"metadata":{},"sourceType":"module"}