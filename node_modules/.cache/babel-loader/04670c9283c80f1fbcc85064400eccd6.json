{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../engine';\nimport { Range } from '../kernel_names';\nimport { makeZerosTypedArray } from '../util';\nimport { tensor1d } from './tensor1d';\nimport { zeros } from './zeros';\n/**\r\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\r\n *\r\n * The tensor is a is half-open interval meaning it includes start, but\r\n * excludes stop. Decrementing ranges and negative step values are also\r\n * supported.sv\r\n *\r\n *\r\n * ```js\r\n * tf.range(0, 9, 2).print();\r\n * ```\r\n *\r\n * @param start An integer start value\r\n * @param stop An integer stop value\r\n * @param step An integer increment (will default to 1 or -1)\r\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\r\n *\r\n * @doc {heading: 'Tensors', subheading: 'Creation'}\r\n */\n\nexport function range(start, stop, step = 1, dtype = 'float32') {\n  if (step === 0) {\n    throw new Error('Cannot have a step of zero');\n  }\n\n  const forward = () => {\n    const sameStartStop = start === stop;\n    const increasingRangeNegativeStep = start < stop && step < 0;\n    const decreasingRangePositiveStep = stop < start && step > 1;\n\n    if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {\n      return zeros([0], dtype);\n    }\n\n    const numElements = Math.abs(Math.ceil((stop - start) / step));\n    const values = makeZerosTypedArray(numElements, dtype);\n\n    if (stop < start && step === 1) {\n      // Auto adjust the step's sign if it hasn't been set\n      // (or was set to 1)\n      step = -1;\n    }\n\n    values[0] = start;\n\n    for (let i = 1; i < values.length; i++) {\n      values[i] = values[i - 1] + step;\n    }\n\n    return tensor1d(values, dtype);\n  };\n\n  const attrs = {\n    start,\n    stop,\n    step,\n    dtype\n  };\n  return ENGINE.runKernelFunc(forward, {}\n  /* inputs */\n  , null\n  /* grad */\n  , Range, attrs);\n}","map":{"version":3,"sources":["../../src/ops/range.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,QAAkC,WAAlC;AACA,SAAQ,KAAR,QAAgC,iBAAhC;AAGA,SAAQ,mBAAR,QAAkC,SAAlC;AAEA,SAAQ,QAAR,QAAuB,YAAvB;AACA,SAAQ,KAAR,QAAoB,SAApB;AAEA;;;;;;;;;;;;;;;;;;AAkBG;;AACH,OAAM,SAAU,KAAV,CACF,KADE,EACa,IADb,EAC2B,IAAI,GAAG,CADlC,EAEF,KAAA,GAA2B,SAFzB,EAEkC;AACtC,MAAI,IAAI,KAAK,CAAb,EAAgB;AACd,UAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;AACD;;AAED,QAAM,OAAO,GAAwB,MAAK;AACxC,UAAM,aAAa,GAAG,KAAK,KAAK,IAAhC;AACA,UAAM,2BAA2B,GAAG,KAAK,GAAG,IAAR,IAAgB,IAAI,GAAG,CAA3D;AACA,UAAM,2BAA2B,GAAG,IAAI,GAAG,KAAP,IAAgB,IAAI,GAAG,CAA3D;;AAEA,QAAI,aAAa,IAAI,2BAAjB,IACA,2BADJ,EACiC;AAC/B,aAAO,KAAK,CAAC,CAAC,CAAD,CAAD,EAAM,KAAN,CAAZ;AACD;;AAED,UAAM,WAAW,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,IAAL,CAAU,CAAC,IAAI,GAAG,KAAR,IAAiB,IAA3B,CAAT,CAApB;AACA,UAAM,MAAM,GAAG,mBAAmB,CAAC,WAAD,EAAc,KAAd,CAAlC;;AAEA,QAAI,IAAI,GAAG,KAAP,IAAgB,IAAI,KAAK,CAA7B,EAAgC;AAC9B;AACA;AACA,MAAA,IAAI,GAAG,CAAC,CAAR;AACD;;AAED,IAAA,MAAM,CAAC,CAAD,CAAN,GAAY,KAAZ;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,MAAA,MAAM,CAAC,CAAD,CAAN,GAAY,MAAM,CAAC,CAAC,GAAG,CAAL,CAAN,GAAgB,IAA5B;AACD;;AAED,WAAO,QAAQ,CAAC,MAAD,EAAS,KAAT,CAAf;AACD,GAzBD;;AA2BA,QAAM,KAAK,GAAe;AAAC,IAAA,KAAD;AAAQ,IAAA,IAAR;AAAc,IAAA,IAAd;AAAoB,IAAA;AAApB,GAA1B;AAEA,SAAO,MAAM,CAAC,aAAP,CACI,OADJ,EACa;AAAG;AADhB,IAC8B;AAAK;AADnC,IAC+C,KAD/C,EAEI,KAFJ,CAAP;AAGD","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../engine';\r\nimport { Range } from '../kernel_names';\r\nimport { makeZerosTypedArray } from '../util';\r\nimport { tensor1d } from './tensor1d';\r\nimport { zeros } from './zeros';\r\n/**\r\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\r\n *\r\n * The tensor is a is half-open interval meaning it includes start, but\r\n * excludes stop. Decrementing ranges and negative step values are also\r\n * supported.sv\r\n *\r\n *\r\n * ```js\r\n * tf.range(0, 9, 2).print();\r\n * ```\r\n *\r\n * @param start An integer start value\r\n * @param stop An integer stop value\r\n * @param step An integer increment (will default to 1 or -1)\r\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\r\n *\r\n * @doc {heading: 'Tensors', subheading: 'Creation'}\r\n */\r\nexport function range(start, stop, step = 1, dtype = 'float32') {\r\n    if (step === 0) {\r\n        throw new Error('Cannot have a step of zero');\r\n    }\r\n    const forward = () => {\r\n        const sameStartStop = start === stop;\r\n        const increasingRangeNegativeStep = start < stop && step < 0;\r\n        const decreasingRangePositiveStep = stop < start && step > 1;\r\n        if (sameStartStop || increasingRangeNegativeStep ||\r\n            decreasingRangePositiveStep) {\r\n            return zeros([0], dtype);\r\n        }\r\n        const numElements = Math.abs(Math.ceil((stop - start) / step));\r\n        const values = makeZerosTypedArray(numElements, dtype);\r\n        if (stop < start && step === 1) {\r\n            // Auto adjust the step's sign if it hasn't been set\r\n            // (or was set to 1)\r\n            step = -1;\r\n        }\r\n        values[0] = start;\r\n        for (let i = 1; i < values.length; i++) {\r\n            values[i] = values[i - 1] + step;\r\n        }\r\n        return tensor1d(values, dtype);\r\n    };\r\n    const attrs = { start, stop, step, dtype };\r\n    return ENGINE.runKernelFunc(forward, {} /* inputs */, null /* grad */, Range, attrs);\r\n}\r\n//# sourceMappingURL=range.js.map"]},"metadata":{},"sourceType":"module"}