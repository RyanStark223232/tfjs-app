{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport const executeOp = (node, tensorMap, context) => {\n  switch (node.op) {\n    case 'Const':\n      {\n        return tensorMap[node.name];\n      }\n\n    case 'PlaceholderWithDefault':\n      const def = getParamValue('default', node, tensorMap, context);\n      return [getTensor(node.name, tensorMap, context) || def];\n\n    case 'Placeholder':\n      return [getTensor(node.name, tensorMap, context)];\n\n    case 'Identity':\n    case 'StopGradient':\n    case 'FakeQuantWithMinMaxVars':\n      {\n        // This op is currently ignored.\n        const data = getParamValue('x', node, tensorMap, context);\n        return [cloneTensor(data)];\n      }\n\n    case 'IdentityN':\n      return getParamValue('x', node, tensorMap, context).map(t => cloneTensor(t));\n\n    case 'Snapshot':\n      const snapshot = getParamValue('x', node, tensorMap, context);\n      return [cloneTensor(snapshot)];\n\n    case 'Shape':\n      return [tfOps.tensor1d(getParamValue('x', node, tensorMap, context).shape, 'int32')];\n\n    case 'ShapeN':\n      return getParamValue('x', node, tensorMap, context).map(t => tfOps.tensor1d(t.shape));\n\n    case 'Size':\n      return [tfOps.scalar(getParamValue('x', node, tensorMap, context).size, 'int32')];\n\n    case 'Rank':\n      return [tfOps.scalar(getParamValue('x', node, tensorMap, context).rank, 'int32')];\n\n    case 'NoOp':\n      return [tfOps.scalar(1)];\n\n    case 'Print':\n      const input = getParamValue('x', node, tensorMap, context);\n      const data = getParamValue('data', node, tensorMap, context);\n      const message = getParamValue('message', node, tensorMap, context);\n      const summarize = getParamValue('summarize', node, tensorMap, context);\n      console.warn('The graph has a tf.print() operation,' + 'usually used for debugging, which slows down performance.');\n      console.log(message);\n\n      for (let i = 0; i < data.length; i++) {\n        console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0, summarize));\n      }\n\n      return [input];\n\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'graph';","map":{"version":3,"sources":["../../../src/operations/executors/graph_executor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n// tslint:disable-next-line: no-imports-from-dist\r\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\r\nimport { cloneTensor, getParamValue, getTensor } from './utils';\r\nexport const executeOp = (node, tensorMap, context) => {\r\n    switch (node.op) {\r\n        case 'Const': {\r\n            return tensorMap[node.name];\r\n        }\r\n        case 'PlaceholderWithDefault':\r\n            const def = getParamValue('default', node, tensorMap, context);\r\n            return [getTensor(node.name, tensorMap, context) || def];\r\n        case 'Placeholder':\r\n            return [getTensor(node.name, tensorMap, context)];\r\n        case 'Identity':\r\n        case 'StopGradient':\r\n        case 'FakeQuantWithMinMaxVars': { // This op is currently ignored.\r\n            const data = getParamValue('x', node, tensorMap, context);\r\n            return [cloneTensor(data)];\r\n        }\r\n        case 'IdentityN':\r\n            return getParamValue('x', node, tensorMap, context)\r\n                .map((t) => cloneTensor(t));\r\n        case 'Snapshot':\r\n            const snapshot = getParamValue('x', node, tensorMap, context);\r\n            return [cloneTensor(snapshot)];\r\n        case 'Shape':\r\n            return [tfOps.tensor1d(getParamValue('x', node, tensorMap, context).shape, 'int32')];\r\n        case 'ShapeN':\r\n            return getParamValue('x', node, tensorMap, context)\r\n                .map((t) => tfOps.tensor1d(t.shape));\r\n        case 'Size':\r\n            return [tfOps.scalar(getParamValue('x', node, tensorMap, context).size, 'int32')];\r\n        case 'Rank':\r\n            return [tfOps.scalar(getParamValue('x', node, tensorMap, context).rank, 'int32')];\r\n        case 'NoOp':\r\n            return [tfOps.scalar(1)];\r\n        case 'Print':\r\n            const input = getParamValue('x', node, tensorMap, context);\r\n            const data = getParamValue('data', node, tensorMap, context);\r\n            const message = getParamValue('message', node, tensorMap, context);\r\n            const summarize = getParamValue('summarize', node, tensorMap, context);\r\n            console.warn('The graph has a tf.print() operation,' +\r\n                'usually used for debugging, which slows down performance.');\r\n            console.log(message);\r\n            for (let i = 0; i < data.length; i++) {\r\n                console.log(Array.prototype.slice.call(data[i].dataSync())\r\n                    .slice(0, summarize));\r\n            }\r\n            return [input];\r\n        default:\r\n            throw TypeError(`Node type ${node.op} is not implemented`);\r\n    }\r\n};\r\nexport const CATEGORY = 'graph';\r\n//# sourceMappingURL=graph_executor.js.map"]},"metadata":{},"sourceType":"module"}