{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\n\n/**\r\n * Gets the new shape of the input Tensor after it's been reshaped\r\n * to:\r\n * [blockShape[0], ..., blockShape[M-1], batch / prod(blockShape),\r\n * inputShape[1], ..., inputShape[N-1]]\r\n *\r\n * See step 1: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\r\n */\nexport function getReshaped(inputShape, blockShape, prod) {\n  var batchToSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var reshaped = [];\n\n  if (batchToSpace) {\n    reshaped = reshaped.concat(blockShape.slice(0));\n    reshaped.push(inputShape[0] / prod);\n    reshaped = reshaped.concat(inputShape.slice(1));\n  } else {\n    reshaped = reshaped.concat(inputShape[0]);\n    var spatialLength = blockShape.length;\n\n    for (var i = 0; i < spatialLength; ++i) {\n      reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);\n    }\n\n    reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));\n  }\n\n  return reshaped;\n}\n/**\r\n * Gets the permutation that will transpose the dimensions of the\r\n * reshaped tensor to shape:\r\n *\r\n * [batch / prod(block_shape),inputShape[1], blockShape[0], ...,\r\n * inputShape[M], blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\r\n *\r\n * see step 2: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\r\n */\n\nexport function getPermuted(reshapedRank, blockShapeRank) {\n  var batchToSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var permuted = [];\n\n  if (batchToSpace) {\n    permuted.push(blockShapeRank);\n\n    for (var i = blockShapeRank + 1; i < reshapedRank; ++i) {\n      if (i <= 2 * blockShapeRank) {\n        permuted.push(i);\n        permuted.push(i - (blockShapeRank + 1));\n      } else {\n        permuted.push(i);\n      }\n    }\n  } else {\n    var permutedBeforeBatch = [];\n    var permutedAfterBatch = [];\n\n    for (var _i = 1; _i < reshapedRank; ++_i) {\n      if (_i >= blockShapeRank * 2 + 1 || _i % 2 === 1) {\n        permutedAfterBatch.push(_i);\n      } else {\n        permutedBeforeBatch.push(_i);\n      }\n    }\n\n    permuted.push.apply(permuted, permutedBeforeBatch);\n    permuted.push(0);\n    permuted.push.apply(permuted, permutedAfterBatch);\n  }\n\n  return permuted;\n}\n/**\r\n * Gets the shape of the reshaped and permuted input Tensor before any cropping\r\n * is applied.  The new shape will be:\r\n *\r\n * [batch / prod(blockShape),inputShape[1] * blockShape[0], ...,\r\n * inputShape[M] * blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\r\n *\r\n * See step 3: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\r\n */\n\nexport function getReshapedPermuted(inputShape, blockShape, prod) {\n  var batchToSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var reshapedPermuted = [];\n\n  if (batchToSpace) {\n    reshapedPermuted.push(inputShape[0] / prod);\n  } else {\n    reshapedPermuted.push(inputShape[0] * prod);\n  }\n\n  for (var i = 1; i < inputShape.length; ++i) {\n    if (i <= blockShape.length) {\n      if (batchToSpace) {\n        reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);\n      } else {\n        reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);\n      }\n    } else {\n      reshapedPermuted.push(inputShape[i]);\n    }\n  }\n\n  return reshapedPermuted;\n}\n/**\r\n * Converts the crops argument into the beginning coordinates of a slice\r\n * operation.\r\n */\n\nexport function getSliceBeginCoords(crops, blockShape) {\n  var sliceBeginCoords = [0];\n\n  for (var i = 0; i < blockShape; ++i) {\n    sliceBeginCoords.push(crops[i][0]);\n  }\n\n  return sliceBeginCoords;\n}\n/**\r\n * Converts the crops argument into the size of a slice operation.  When\r\n * combined with getSliceBeginCoords this function allows the reshaped and\r\n * permuted Tensor to be cropped to its final output shape of:\r\n *\r\n * inputShape[1] * blockShape[0] - crops[0,0] - crops[0,1], ...,\r\n * inputShape[M] * blockShape[M-1] -crops[M-1,0] -\r\n * crops[M-1,1],inputShape[M+1], ..., inputShape[N-1]]\r\n *\r\n * See step 4: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\r\n */\n\nexport function getSliceSize(uncroppedShape, crops, blockShape) {\n  var sliceSize = uncroppedShape.slice(0, 1);\n\n  for (var i = 0; i < blockShape; ++i) {\n    sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);\n  }\n\n  return sliceSize;\n}","map":{"version":3,"sources":["../../src/ops/array_ops_util.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;;AAEH;;;;;;;AAOG;AACH,OAAM,SAAU,WAAV,CACF,UADE,EACoB,UADpB,EAC0C,IAD1C,EAEiB;AAAA,MAAnB,YAAmB,uEAAJ,IAAI;AACrB,MAAI,QAAQ,GAAa,EAAzB;;AACA,MAAI,YAAJ,EAAkB;AAChB,IAAA,QAAQ,GAAG,QAAQ,CAAC,MAAT,CAAgB,UAAU,CAAC,KAAX,CAAiB,CAAjB,CAAhB,CAAX;AACA,IAAA,QAAQ,CAAC,IAAT,CAAc,UAAU,CAAC,CAAD,CAAV,GAAgB,IAA9B;AACA,IAAA,QAAQ,GAAG,QAAQ,CAAC,MAAT,CAAgB,UAAU,CAAC,KAAX,CAAiB,CAAjB,CAAhB,CAAX;AACD,GAJD,MAIO;AACL,IAAA,QAAQ,GAAG,QAAQ,CAAC,MAAT,CAAgB,UAAU,CAAC,CAAD,CAA1B,CAAX;AACA,QAAM,aAAa,GAAG,UAAU,CAAC,MAAjC;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,aAApB,EAAmC,EAAE,CAArC,EAAwC;AACtC,MAAA,QAAQ,GACJ,QAAQ,CAAC,MAAT,CAAgB,CAAC,UAAU,CAAC,CAAC,GAAG,CAAL,CAAV,GAAoB,UAAU,CAAC,CAAD,CAA/B,EAAoC,UAAU,CAAC,CAAD,CAA9C,CAAhB,CADJ;AAED;;AACD,IAAA,QAAQ,GAAG,QAAQ,CAAC,MAAT,CAAgB,UAAU,CAAC,KAAX,CAAiB,aAAa,GAAG,CAAjC,CAAhB,CAAX;AACD;;AACD,SAAO,QAAP;AACD;AAED;;;;;;;;AAQG;;AACH,OAAM,SAAU,WAAV,CACF,YADE,EACoB,cADpB,EAEiB;AAAA,MAAnB,YAAmB,uEAAJ,IAAI;AACrB,MAAM,QAAQ,GAAG,EAAjB;;AACA,MAAI,YAAJ,EAAkB;AAChB,IAAA,QAAQ,CAAC,IAAT,CAAc,cAAd;;AACA,SAAK,IAAI,CAAC,GAAG,cAAc,GAAG,CAA9B,EAAiC,CAAC,GAAG,YAArC,EAAmD,EAAE,CAArD,EAAwD;AACtD,UAAI,CAAC,IAAI,IAAI,cAAb,EAA6B;AAC3B,QAAA,QAAQ,CAAC,IAAT,CAAc,CAAd;AACA,QAAA,QAAQ,CAAC,IAAT,CAAc,CAAC,IAAI,cAAc,GAAG,CAArB,CAAf;AACD,OAHD,MAGO;AACL,QAAA,QAAQ,CAAC,IAAT,CAAc,CAAd;AACD;AACF;AACF,GAVD,MAUO;AACL,QAAM,mBAAmB,GAAG,EAA5B;AACA,QAAM,kBAAkB,GAAG,EAA3B;;AACA,SAAK,IAAI,EAAC,GAAG,CAAb,EAAgB,EAAC,GAAG,YAApB,EAAkC,EAAE,EAApC,EAAuC;AACrC,UAAI,EAAC,IAAI,cAAc,GAAG,CAAjB,GAAqB,CAA1B,IAA+B,EAAC,GAAG,CAAJ,KAAU,CAA7C,EAAgD;AAC9C,QAAA,kBAAkB,CAAC,IAAnB,CAAwB,EAAxB;AACD,OAFD,MAEO;AACL,QAAA,mBAAmB,CAAC,IAApB,CAAyB,EAAzB;AACD;AACF;;AACD,IAAA,QAAQ,CAAC,IAAT,OAAA,QAAQ,EAAS,mBAAT,CAAR;AACA,IAAA,QAAQ,CAAC,IAAT,CAAc,CAAd;AACA,IAAA,QAAQ,CAAC,IAAT,OAAA,QAAQ,EAAS,kBAAT,CAAR;AACD;;AACD,SAAO,QAAP;AACD;AAED;;;;;;;;AAQG;;AACH,OAAM,SAAU,mBAAV,CACF,UADE,EACoB,UADpB,EAC0C,IAD1C,EAEiB;AAAA,MAAnB,YAAmB,uEAAJ,IAAI;AACrB,MAAM,gBAAgB,GAAG,EAAzB;;AAEA,MAAI,YAAJ,EAAkB;AAChB,IAAA,gBAAgB,CAAC,IAAjB,CAAsB,UAAU,CAAC,CAAD,CAAV,GAAgB,IAAtC;AACD,GAFD,MAEO;AACL,IAAA,gBAAgB,CAAC,IAAjB,CAAsB,UAAU,CAAC,CAAD,CAAV,GAAgB,IAAtC;AACD;;AAED,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAAU,CAAC,MAA/B,EAAuC,EAAE,CAAzC,EAA4C;AAC1C,QAAI,CAAC,IAAI,UAAU,CAAC,MAApB,EAA4B;AAC1B,UAAI,YAAJ,EAAkB;AAChB,QAAA,gBAAgB,CAAC,IAAjB,CAAsB,UAAU,CAAC,CAAC,GAAG,CAAL,CAAV,GAAoB,UAAU,CAAC,CAAD,CAApD;AACD,OAFD,MAEO;AACL,QAAA,gBAAgB,CAAC,IAAjB,CAAsB,UAAU,CAAC,CAAD,CAAV,GAAgB,UAAU,CAAC,CAAC,GAAG,CAAL,CAAhD;AACD;AACF,KAND,MAMO;AACL,MAAA,gBAAgB,CAAC,IAAjB,CAAsB,UAAU,CAAC,CAAD,CAAhC;AACD;AACF;;AAED,SAAO,gBAAP;AACD;AAED;;;AAGG;;AACH,OAAM,SAAU,mBAAV,CACF,KADE,EACiB,UADjB,EACmC;AACvC,MAAM,gBAAgB,GAAG,CAAC,CAAD,CAAzB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,EAAE,CAAlC,EAAqC;AACnC,IAAA,gBAAgB,CAAC,IAAjB,CAAsB,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,CAAtB;AACD;;AACD,SAAO,gBAAP;AACD;AAED;;;;;;;;;;AAUG;;AACH,OAAM,SAAU,YAAV,CACF,cADE,EACwB,KADxB,EAC2C,UAD3C,EAC6D;AACjE,MAAM,SAAS,GAAG,cAAc,CAAC,KAAf,CAAqB,CAArB,EAAwB,CAAxB,CAAlB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,EAAE,CAAlC,EAAqC;AACnC,IAAA,SAAS,CAAC,IAAV,CAAe,cAAc,CAAC,CAAC,GAAG,CAAL,CAAd,GAAwB,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,CAAxB,GAAsC,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,CAArD;AACD;;AAED,SAAO,SAAP;AACD","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n/**\r\n * Gets the new shape of the input Tensor after it's been reshaped\r\n * to:\r\n * [blockShape[0], ..., blockShape[M-1], batch / prod(blockShape),\r\n * inputShape[1], ..., inputShape[N-1]]\r\n *\r\n * See step 1: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\r\n */\r\nexport function getReshaped(inputShape, blockShape, prod, batchToSpace = true) {\r\n    let reshaped = [];\r\n    if (batchToSpace) {\r\n        reshaped = reshaped.concat(blockShape.slice(0));\r\n        reshaped.push(inputShape[0] / prod);\r\n        reshaped = reshaped.concat(inputShape.slice(1));\r\n    }\r\n    else {\r\n        reshaped = reshaped.concat(inputShape[0]);\r\n        const spatialLength = blockShape.length;\r\n        for (let i = 0; i < spatialLength; ++i) {\r\n            reshaped =\r\n                reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);\r\n        }\r\n        reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));\r\n    }\r\n    return reshaped;\r\n}\r\n/**\r\n * Gets the permutation that will transpose the dimensions of the\r\n * reshaped tensor to shape:\r\n *\r\n * [batch / prod(block_shape),inputShape[1], blockShape[0], ...,\r\n * inputShape[M], blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\r\n *\r\n * see step 2: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\r\n */\r\nexport function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {\r\n    const permuted = [];\r\n    if (batchToSpace) {\r\n        permuted.push(blockShapeRank);\r\n        for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {\r\n            if (i <= 2 * blockShapeRank) {\r\n                permuted.push(i);\r\n                permuted.push(i - (blockShapeRank + 1));\r\n            }\r\n            else {\r\n                permuted.push(i);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const permutedBeforeBatch = [];\r\n        const permutedAfterBatch = [];\r\n        for (let i = 1; i < reshapedRank; ++i) {\r\n            if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {\r\n                permutedAfterBatch.push(i);\r\n            }\r\n            else {\r\n                permutedBeforeBatch.push(i);\r\n            }\r\n        }\r\n        permuted.push(...permutedBeforeBatch);\r\n        permuted.push(0);\r\n        permuted.push(...permutedAfterBatch);\r\n    }\r\n    return permuted;\r\n}\r\n/**\r\n * Gets the shape of the reshaped and permuted input Tensor before any cropping\r\n * is applied.  The new shape will be:\r\n *\r\n * [batch / prod(blockShape),inputShape[1] * blockShape[0], ...,\r\n * inputShape[M] * blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\r\n *\r\n * See step 3: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\r\n */\r\nexport function getReshapedPermuted(inputShape, blockShape, prod, batchToSpace = true) {\r\n    const reshapedPermuted = [];\r\n    if (batchToSpace) {\r\n        reshapedPermuted.push(inputShape[0] / prod);\r\n    }\r\n    else {\r\n        reshapedPermuted.push(inputShape[0] * prod);\r\n    }\r\n    for (let i = 1; i < inputShape.length; ++i) {\r\n        if (i <= blockShape.length) {\r\n            if (batchToSpace) {\r\n                reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);\r\n            }\r\n            else {\r\n                reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);\r\n            }\r\n        }\r\n        else {\r\n            reshapedPermuted.push(inputShape[i]);\r\n        }\r\n    }\r\n    return reshapedPermuted;\r\n}\r\n/**\r\n * Converts the crops argument into the beginning coordinates of a slice\r\n * operation.\r\n */\r\nexport function getSliceBeginCoords(crops, blockShape) {\r\n    const sliceBeginCoords = [0];\r\n    for (let i = 0; i < blockShape; ++i) {\r\n        sliceBeginCoords.push(crops[i][0]);\r\n    }\r\n    return sliceBeginCoords;\r\n}\r\n/**\r\n * Converts the crops argument into the size of a slice operation.  When\r\n * combined with getSliceBeginCoords this function allows the reshaped and\r\n * permuted Tensor to be cropped to its final output shape of:\r\n *\r\n * inputShape[1] * blockShape[0] - crops[0,0] - crops[0,1], ...,\r\n * inputShape[M] * blockShape[M-1] -crops[M-1,0] -\r\n * crops[M-1,1],inputShape[M+1], ..., inputShape[N-1]]\r\n *\r\n * See step 4: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\r\n */\r\nexport function getSliceSize(uncroppedShape, crops, blockShape) {\r\n    const sliceSize = uncroppedShape.slice(0, 1);\r\n    for (let i = 0; i < blockShape; ++i) {\r\n        sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);\r\n    }\r\n    return sliceSize;\r\n}\r\n//# sourceMappingURL=array_ops_util.js.map"]},"metadata":{},"sourceType":"module"}