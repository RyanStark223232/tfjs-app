{"ast":null,"code":"import { env } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\nexport const CHECK_NAN_SNIPPET_BINARY = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippets Op snippet to create `UnaryOpProgram`.\n */\n\nexport function unaryKernelFunc(opSnippet) {\n  return ({\n    inputs,\n    backend\n  }) => {\n    const {\n      x\n    } = inputs;\n    const webglBackend = backend;\n    const program = new UnaryOpProgram(x.shape, opSnippet);\n    return webglBackend.runWebGLProgram(program, [x], x.dtype);\n  };\n}\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\n\nexport function binaryKernelFunc(opSnippet, packedOpSnippet, checkOutOfBoundsForPackedProgram, dtype) {\n  // TODO(jingjin): handle complex64.\n  return ({\n    inputs,\n    backend\n  }) => {\n    const {\n      a,\n      b\n    } = inputs;\n    const webglBackend = backend;\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ? new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, !!checkOutOfBoundsForPackedProgram) : new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    const $dtype = dtype || a.dtype;\n    const output = webglBackend.runWebGLProgram(program, [a, b], $dtype);\n    return output;\n  };\n}","map":{"version":3,"sources":["../../src/kernel_utils/kernel_funcs_utils.ts"],"names":[],"mappings":"AAAA,SAAgC,GAAhC,QAAmE,uBAAnE;AAGA,SAAQ,eAAR,QAA8B,iBAA9B;AACA,SAAQ,qBAAR,QAAoC,wBAApC;AACA,SAAQ,cAAR,QAA6B,gBAA7B;AAEA,OAAO,MAAM,uBAAuB,GAAG,yBAAhC;AAEP,OAAO,MAAM,wBAAwB,GAAG;;;AAGvC,CAHM;AAKP,OAAO,MAAM,+BAA+B,GAAG;;;;;AAK9C,CALM;AAOP;;;AAGG;;AACH,OAAM,SAAU,eAAV,CAA0B,SAA1B,EAA2C;AAC/C,SAAO,CAAC;AAAC,IAAA,MAAD;AAAS,IAAA;AAAT,GAAD,KAAsB;AAC3B,UAAM;AAAC,MAAA;AAAD,QAAM,MAAZ;AACA,UAAM,YAAY,GAAG,OAArB;AACA,UAAM,OAAO,GAAG,IAAI,cAAJ,CAAmB,CAAC,CAAC,KAArB,EAA4B,SAA5B,CAAhB;AACA,WAAO,YAAY,CAAC,eAAb,CAA6B,OAA7B,EAAsC,CAAC,CAAD,CAAtC,EAA2C,CAAC,CAAC,KAA7C,CAAP;AACD,GALD;AAMD;AAED;;;;;;;;;AASG;;AACH,OAAM,SAAU,gBAAV,CACF,SADE,EACiB,eADjB,EAEF,gCAFE,EAE0C,KAF1C,EAE0D;AAC9D;AAEA,SAAO,CAAC;AAAC,IAAA,MAAD;AAAS,IAAA;AAAT,GAAD,KAAsB;AAC3B,UAAM;AAAC,MAAA,CAAD;AAAI,MAAA;AAAJ,QAAS,MAAf;AACA,UAAM,YAAY,GAAG,OAArB;AACA,UAAM,OAAO,GAAG,GAAG,GAAG,OAAN,CAAc,8BAAd,IACZ,IAAI,qBAAJ,CACI,eADJ,EACqB,CAAC,CAAC,KADvB,EAC8B,CAAC,CAAC,KADhC,EAEI,CAAC,CAAC,gCAFN,CADY,GAIZ,IAAI,eAAJ,CAAoB,SAApB,EAA+B,CAAC,CAAC,KAAjC,EAAwC,CAAC,CAAC,KAA1C,CAJJ;AAKA,UAAM,MAAM,GAAG,KAAK,IAAI,CAAC,CAAC,KAA1B;AACA,UAAM,MAAM,GAAG,YAAY,CAAC,eAAb,CAA6B,OAA7B,EAAsC,CAAC,CAAD,EAAI,CAAJ,CAAtC,EAA8C,MAA9C,CAAf;AACA,WAAO,MAAP;AACD,GAXD;AAYD","sourceRoot":"","sourcesContent":["import { env } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\nexport const CHECK_NAN_SNIPPET_BINARY = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippets Op snippet to create `UnaryOpProgram`.\n */\nexport function unaryKernelFunc(opSnippet) {\n    return ({ inputs, backend }) => {\n        const { x } = inputs;\n        const webglBackend = backend;\n        const program = new UnaryOpProgram(x.shape, opSnippet);\n        return webglBackend.runWebGLProgram(program, [x], x.dtype);\n    };\n}\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc(opSnippet, packedOpSnippet, checkOutOfBoundsForPackedProgram, dtype) {\n    // TODO(jingjin): handle complex64.\n    return ({ inputs, backend }) => {\n        const { a, b } = inputs;\n        const webglBackend = backend;\n        const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n            new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, !!checkOutOfBoundsForPackedProgram) :\n            new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        const $dtype = dtype || a.dtype;\n        const output = webglBackend.runWebGLProgram(program, [a, b], $dtype);\n        return output;\n    };\n}\n//# sourceMappingURL=kernel_funcs_utils.js.map"]},"metadata":{},"sourceType":"module"}