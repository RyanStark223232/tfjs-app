{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { mul } from '../mul';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { reverse } from '../reverse';\nimport { scalar } from '../scalar';\nimport { slice } from '../slice';\nimport { ifft } from './ifft';\n/**\r\n * Inversed real value input fast Fourier transform.\r\n *\r\n * Computes the 1-dimensional inversed discrete Fourier transform over the\r\n * inner-most dimension of the real input.\r\n *\r\n * ```js\r\n * const real = tf.tensor1d([1, 2, 3]);\r\n * const imag = tf.tensor1d([0, 0, 0]);\r\n * const x = tf.complex(real, imag);\r\n *\r\n * x.irfft().print();\r\n * ```\r\n * @param input The real value input to compute an irfft over.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\r\n */\n\nfunction irfft_(input) {\n  const innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  let ret;\n\n  if (innerDimensionSize <= 2) {\n    const complexInput = reshape(input, [batch, innerDimensionSize]);\n    ret = ifft(complexInput);\n  } else {\n    // The length of unique components of the DFT of a real-valued signal\n    // is 2 * (input_len - 1)\n    const outputShape = [batch, 2 * (innerDimensionSize - 1)];\n    const realInput = reshape(real(input), [batch, innerDimensionSize]);\n    const imagInput = reshape(imag(input), [batch, innerDimensionSize]);\n    const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);\n    const imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));\n    const r = concat([realInput, realConjugate], 1);\n    const i = concat([imagInput, imagConjugate], 1);\n    const complexInput = reshape(complex(r, i), [outputShape[0], outputShape[1]]);\n    ret = ifft(complexInput);\n  }\n\n  ret = real(ret); // reshape the result if the input is 3D tensor.\n\n  if (input.rank === 3 && input.shape[0] !== 0) {\n    const temp = ret;\n    const batch = input.shape[0];\n    ret = reshape(ret, [batch, ret.shape[0] / batch, ret.shape[1]]);\n    temp.dispose();\n  }\n\n  return ret;\n}\n\nexport const irfft = op({\n  irfft_\n});","map":{"version":3,"sources":["../../../src/ops/spectral/irfft.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { complex } from '../complex';\r\nimport { concat } from '../concat';\r\nimport { imag } from '../imag';\r\nimport { mul } from '../mul';\r\nimport { op } from '../operation';\r\nimport { real } from '../real';\r\nimport { reshape } from '../reshape';\r\nimport { reverse } from '../reverse';\r\nimport { scalar } from '../scalar';\r\nimport { slice } from '../slice';\r\nimport { ifft } from './ifft';\r\n/**\r\n * Inversed real value input fast Fourier transform.\r\n *\r\n * Computes the 1-dimensional inversed discrete Fourier transform over the\r\n * inner-most dimension of the real input.\r\n *\r\n * ```js\r\n * const real = tf.tensor1d([1, 2, 3]);\r\n * const imag = tf.tensor1d([0, 0, 0]);\r\n * const x = tf.complex(real, imag);\r\n *\r\n * x.irfft().print();\r\n * ```\r\n * @param input The real value input to compute an irfft over.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\r\n */\r\nfunction irfft_(input) {\r\n    const innerDimensionSize = input.shape[input.shape.length - 1];\r\n    const batch = input.size / innerDimensionSize;\r\n    let ret;\r\n    if (innerDimensionSize <= 2) {\r\n        const complexInput = reshape(input, [batch, innerDimensionSize]);\r\n        ret = ifft(complexInput);\r\n    }\r\n    else {\r\n        // The length of unique components of the DFT of a real-valued signal\r\n        // is 2 * (input_len - 1)\r\n        const outputShape = [batch, 2 * (innerDimensionSize - 1)];\r\n        const realInput = reshape(real(input), [batch, innerDimensionSize]);\r\n        const imagInput = reshape(imag(input), [batch, innerDimensionSize]);\r\n        const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);\r\n        const imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));\r\n        const r = concat([realInput, realConjugate], 1);\r\n        const i = concat([imagInput, imagConjugate], 1);\r\n        const complexInput = reshape(complex(r, i), [outputShape[0], outputShape[1]]);\r\n        ret = ifft(complexInput);\r\n    }\r\n    ret = real(ret);\r\n    // reshape the result if the input is 3D tensor.\r\n    if (input.rank === 3 && input.shape[0] !== 0) {\r\n        const temp = ret;\r\n        const batch = input.shape[0];\r\n        ret = reshape(ret, [batch, ret.shape[0] / batch, ret.shape[1]]);\r\n        temp.dispose();\r\n    }\r\n    return ret;\r\n}\r\nexport const irfft = op({ irfft_ });\r\n//# sourceMappingURL=irfft.js.map"]},"metadata":{},"sourceType":"module"}