{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../engine';\nimport { UnsortedSegmentSum } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, isInt } from '../util';\nimport { op } from './operation';\n/**\r\n * Computes the sum along segments of a `tf.Tensor`.\r\n *\r\n * ```js\r\n * const x = tf.tensor1d([1, 2, 3, 4]);\r\n * const segmentIds = tf.tensor1d([1, 2, 0, 1], 'int32');\r\n * const numSegments = 3;\r\n *\r\n * x.unsortedSegmentSum(segmentIds, numSegments).print()\r\n * //or tf.unsortedSegmentSum(x, segmentIds, numSegments)\r\n * ```\r\n * @param x The `tf.Tensor` that will be summed along its segments.\r\n * @param segmentIds A `tf.Tensor1D` whose rank is equal to the rank of `x`'s\r\n * dimension along the `axis`.  Maps each element of `x` to a segment.\r\n * @param numSegments The number of distinct `segmentIds`.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Segment'}\r\n */\n\nfunction unsortedSegmentSum_(x, segmentIds, numSegments) {\n  const $x = convertToTensor(x, 'x', 'unsortedSegmentSum');\n  const $segmentIds = convertToTensor(segmentIds, 'segmentIds', 'unsortedSegmentSum', 'int32');\n  assert(isInt(numSegments), () => 'numSegments must be of dtype int');\n  const inputs = {\n    x: $x,\n    segmentIds: $segmentIds\n  };\n  const attrs = {\n    numSegments\n  };\n\n  const forward = (backend, save) => {\n    const res = backend.unsortedSegmentSum($x, $segmentIds, numSegments);\n    save([$segmentIds]);\n    return res;\n  };\n\n  return ENGINE.runKernelFunc(forward, inputs, null\n  /* grad */\n  , UnsortedSegmentSum, attrs);\n}\n\nexport const unsortedSegmentSum = op({\n  unsortedSegmentSum_\n});","map":{"version":3,"sources":["../../src/ops/unsorted_segment_sum.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,QAAkC,WAAlC;AACA,SAAQ,kBAAR,QAAoF,iBAApF;AAIA,SAAQ,eAAR,QAA8B,oBAA9B;AAEA,SAAQ,MAAR,EAAgB,KAAhB,QAA4B,SAA5B;AAEA,SAAQ,EAAR,QAAiB,aAAjB;AAEA;;;;;;;;;;;;;;;;;AAiBG;;AACH,SAAS,mBAAT,CACI,CADJ,EACqB,UADrB,EACsD,WADtD,EACyE;AACvE,QAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,oBAAT,CAA1B;AACA,QAAM,WAAW,GACb,eAAe,CAAC,UAAD,EAAa,YAAb,EAA2B,oBAA3B,EAAiD,OAAjD,CADnB;AAEA,EAAA,MAAM,CAAC,KAAK,CAAC,WAAD,CAAN,EAAqB,MAAM,kCAA3B,CAAN;AAEA,QAAM,MAAM,GAA6B;AAAC,IAAA,CAAC,EAAE,EAAJ;AAAQ,IAAA,UAAU,EAAE;AAApB,GAAzC;AACA,QAAM,KAAK,GAA4B;AAAC,IAAA;AAAD,GAAvC;;AAEA,QAAM,OAAO,GAAwB,CAAC,OAAD,EAAU,IAAV,KAAkB;AACrD,UAAM,GAAG,GAAG,OAAO,CAAC,kBAAR,CAA2B,EAA3B,EAA+B,WAA/B,EAA4C,WAA5C,CAAZ;AACA,IAAA,IAAI,CAAC,CAAC,WAAD,CAAD,CAAJ;AACA,WAAO,GAAP;AACD,GAJD;;AAMA,SAAO,MAAM,CAAC,aAAP,CACI,OADJ,EACa,MADb,EAC6C;AAAK;AADlD,IAEI,kBAFJ,EAEwB,KAFxB,CAAP;AAGD;;AAED,OAAO,MAAM,kBAAkB,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAA7B","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../engine';\r\nimport { UnsortedSegmentSum } from '../kernel_names';\r\nimport { convertToTensor } from '../tensor_util_env';\r\nimport { assert, isInt } from '../util';\r\nimport { op } from './operation';\r\n/**\r\n * Computes the sum along segments of a `tf.Tensor`.\r\n *\r\n * ```js\r\n * const x = tf.tensor1d([1, 2, 3, 4]);\r\n * const segmentIds = tf.tensor1d([1, 2, 0, 1], 'int32');\r\n * const numSegments = 3;\r\n *\r\n * x.unsortedSegmentSum(segmentIds, numSegments).print()\r\n * //or tf.unsortedSegmentSum(x, segmentIds, numSegments)\r\n * ```\r\n * @param x The `tf.Tensor` that will be summed along its segments.\r\n * @param segmentIds A `tf.Tensor1D` whose rank is equal to the rank of `x`'s\r\n * dimension along the `axis`.  Maps each element of `x` to a segment.\r\n * @param numSegments The number of distinct `segmentIds`.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Segment'}\r\n */\r\nfunction unsortedSegmentSum_(x, segmentIds, numSegments) {\r\n    const $x = convertToTensor(x, 'x', 'unsortedSegmentSum');\r\n    const $segmentIds = convertToTensor(segmentIds, 'segmentIds', 'unsortedSegmentSum', 'int32');\r\n    assert(isInt(numSegments), () => 'numSegments must be of dtype int');\r\n    const inputs = { x: $x, segmentIds: $segmentIds };\r\n    const attrs = { numSegments };\r\n    const forward = (backend, save) => {\r\n        const res = backend.unsortedSegmentSum($x, $segmentIds, numSegments);\r\n        save([$segmentIds]);\r\n        return res;\r\n    };\r\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, UnsortedSegmentSum, attrs);\r\n}\r\nexport const unsortedSegmentSum = op({ unsortedSegmentSum_ });\r\n//# sourceMappingURL=unsorted_segment_sum.js.map"]},"metadata":{},"sourceType":"module"}