{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nvar PassthroughLoader = /*#__PURE__*/function () {\n  function PassthroughLoader(modelArtifacts) {\n    _classCallCheck(this, PassthroughLoader);\n\n    this.modelArtifacts = modelArtifacts;\n  }\n\n  _createClass(PassthroughLoader, [{\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.modelArtifacts);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function load() {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }]);\n\n  return PassthroughLoader;\n}();\n\nvar PassthroughSaver = /*#__PURE__*/function () {\n  function PassthroughSaver(saveHandler) {\n    _classCallCheck(this, PassthroughSaver);\n\n    this.saveHandler = saveHandler;\n  }\n\n  _createClass(PassthroughSaver, [{\n    key: \"save\",\n    value: function () {\n      var _save = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(modelArtifacts) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.saveHandler(modelArtifacts));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function save(_x) {\n        return _save.apply(this, arguments);\n      }\n\n      return save;\n    }()\n  }]);\n\n  return PassthroughSaver;\n}();\n/**\r\n * Creates an IOHandler that loads model artifacts from memory.\r\n *\r\n * When used in conjunction with `tf.loadLayersModel`, an instance of\r\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\r\n *\r\n * ```js\r\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\r\n *     modelTopology, weightSpecs, weightData));\r\n * ```\r\n *\r\n * @param modelArtifacts a object containing model topology (i.e., parsed from\r\n *   the JSON format).\r\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\r\n *   names, shapes, types, and quantization of the weight data.\r\n * @param weightData A single `ArrayBuffer` containing the weight data,\r\n *   concatenated in the order described by the weightSpecs.\r\n * @param trainingConfig Model training configuration. Optional.\r\n *\r\n * @returns A passthrough `IOHandler` that simply loads the provided data.\r\n */\n\n\nexport function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n  if (arguments.length === 1) {\n    var isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;\n\n    if (isModelArtifacts) {\n      return new PassthroughLoader(modelArtifacts);\n    } else {\n      // Legacy support: with only modelTopology.\n      // TODO(cais): Remove this deprecated API.\n      console.warn('Please call tf.io.fromMemory() with only one argument. ' + 'The argument should be of type ModelArtifacts. ' + 'The multi-argument signature of tf.io.fromMemory() has been ' + 'deprecated and will be removed in a future release.');\n      return new PassthroughLoader({\n        modelTopology: modelArtifacts\n      });\n    }\n  } else {\n    // Legacy support.\n    // TODO(cais): Remove this deprecated API.\n    console.warn('Please call tf.io.fromMemory() with only one argument. ' + 'The argument should be of type ModelArtifacts. ' + 'The multi-argument signature of tf.io.fromMemory() has been ' + 'deprecated and will be removed in a future release.');\n    return new PassthroughLoader({\n      modelTopology: modelArtifacts,\n      weightSpecs: weightSpecs,\n      weightData: weightData,\n      trainingConfig: trainingConfig\n    });\n  }\n}\n/**\r\n * Creates an IOHandler that passes saved model artifacts to a callback.\r\n *\r\n * ```js\r\n * function handleSave(artifacts) {\r\n *   // ... do something with the artifacts ...\r\n *   return {modelArtifactsInfo: {...}, ...};\r\n * }\r\n *\r\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\r\n * ```\r\n *\r\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\r\n *     `SaveResult`.\r\n */\n\nexport function withSaveHandler(saveHandler) {\n  return new PassthroughSaver(saveHandler);\n}","map":{"version":3,"sources":["../../src/io/passthrough.ts"],"names":[],"mappings":";;;;;AAAA;;;;;;;;;;;;;;;AAeG;IAQG,iB;AACJ,6BAA6B,cAA7B,EAA4D;AAAA;;AAA/B,SAAA,cAAA,GAAA,cAAA;AAAmC;;;;;;;;;;iDAGvD,KAAK,c;;;;;;;;;;;;;;;;;;;;;IAIV,gB;AACJ,4BACqB,WADrB,EAE0D;AAAA;;AADrC,SAAA,WAAA,GAAA,WAAA;AACyC;;;;;6FAEnD,c;;;;;kDACF,KAAK,WAAL,CAAiB,cAAjB,C;;;;;;;;;;;;;;;;;;;;AAIX;;;;;;;;;;;;;;;;;;;;AAoBG;;;AACH,OAAM,SAAU,UAAV,CACF,cADE,EACiC,WADjC,EAEF,UAFE,EAEwB,cAFxB,EAEuD;AAC3D,MAAI,SAAS,CAAC,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,QAAM,gBAAgB,GACjB,cAAiC,CAAC,aAAlC,IAAmD,IAAnD,IACA,cAAiC,CAAC,WAAlC,IAAiD,IAFtD;;AAGA,QAAI,gBAAJ,EAAsB;AACpB,aAAO,IAAI,iBAAJ,CAAsB,cAAtB,CAAP;AACD,KAFD,MAEO;AACL;AACA;AACA,MAAA,OAAO,CAAC,IAAR,CACI,4DACA,iDADA,GAEA,8DAFA,GAGA,qDAJJ;AAKA,aAAO,IAAI,iBAAJ,CAAsB;AAAC,QAAA,aAAa,EAAE;AAAhB,OAAtB,CAAP;AACD;AACF,GAhBD,MAgBO;AACL;AACA;AACA,IAAA,OAAO,CAAC,IAAR,CACI,4DACA,iDADA,GAEA,8DAFA,GAGA,qDAJJ;AAKA,WAAO,IAAI,iBAAJ,CAAsB;AAC3B,MAAA,aAAa,EAAE,cADY;AAE3B,MAAA,WAAW,EAAX,WAF2B;AAG3B,MAAA,UAAU,EAAV,UAH2B;AAI3B,MAAA,cAAc,EAAd;AAJ2B,KAAtB,CAAP;AAMD;AACF;AAED;;;;;;;;;;;;;;AAcG;;AACH,OAAM,SAAU,eAAV,CACF,WADE,EAEqB;AACzB,SAAO,IAAI,gBAAJ,CAAqB,WAArB,CAAP;AACD","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nclass PassthroughLoader {\r\n    constructor(modelArtifacts) {\r\n        this.modelArtifacts = modelArtifacts;\r\n    }\r\n    async load() {\r\n        return this.modelArtifacts;\r\n    }\r\n}\r\nclass PassthroughSaver {\r\n    constructor(saveHandler) {\r\n        this.saveHandler = saveHandler;\r\n    }\r\n    async save(modelArtifacts) {\r\n        return this.saveHandler(modelArtifacts);\r\n    }\r\n}\r\n/**\r\n * Creates an IOHandler that loads model artifacts from memory.\r\n *\r\n * When used in conjunction with `tf.loadLayersModel`, an instance of\r\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\r\n *\r\n * ```js\r\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\r\n *     modelTopology, weightSpecs, weightData));\r\n * ```\r\n *\r\n * @param modelArtifacts a object containing model topology (i.e., parsed from\r\n *   the JSON format).\r\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\r\n *   names, shapes, types, and quantization of the weight data.\r\n * @param weightData A single `ArrayBuffer` containing the weight data,\r\n *   concatenated in the order described by the weightSpecs.\r\n * @param trainingConfig Model training configuration. Optional.\r\n *\r\n * @returns A passthrough `IOHandler` that simply loads the provided data.\r\n */\r\nexport function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {\r\n    if (arguments.length === 1) {\r\n        const isModelArtifacts = modelArtifacts.modelTopology != null ||\r\n            modelArtifacts.weightSpecs != null;\r\n        if (isModelArtifacts) {\r\n            return new PassthroughLoader(modelArtifacts);\r\n        }\r\n        else {\r\n            // Legacy support: with only modelTopology.\r\n            // TODO(cais): Remove this deprecated API.\r\n            console.warn('Please call tf.io.fromMemory() with only one argument. ' +\r\n                'The argument should be of type ModelArtifacts. ' +\r\n                'The multi-argument signature of tf.io.fromMemory() has been ' +\r\n                'deprecated and will be removed in a future release.');\r\n            return new PassthroughLoader({ modelTopology: modelArtifacts });\r\n        }\r\n    }\r\n    else {\r\n        // Legacy support.\r\n        // TODO(cais): Remove this deprecated API.\r\n        console.warn('Please call tf.io.fromMemory() with only one argument. ' +\r\n            'The argument should be of type ModelArtifacts. ' +\r\n            'The multi-argument signature of tf.io.fromMemory() has been ' +\r\n            'deprecated and will be removed in a future release.');\r\n        return new PassthroughLoader({\r\n            modelTopology: modelArtifacts,\r\n            weightSpecs,\r\n            weightData,\r\n            trainingConfig\r\n        });\r\n    }\r\n}\r\n/**\r\n * Creates an IOHandler that passes saved model artifacts to a callback.\r\n *\r\n * ```js\r\n * function handleSave(artifacts) {\r\n *   // ... do something with the artifacts ...\r\n *   return {modelArtifactsInfo: {...}, ...};\r\n * }\r\n *\r\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\r\n * ```\r\n *\r\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\r\n *     `SaveResult`.\r\n */\r\nexport function withSaveHandler(saveHandler) {\r\n    return new PassthroughSaver(saveHandler);\r\n}\r\n//# sourceMappingURL=passthrough.js.map"]},"metadata":{},"sourceType":"module"}