{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../../engine';\nimport { CropAndResize } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { op } from '../operation';\n/**\r\n * Extracts crops from the input image tensor and resizes them using bilinear\r\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\r\n * to a common output size specified by cropSize.\r\n *\r\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\r\n *     where imageHeight and imageWidth must be positive, specifying the\r\n *     batch of images from which to take crops\r\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\r\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\r\n *     coordinates of the box in the boxInd[i]'th image in the batch\r\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\r\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\r\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\r\n *     specifying the size to which all crops are resized to.\r\n * @param method Optional string from `'bilinear' | 'nearest'`,\r\n *     defaults to bilinear, which specifies the sampling method for resizing\r\n * @param extrapolationValue A threshold for deciding when to remove boxes based\r\n *     on score. Defaults to 0.\r\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\r\n */\n\nfunction cropAndResize_(image, boxes, boxInd, cropSize, method, extrapolationValue) {\n  var $image = convertToTensor(image, 'image', 'cropAndResize');\n  var $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n  var $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n  method = method || 'bilinear';\n  extrapolationValue = extrapolationValue || 0;\n  var numBoxes = $boxes.shape[0];\n  util.assert($image.rank === 4, function () {\n    return 'Error in cropAndResize: image must be rank 4,' + \"but got rank \".concat($image.rank, \".\");\n  });\n  util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, function () {\n    return \"Error in cropAndResize: boxes must be have size [\".concat(numBoxes, \",4] \") + \"but had shape \".concat($boxes.shape, \".\");\n  });\n  util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, function () {\n    return \"Error in cropAndResize: boxInd must be have size [\".concat(numBoxes, \"] \") + \"but had shape \".concat($boxes.shape, \".\");\n  });\n  util.assert(cropSize.length === 2, function () {\n    return \"Error in cropAndResize: cropSize must be of length 2, but got \" + \"length \".concat(cropSize.length, \".\");\n  });\n  util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, function () {\n    return \"cropSize must be atleast [1,1], but was \".concat(cropSize);\n  });\n  util.assert(method === 'bilinear' || method === 'nearest', function () {\n    return \"method must be bilinear or nearest, but was \".concat(method);\n  });\n\n  var forward = function forward(backend) {\n    return backend.cropAndResize($image, $boxes, $boxInd, cropSize, method, extrapolationValue);\n  };\n\n  var inputs = {\n    image: $image,\n    boxes: $boxes,\n    boxInd: $boxInd\n  };\n  var attrs = {\n    method: method,\n    extrapolationValue: extrapolationValue,\n    cropSize: cropSize\n  };\n  var res = ENGINE.runKernelFunc(forward, inputs, null\n  /* grad */\n  , CropAndResize, attrs);\n  return res;\n}\n\nexport var cropAndResize = op({\n  cropAndResize_: cropAndResize_\n});","map":{"version":3,"sources":["../../../src/ops/image/crop_and_resize.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,QAAkC,cAAlC;AACA,SAAQ,aAAR,QAAqE,oBAArE;AAIA,SAAQ,eAAR,QAA8B,uBAA9B;AAEA,OAAO,KAAK,IAAZ,MAAsB,YAAtB;AAEA,SAAQ,EAAR,QAAiB,cAAjB;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBG;;AACH,SAAS,cAAT,CACI,KADJ,EAEI,KAFJ,EAGI,MAHJ,EAII,QAJJ,EAKI,MALJ,EAMI,kBANJ,EAM+B;AAE7B,MAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,CAA9B;AACA,MAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,EAAkC,SAAlC,CAA9B;AACA,MAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,eAAnB,EAAoC,OAApC,CAA/B;AACA,EAAA,MAAM,GAAG,MAAM,IAAI,UAAnB;AACA,EAAA,kBAAkB,GAAG,kBAAkB,IAAI,CAA3C;AAEA,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAjB;AAEA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,CADpB,EAEI;AAAA,WAAM,yEACc,MAAM,CAAC,IADrB,MAAN;AAAA,GAFJ;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,CAAhB,IAAqB,MAAM,CAAC,KAAP,CAAa,CAAb,MAAoB,CAD7C,EAEI;AAAA,WAAM,2DAAoD,QAApD,oCACe,MAAM,CAAC,KADtB,MAAN;AAAA,GAFJ;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,OAAO,CAAC,IAAR,KAAiB,CAAjB,IAAsB,OAAO,CAAC,KAAR,CAAc,CAAd,MAAqB,QAD/C,EAEI;AAAA,WAAM,4DAAqD,QAArD,kCACe,MAAM,CAAC,KADtB,MAAN;AAAA,GAFJ;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,QAAQ,CAAC,MAAT,KAAoB,CADxB,EAEI;AAAA,WAAM,oFACQ,QAAQ,CAAC,MADjB,MAAN;AAAA,GAFJ;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,QAAQ,CAAC,CAAD,CAAR,IAAe,CAAf,IAAoB,QAAQ,CAAC,CAAD,CAAR,IAAe,CADvC,EAEI;AAAA,6DAAiD,QAAjD;AAAA,GAFJ;AAGA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,KAAK,UAAX,IAAyB,MAAM,KAAK,SADxC,EAEI;AAAA,iEAAqD,MAArD;AAAA,GAFJ;;AAIA,MAAM,OAAO,GAA0B,SAAjC,OAAiC,CAAC,OAAD;AAAA,WAAa,OAAO,CAAC,aAAR,CAChD,MADgD,EACxC,MADwC,EAChC,OADgC,EACvB,QADuB,EACb,MADa,EACL,kBADK,CAAb;AAAA,GAAvC;;AAGA,MAAM,MAAM,GACc;AAAC,IAAA,KAAK,EAAE,MAAR;AAAgB,IAAA,KAAK,EAAE,MAAvB;AAA+B,IAAA,MAAM,EAAE;AAAvC,GAD1B;AAEA,MAAM,KAAK,GAAuB;AAAC,IAAA,MAAM,EAAN,MAAD;AAAS,IAAA,kBAAkB,EAAlB,kBAAT;AAA6B,IAAA,QAAQ,EAAR;AAA7B,GAAlC;AACA,MAAM,GAAG,GAAG,MAAM,CAAC,aAAP,CACR,OADQ,EACC,MADD,EACiC;AAAK;AADtC,IACkD,aADlD,EAER,KAFQ,CAAZ;AAGA,SAAO,GAAP;AACD;;AAED,OAAO,IAAM,aAAa,GAAG,EAAE,CAAC;AAAC,EAAA,cAAc,EAAd;AAAD,CAAD,CAAxB","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../../engine';\r\nimport { CropAndResize } from '../../kernel_names';\r\nimport { convertToTensor } from '../../tensor_util_env';\r\nimport * as util from '../../util';\r\nimport { op } from '../operation';\r\n/**\r\n * Extracts crops from the input image tensor and resizes them using bilinear\r\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\r\n * to a common output size specified by cropSize.\r\n *\r\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\r\n *     where imageHeight and imageWidth must be positive, specifying the\r\n *     batch of images from which to take crops\r\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\r\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\r\n *     coordinates of the box in the boxInd[i]'th image in the batch\r\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\r\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\r\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\r\n *     specifying the size to which all crops are resized to.\r\n * @param method Optional string from `'bilinear' | 'nearest'`,\r\n *     defaults to bilinear, which specifies the sampling method for resizing\r\n * @param extrapolationValue A threshold for deciding when to remove boxes based\r\n *     on score. Defaults to 0.\r\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\r\n */\r\nfunction cropAndResize_(image, boxes, boxInd, cropSize, method, extrapolationValue) {\r\n    const $image = convertToTensor(image, 'image', 'cropAndResize');\r\n    const $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\r\n    const $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\r\n    method = method || 'bilinear';\r\n    extrapolationValue = extrapolationValue || 0;\r\n    const numBoxes = $boxes.shape[0];\r\n    util.assert($image.rank === 4, () => 'Error in cropAndResize: image must be rank 4,' +\r\n        `but got rank ${$image.rank}.`);\r\n    util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` +\r\n        `but had shape ${$boxes.shape}.`);\r\n    util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` +\r\n        `but had shape ${$boxes.shape}.`);\r\n    util.assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got ` +\r\n        `length ${cropSize.length}.`);\r\n    util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);\r\n    util.assert(method === 'bilinear' || method === 'nearest', () => `method must be bilinear or nearest, but was ${method}`);\r\n    const forward = (backend) => backend.cropAndResize($image, $boxes, $boxInd, cropSize, method, extrapolationValue);\r\n    const inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };\r\n    const attrs = { method, extrapolationValue, cropSize };\r\n    const res = ENGINE.runKernelFunc(forward, inputs, null /* grad */, CropAndResize, attrs);\r\n    return res;\r\n}\r\nexport const cropAndResize = op({ cropAndResize_ });\r\n//# sourceMappingURL=crop_and_resize.js.map"]},"metadata":{},"sourceType":"module"}