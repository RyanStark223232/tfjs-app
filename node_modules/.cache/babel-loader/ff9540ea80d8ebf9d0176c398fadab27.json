{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nexport class SegmentOpProgram {\n  constructor(segOpInfo, segOpType) {\n    this.variableNames = ['x', 'segmentIds'];\n    const windowSize = segOpInfo.windowSize;\n    const batchSize = segOpInfo.batchSize;\n    const inSize = segOpInfo.inSize;\n    const numSegments = segOpInfo.numSegments;\n    const outSize = numSegments * Math.ceil(inSize / windowSize);\n    this.outputShape = [batchSize, outSize];\n    const initializationValue = '0.0';\n    const returnValue = `sumValue`;\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n    const updateSnippet = `\n        sumValue += dot(values, segFilter);\n    `;\n    let checkValueOutOfBounds = '';\n\n    if (inSize % windowSize > 0) {\n      checkValueOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n\n    let checkSegmentIdOutOfBounds = '';\n\n    if (inSize % windowSize > 0) {\n      checkSegmentIdOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return -1.0;\n        }\n      `;\n    }\n\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n\n      float getValue(int batch, int inIdx) {\n        ${checkValueOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${checkSegmentIdOutOfBounds}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${numSegments})) * float(${windowSize}));\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n\n}","map":{"version":3,"sources":["../src/segment_gpu.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAKH,OAAM,MAAO,gBAAP,CAAuB;AAK3B,EAAA,WAAA,CACI,SADJ,EAEI,SAFJ,EAEmC;AANnC,SAAA,aAAA,GAAgB,CAAC,GAAD,EAAM,YAAN,CAAhB;AAOE,UAAM,UAAU,GAAG,SAAS,CAAC,UAA7B;AACA,UAAM,SAAS,GAAG,SAAS,CAAC,SAA5B;AACA,UAAM,MAAM,GAAG,SAAS,CAAC,MAAzB;AACA,UAAM,WAAW,GAAG,SAAS,CAAC,WAA9B;AACA,UAAM,OAAO,GAAG,WAAW,GAAG,IAAI,CAAC,IAAL,CAAU,MAAM,GAAG,UAAnB,CAA9B;AACA,SAAK,WAAL,GAAmB,CAAC,SAAD,EAAY,OAAZ,CAAnB;AAEA,UAAM,mBAAmB,GAAG,KAA5B;AACA,UAAM,WAAW,GAAG,UAApB;AAEA,UAAM,qBAAqB,GAAG,IAAI,CAAC,KAAL,CAAW,UAAU,GAAG,CAAxB,IAA6B,CAA3D;AACA,UAAM,uBAAuB,GAAG,UAAU,GAAG,CAA7C;AAEA,UAAM,aAAa,GAAG;;AAErB,KAFD;AAIA,QAAI,qBAAqB,GAAG,EAA5B;;AACA,QAAI,MAAM,GAAG,UAAT,GAAsB,CAA1B,EAA6B;AAC3B,MAAA,qBAAqB,GAAG;oCACM,MAAM;;;AAGnC,OAJD;AAKD;;AAED,QAAI,yBAAyB,GAAG,EAAhC;;AACA,QAAI,MAAM,GAAG,UAAT,GAAsB,CAA1B,EAA6B;AAC3B,MAAA,yBAAyB,GAAG;oCACE,MAAM;;;AAGnC,OAJD;AAKD;;AAED,SAAK,QAAL,GAAgB;0CACsB,mBAAmB;;;UAGnD,qBAAqB;;;;;UAKrB,yBAAyB;;;;;;;;;YASvB,WAAW,cAAc,UAAU;wDACS,WAAW;;;;8BAIrC,qBAAqB;;;;;;;;;;;;;;;;YAgBvC,aAAa;;;iCAGQ,qBAAqB;cACxC,uBAAuB,KAAK,CAAC;;;;;;;;;;;;;;;;;YAiB/B,aAAa;qBACJ,uBAAuB,KAAK,CAAC;;;;;;;;;;;;;;;YAetC,aAAa;qBACJ,uBAAuB,KAAK,CAAC;;;;;;;;;;;;;;;YAetC,aAAa;;oBAEL,WAAW;;AAE1B,KAhGD;AAiGD;;AA5I0B","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nexport class SegmentOpProgram {\r\n    constructor(segOpInfo, segOpType) {\r\n        this.variableNames = ['x', 'segmentIds'];\r\n        const windowSize = segOpInfo.windowSize;\r\n        const batchSize = segOpInfo.batchSize;\r\n        const inSize = segOpInfo.inSize;\r\n        const numSegments = segOpInfo.numSegments;\r\n        const outSize = numSegments * Math.ceil(inSize / windowSize);\r\n        this.outputShape = [batchSize, outSize];\r\n        const initializationValue = '0.0';\r\n        const returnValue = `sumValue`;\r\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\r\n        const windowSizeVec4Remainder = windowSize % 4;\r\n        const updateSnippet = `\r\n        sumValue += dot(values, segFilter);\r\n    `;\r\n        let checkValueOutOfBounds = '';\r\n        if (inSize % windowSize > 0) {\r\n            checkValueOutOfBounds = `\r\n        if (inIdx < 0 || inIdx >= ${inSize}) {\r\n          return initializationValue;\r\n        }\r\n      `;\r\n        }\r\n        let checkSegmentIdOutOfBounds = '';\r\n        if (inSize % windowSize > 0) {\r\n            checkSegmentIdOutOfBounds = `\r\n        if (inIdx < 0 || inIdx >= ${inSize}) {\r\n          return -1.0;\r\n        }\r\n      `;\r\n        }\r\n        this.userCode = `\r\n      const float initializationValue = ${initializationValue};\r\n\r\n      float getValue(int batch, int inIdx) {\r\n        ${checkValueOutOfBounds}\r\n        return getX(batch, inIdx);\r\n      }\r\n\r\n      float getSegmentIdAtIndex(int inIdx) {\r\n        ${checkSegmentIdOutOfBounds}\r\n        return getSegmentIds(inIdx);\r\n      }\r\n\r\n      void main() {\r\n        ivec2 coords = getOutputCoords();\r\n        int batch = coords[0];\r\n        int outIdx = coords[1];\r\n        int inOffset = int(floor(float(outIdx) / float(\r\n          ${numSegments})) * float(${windowSize}));\r\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\r\n\r\n        float sumValue = 0.0;\r\n\r\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\r\n          int inIdx = inOffset + i;\r\n          vec4 values = vec4(\r\n            getValue(batch, inIdx),\r\n            getValue(batch, inIdx + 1),\r\n            getValue(batch, inIdx + 2),\r\n            getValue(batch, inIdx + 3)\r\n          );\r\n\r\n          vec4 segFilter = vec4(\r\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\r\n          );\r\n\r\n          ${updateSnippet}\r\n        }\r\n\r\n        int inIdx = inOffset + ${windowSizeNearestVec4};\r\n        if (${windowSizeVec4Remainder === 1}) {\r\n          vec4 values = vec4(\r\n            getValue(batch, inIdx),\r\n            initializationValue,\r\n            initializationValue,\r\n            initializationValue\r\n          );\r\n\r\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\r\n\r\n          vec4 segFilter = vec4(\r\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\r\n            0,\r\n            0,\r\n            0\r\n          );\r\n\r\n          ${updateSnippet}\r\n        } else if (${windowSizeVec4Remainder === 2}) {\r\n          vec4 values = vec4(\r\n            getValue(batch, inIdx),\r\n            getValue(batch, inIdx + 1),\r\n            initializationValue,\r\n            initializationValue\r\n          );\r\n\r\n          vec4 segFilter = vec4(\r\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\r\n              0,\r\n              0\r\n          );\r\n\r\n          ${updateSnippet}\r\n        } else if (${windowSizeVec4Remainder === 3}) {\r\n          vec4 values = vec4(\r\n            getValue(batch, inIdx),\r\n            getValue(batch, inIdx + 1),\r\n            getValue(batch, inIdx + 2),\r\n            initializationValue\r\n          );\r\n\r\n          vec4 segFilter = vec4(\r\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\r\n            0\r\n          );\r\n\r\n          ${updateSnippet}\r\n        }\r\n        setOutput(${returnValue});\r\n      }\r\n    `;\r\n    }\r\n}\r\n//# sourceMappingURL=segment_gpu.js.map"]},"metadata":{},"sourceType":"module"}