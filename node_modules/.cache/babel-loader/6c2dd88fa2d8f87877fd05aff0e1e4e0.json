{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { concat } from '../concat';\nimport { fill } from '../fill';\nimport { op } from '../operation';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { tensor2d } from '../tensor2d';\n/**\r\n * Expands input into frames of frameLength.\r\n * Slides a window size with frameStep.\r\n *\r\n * ```js\r\n * tf.signal.frame([1, 2, 3], 2, 1).print();\r\n * ```\r\n * @param signal The input tensor to be expanded\r\n * @param frameLength Length of each frame\r\n * @param frameStep The frame hop size in samples.\r\n * @param padEnd Whether to pad the end of signal with padValue.\r\n * @param padValue An number to use where the input signal does\r\n *     not exist when padEnd is True.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\r\n */\n\nfunction frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {\n  let start = 0;\n  const output = [];\n\n  while (start + frameLength <= signal.size) {\n    output.push(slice(signal, start, frameLength));\n    start += frameStep;\n  }\n\n  if (padEnd) {\n    while (start < signal.size) {\n      const padLen = start + frameLength - signal.size;\n      const pad = concat([slice(signal, start, frameLength - padLen), fill([padLen], padValue)]);\n      output.push(pad);\n      start += frameStep;\n    }\n  }\n\n  if (output.length === 0) {\n    return tensor2d([], [0, frameLength]);\n  }\n\n  return reshape(concat(output), [output.length, frameLength]);\n}\n\nexport const frame = op({\n  frame_\n});","map":{"version":3,"sources":["../../../src/ops/signal/frame.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAGH,SAAQ,MAAR,QAAqB,WAArB;AACA,SAAQ,IAAR,QAAmB,SAAnB;AACA,SAAQ,EAAR,QAAiB,cAAjB;AACA,SAAQ,OAAR,QAAsB,YAAtB;AACA,SAAQ,KAAR,QAAoB,UAApB;AACA,SAAQ,QAAR,QAAuB,aAAvB;AAEA;;;;;;;;;;;;;;;AAeG;;AACH,SAAS,MAAT,CACI,MADJ,EACsB,WADtB,EAC2C,SAD3C,EAC8D,MAAM,GAAG,KADvE,EAEI,QAAQ,GAAG,CAFf,EAEgB;AACd,MAAI,KAAK,GAAG,CAAZ;AACA,QAAM,MAAM,GAAa,EAAzB;;AACA,SAAO,KAAK,GAAG,WAAR,IAAuB,MAAM,CAAC,IAArC,EAA2C;AACzC,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,MAAD,EAAS,KAAT,EAAgB,WAAhB,CAAjB;AACA,IAAA,KAAK,IAAI,SAAT;AACD;;AAED,MAAI,MAAJ,EAAY;AACV,WAAO,KAAK,GAAG,MAAM,CAAC,IAAtB,EAA4B;AAC1B,YAAM,MAAM,GAAI,KAAK,GAAG,WAAT,GAAwB,MAAM,CAAC,IAA9C;AACA,YAAM,GAAG,GAAG,MAAM,CAAC,CACjB,KAAK,CAAC,MAAD,EAAS,KAAT,EAAgB,WAAW,GAAG,MAA9B,CADY,EAC2B,IAAI,CAAC,CAAC,MAAD,CAAD,EAAW,QAAX,CAD/B,CAAD,CAAlB;AAGA,MAAA,MAAM,CAAC,IAAP,CAAY,GAAZ;AACA,MAAA,KAAK,IAAI,SAAT;AACD;AACF;;AAED,MAAI,MAAM,CAAC,MAAP,KAAkB,CAAtB,EAAyB;AACvB,WAAO,QAAQ,CAAC,EAAD,EAAK,CAAC,CAAD,EAAI,WAAJ,CAAL,CAAf;AACD;;AAED,SAAO,OAAO,CAAC,MAAM,CAAC,MAAD,CAAP,EAAiB,CAAC,MAAM,CAAC,MAAR,EAAgB,WAAhB,CAAjB,CAAd;AACD;;AACD,OAAO,MAAM,KAAK,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAhB","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { concat } from '../concat';\r\nimport { fill } from '../fill';\r\nimport { op } from '../operation';\r\nimport { reshape } from '../reshape';\r\nimport { slice } from '../slice';\r\nimport { tensor2d } from '../tensor2d';\r\n/**\r\n * Expands input into frames of frameLength.\r\n * Slides a window size with frameStep.\r\n *\r\n * ```js\r\n * tf.signal.frame([1, 2, 3], 2, 1).print();\r\n * ```\r\n * @param signal The input tensor to be expanded\r\n * @param frameLength Length of each frame\r\n * @param frameStep The frame hop size in samples.\r\n * @param padEnd Whether to pad the end of signal with padValue.\r\n * @param padValue An number to use where the input signal does\r\n *     not exist when padEnd is True.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\r\n */\r\nfunction frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {\r\n    let start = 0;\r\n    const output = [];\r\n    while (start + frameLength <= signal.size) {\r\n        output.push(slice(signal, start, frameLength));\r\n        start += frameStep;\r\n    }\r\n    if (padEnd) {\r\n        while (start < signal.size) {\r\n            const padLen = (start + frameLength) - signal.size;\r\n            const pad = concat([\r\n                slice(signal, start, frameLength - padLen), fill([padLen], padValue)\r\n            ]);\r\n            output.push(pad);\r\n            start += frameStep;\r\n        }\r\n    }\r\n    if (output.length === 0) {\r\n        return tensor2d([], [0, frameLength]);\r\n    }\r\n    return reshape(concat(output), [output.length, frameLength]);\r\n}\r\nexport const frame = op({ frame_ });\r\n//# sourceMappingURL=frame.js.map"]},"metadata":{},"sourceType":"module"}