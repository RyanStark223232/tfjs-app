{"ast":null,"code":"import _slicedToArray from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport var executeOp = function executeOp(node, tensorMap, context) {\n  switch (node.op) {\n    case 'BatchMatMul':\n    case 'BatchMatMulV2':\n    case 'MatMul':\n      return [tfOps.matMul(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context), getParamValue('transposeA', node, tensorMap, context), getParamValue('transposeB', node, tensorMap, context))];\n\n    case 'Transpose':\n      return [tfOps.transpose(getParamValue('x', node, tensorMap, context), getParamValue('perm', node, tensorMap, context))];\n\n    case '_FusedMatMul':\n      var _getParamValue = getParamValue('fusedOps', node, tensorMap, context),\n          _getParamValue2 = _slicedToArray(_getParamValue, 2),\n          extraOp = _getParamValue2[0],\n          activationFunc = _getParamValue2[1];\n\n      var isBiasAdd = extraOp === 'biasadd';\n      var isPrelu = activationFunc === 'prelu';\n      var numArgs = getParamValue('numArgs', node, tensorMap, context);\n\n      if (isBiasAdd) {\n        if (isPrelu && numArgs !== 2) {\n          throw new Error('Fused MatMul with BiasAdd and Prelu must have two ' + 'extra arguments: bias and alpha.');\n        }\n\n        if (!isPrelu && numArgs !== 1) {\n          throw new Error('Fused MatMul with BiasAdd must have one extra argument: bias.');\n        }\n      }\n\n      var _getParamValue3 = getParamValue('args', node, tensorMap, context),\n          _getParamValue4 = _slicedToArray(_getParamValue3, 2),\n          biasArg = _getParamValue4[0],\n          preluArg = _getParamValue4[1];\n\n      return [tfOps.fused.matMul({\n        a: getParamValue('a', node, tensorMap, context),\n        b: getParamValue('b', node, tensorMap, context),\n        transposeA: getParamValue('transposeA', node, tensorMap, context),\n        transposeB: getParamValue('transposeB', node, tensorMap, context),\n        bias: biasArg,\n        activation: activationFunc,\n        preluActivationWeights: preluArg\n      })];\n\n    default:\n      throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n  }\n};\nexport var CATEGORY = 'matrices';","map":{"version":3,"sources":["../../../src/operations/executors/matrices_executor.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;AAeG;AAGH;AACA,OAAO,KAAK,KAAZ,MAAuB,kDAAvB;AAMA,SAAQ,aAAR,QAA4B,SAA5B;AAEA,OAAO,IAAM,SAAS,GAClB,SADS,SACT,CAAC,IAAD,EAAa,SAAb,EACC,OADD,EACwC;AACtC,UAAQ,IAAI,CAAC,EAAb;AACE,SAAK,aAAL;AACA,SAAK,eAAL;AACA,SAAK,QAAL;AACE,aAAO,CAAC,KAAK,CAAC,MAAN,CACJ,aAAa,CAAC,GAAD,EAAM,IAAN,EAAY,SAAZ,EAAuB,OAAvB,CADT,EAEJ,aAAa,CAAC,GAAD,EAAM,IAAN,EAAY,SAAZ,EAAuB,OAAvB,CAFT,EAGJ,aAAa,CAAC,YAAD,EAAe,IAAf,EAAqB,SAArB,EAAgC,OAAhC,CAHT,EAIJ,aAAa,CAAC,YAAD,EAAe,IAAf,EAAqB,SAArB,EAAgC,OAAhC,CAJT,CAAD,CAAP;;AAOF,SAAK,WAAL;AACE,aAAO,CAAC,KAAK,CAAC,SAAN,CACJ,aAAa,CAAC,GAAD,EAAM,IAAN,EAAY,SAAZ,EAAuB,OAAvB,CADT,EAEJ,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAFT,CAAD,CAAP;;AAIF,SAAK,cAAL;AAAA,2BAEO,aAAa,CAAC,UAAD,EAAa,IAAb,EAAmB,SAAnB,EAA8B,OAA9B,CAFpB;AAAA;AAAA,UACS,OADT;AAAA,UACkB,cADlB;;AAIE,UAAM,SAAS,GAAG,OAAO,KAAK,SAA9B;AACA,UAAM,OAAO,GAAG,cAAc,KAAK,OAAnC;AAEA,UAAM,OAAO,GACR,aAAa,CAAC,SAAD,EAAY,IAAZ,EAAkB,SAAlB,EAA6B,OAA7B,CADlB;;AAEA,UAAI,SAAJ,EAAe;AACb,YAAI,OAAO,IAAI,OAAO,KAAK,CAA3B,EAA8B;AAC5B,gBAAM,IAAI,KAAJ,CACF,uDACA,kCAFE,CAAN;AAGD;;AACD,YAAI,CAAC,OAAD,IAAY,OAAO,KAAK,CAA5B,EAA+B;AAC7B,gBAAM,IAAI,KAAJ,CACF,+DADE,CAAN;AAED;AACF;;AAnBH,4BAqBM,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CArBnB;AAAA;AAAA,UAoBS,OApBT;AAAA,UAoBkB,QApBlB;;AAsBE,aAAO,CAAC,KAAK,CAAC,KAAN,CAAY,MAAZ,CAAmB;AACzB,QAAA,CAAC,EAAE,aAAa,CAAC,GAAD,EAAM,IAAN,EAAY,SAAZ,EAAuB,OAAvB,CADS;AAEzB,QAAA,CAAC,EAAE,aAAa,CAAC,GAAD,EAAM,IAAN,EAAY,SAAZ,EAAuB,OAAvB,CAFS;AAGzB,QAAA,UAAU,EAAE,aAAa,CAAC,YAAD,EAAe,IAAf,EAAqB,SAArB,EAAgC,OAAhC,CAHA;AAKzB,QAAA,UAAU,EAAE,aAAa,CAAC,YAAD,EAAe,IAAf,EAAqB,SAArB,EAAgC,OAAhC,CALA;AAOzB,QAAA,IAAI,EAAE,OAPmB;AAQzB,QAAA,UAAU,EAAE,cARa;AASzB,QAAA,sBAAsB,EAAE;AATC,OAAnB,CAAD,CAAP;;AAYF;AACE,YAAM,SAAS,qBAAc,IAAI,CAAC,EAAnB,yBAAf;AAnDJ;AAqDD,CAxDE;AA0DP,OAAO,IAAM,QAAQ,GAAG,UAAjB","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n// tslint:disable-next-line: no-imports-from-dist\r\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\r\nimport { getParamValue } from './utils';\r\nexport const executeOp = (node, tensorMap, context) => {\r\n    switch (node.op) {\r\n        case 'BatchMatMul':\r\n        case 'BatchMatMulV2':\r\n        case 'MatMul':\r\n            return [tfOps.matMul(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context), getParamValue('transposeA', node, tensorMap, context), getParamValue('transposeB', node, tensorMap, context))];\r\n        case 'Transpose':\r\n            return [tfOps.transpose(getParamValue('x', node, tensorMap, context), getParamValue('perm', node, tensorMap, context))];\r\n        case '_FusedMatMul':\r\n            const [extraOp, activationFunc] = getParamValue('fusedOps', node, tensorMap, context);\r\n            const isBiasAdd = extraOp === 'biasadd';\r\n            const isPrelu = activationFunc === 'prelu';\r\n            const numArgs = getParamValue('numArgs', node, tensorMap, context);\r\n            if (isBiasAdd) {\r\n                if (isPrelu && numArgs !== 2) {\r\n                    throw new Error('Fused MatMul with BiasAdd and Prelu must have two ' +\r\n                        'extra arguments: bias and alpha.');\r\n                }\r\n                if (!isPrelu && numArgs !== 1) {\r\n                    throw new Error('Fused MatMul with BiasAdd must have one extra argument: bias.');\r\n                }\r\n            }\r\n            const [biasArg, preluArg] = getParamValue('args', node, tensorMap, context);\r\n            return [tfOps.fused.matMul({\r\n                    a: getParamValue('a', node, tensorMap, context),\r\n                    b: getParamValue('b', node, tensorMap, context),\r\n                    transposeA: getParamValue('transposeA', node, tensorMap, context),\r\n                    transposeB: getParamValue('transposeB', node, tensorMap, context),\r\n                    bias: biasArg,\r\n                    activation: activationFunc,\r\n                    preluActivationWeights: preluArg\r\n                })];\r\n        default:\r\n            throw TypeError(`Node type ${node.op} is not implemented`);\r\n    }\r\n};\r\nexport const CATEGORY = 'matrices';\r\n//# sourceMappingURL=matrices_executor.js.map"]},"metadata":{},"sourceType":"module"}