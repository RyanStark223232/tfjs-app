{"ast":null,"code":"import { env } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\nexport const CHECK_NAN_SNIPPET_BINARY = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n/**\r\n * Template that creates a `KernelFunc` for unary ops.\r\n * @param opSnippets Op snippet to create `UnaryOpProgram`.\r\n */\n\nexport function unaryKernelFunc(opSnippet) {\n  return ({\n    inputs,\n    backend\n  }) => {\n    const {\n      x\n    } = inputs;\n    const webglBackend = backend;\n    const program = new UnaryOpProgram(x.shape, opSnippet);\n    return webglBackend.runWebGLProgram(program, [x], x.dtype);\n  };\n}\n/**\r\n * Template that creates a `KernelFunc` for binary ops.\r\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\r\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\r\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\r\n *     when creating BinaryOpPackedProgram.\r\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\r\n *     result has the same dtype as the first input. This is mainly used in\r\n *     comparison kernels, such as Equal, Less, Greater, etc.\r\n */\n\nexport function binaryKernelFunc(opSnippet, packedOpSnippet, checkOutOfBoundsForPackedProgram, dtype) {\n  // TODO(jingjin): handle complex64.\n  return ({\n    inputs,\n    backend\n  }) => {\n    const {\n      a,\n      b\n    } = inputs;\n    const webglBackend = backend;\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ? new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, !!checkOutOfBoundsForPackedProgram) : new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    const $dtype = dtype || a.dtype;\n    const output = webglBackend.runWebGLProgram(program, [a, b], $dtype);\n    return output;\n  };\n}","map":{"version":3,"sources":["../../src/kernel_utils/kernel_funcs_utils.ts"],"names":[],"mappings":"AAAA,SAAgC,GAAhC,QAAmE,uBAAnE;AAGA,SAAQ,eAAR,QAA8B,iBAA9B;AACA,SAAQ,qBAAR,QAAoC,wBAApC;AACA,SAAQ,cAAR,QAA6B,gBAA7B;AAEA,OAAO,MAAM,uBAAuB,GAAG,yBAAhC;AAEP,OAAO,MAAM,wBAAwB,GAAG;;;AAGvC,CAHM;AAKP,OAAO,MAAM,+BAA+B,GAAG;;;;;AAK9C,CALM;AAOP;;;AAGG;;AACH,OAAM,SAAU,eAAV,CAA0B,SAA1B,EAA2C;AAC/C,SAAO,CAAC;AAAC,IAAA,MAAD;AAAS,IAAA;AAAT,GAAD,KAAsB;AAC3B,UAAM;AAAC,MAAA;AAAD,QAAM,MAAZ;AACA,UAAM,YAAY,GAAG,OAArB;AACA,UAAM,OAAO,GAAG,IAAI,cAAJ,CAAmB,CAAC,CAAC,KAArB,EAA4B,SAA5B,CAAhB;AACA,WAAO,YAAY,CAAC,eAAb,CAA6B,OAA7B,EAAsC,CAAC,CAAD,CAAtC,EAA2C,CAAC,CAAC,KAA7C,CAAP;AACD,GALD;AAMD;AAED;;;;;;;;;AASG;;AACH,OAAM,SAAU,gBAAV,CACF,SADE,EACiB,eADjB,EAEF,gCAFE,EAE0C,KAF1C,EAE0D;AAC9D;AAEA,SAAO,CAAC;AAAC,IAAA,MAAD;AAAS,IAAA;AAAT,GAAD,KAAsB;AAC3B,UAAM;AAAC,MAAA,CAAD;AAAI,MAAA;AAAJ,QAAS,MAAf;AACA,UAAM,YAAY,GAAG,OAArB;AACA,UAAM,OAAO,GAAG,GAAG,GAAG,OAAN,CAAc,8BAAd,IACZ,IAAI,qBAAJ,CACI,eADJ,EACqB,CAAC,CAAC,KADvB,EAC8B,CAAC,CAAC,KADhC,EAEI,CAAC,CAAC,gCAFN,CADY,GAIZ,IAAI,eAAJ,CAAoB,SAApB,EAA+B,CAAC,CAAC,KAAjC,EAAwC,CAAC,CAAC,KAA1C,CAJJ;AAKA,UAAM,MAAM,GAAG,KAAK,IAAI,CAAC,CAAC,KAA1B;AACA,UAAM,MAAM,GAAG,YAAY,CAAC,eAAb,CAA6B,OAA7B,EAAsC,CAAC,CAAD,EAAI,CAAJ,CAAtC,EAA8C,MAA9C,CAAf;AACA,WAAO,MAAP;AACD,GAXD;AAYD","sourceRoot":"","sourcesContent":["import { env } from '@tensorflow/tfjs-core';\r\nimport { BinaryOpProgram } from '../binaryop_gpu';\r\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\r\nimport { UnaryOpProgram } from '../unaryop_gpu';\r\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\r\nexport const CHECK_NAN_SNIPPET_BINARY = `\r\n  if (isnan(a)) return a;\r\n  if (isnan(b)) return b;\r\n`;\r\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\r\n  result.r = isNaN.r > 0. ? NAN : result.r;\r\n  result.g = isNaN.g > 0. ? NAN : result.g;\r\n  result.b = isNaN.b > 0. ? NAN : result.b;\r\n  result.a = isNaN.a > 0. ? NAN : result.a;\r\n`;\r\n/**\r\n * Template that creates a `KernelFunc` for unary ops.\r\n * @param opSnippets Op snippet to create `UnaryOpProgram`.\r\n */\r\nexport function unaryKernelFunc(opSnippet) {\r\n    return ({ inputs, backend }) => {\r\n        const { x } = inputs;\r\n        const webglBackend = backend;\r\n        const program = new UnaryOpProgram(x.shape, opSnippet);\r\n        return webglBackend.runWebGLProgram(program, [x], x.dtype);\r\n    };\r\n}\r\n/**\r\n * Template that creates a `KernelFunc` for binary ops.\r\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\r\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\r\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\r\n *     when creating BinaryOpPackedProgram.\r\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\r\n *     result has the same dtype as the first input. This is mainly used in\r\n *     comparison kernels, such as Equal, Less, Greater, etc.\r\n */\r\nexport function binaryKernelFunc(opSnippet, packedOpSnippet, checkOutOfBoundsForPackedProgram, dtype) {\r\n    // TODO(jingjin): handle complex64.\r\n    return ({ inputs, backend }) => {\r\n        const { a, b } = inputs;\r\n        const webglBackend = backend;\r\n        const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\r\n            new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, !!checkOutOfBoundsForPackedProgram) :\r\n            new BinaryOpProgram(opSnippet, a.shape, b.shape);\r\n        const $dtype = dtype || a.dtype;\r\n        const output = webglBackend.runWebGLProgram(program, [a, b], $dtype);\r\n        return output;\r\n    };\r\n}\r\n//# sourceMappingURL=kernel_funcs_utils.js.map"]},"metadata":{},"sourceType":"module"}