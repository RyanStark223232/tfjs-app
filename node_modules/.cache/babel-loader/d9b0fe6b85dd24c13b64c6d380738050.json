{"ast":null,"code":"import _toConsumableArray from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { computeStrides, sizeFromShape } from '../util';\n/**\r\n * Check whether updates.shape = indices.shape[:batchDim] +\r\n * shape[sliceDim:]\r\n *\r\n * @param x The input tensor.\r\n */\n\nexport function validateUpdateShape(shape, indices, updates) {\n  var sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;\n  var batchDim = indices.rank > 1 ? indices.rank - 1 : 1;\n  var shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' + \"shape[sliceDim:], got updates.shape: \".concat(updates.shape) + \", indices.shape: \".concat(indices.shape, \", shape: \").concat(shape) + \", sliceDim: \".concat(sliceDim, \", and batchDim: \").concat(batchDim, \".\");\n\n  if (updates.rank < batchDim) {\n    throw new Error(shapeError + \" update.rank < \".concat(batchDim, \". \"));\n  }\n\n  if (shape.length < sliceDim + (updates.rank - batchDim)) {\n    throw new Error(shapeError + \" Output shape length < \".concat(sliceDim + (updates.rank - batchDim)));\n  }\n\n  if (updates.rank !== batchDim + shape.length - sliceDim) {\n    throw new Error(shapeError + \" update.rank != \".concat(batchDim + shape.length - sliceDim));\n  }\n\n  for (var d = 0; d < batchDim; ++d) {\n    if (updates.shape[d] !== indices.shape[d]) {\n      throw new Error(shapeError + \" updates.shape[\".concat(d, \"] (\").concat(updates.shape[d], \") != indices.shape[\").concat(d, \"] (\").concat(indices.shape[d], \").\"));\n    }\n  }\n\n  for (var _d = 0; _d < updates.rank - batchDim; ++_d) {\n    if (updates.shape[_d + batchDim] !== shape[_d + sliceDim]) {\n      throw new Error(shapeError + \" updates.shape[\".concat(_d + batchDim, \"] (\").concat(updates.shape[_d + batchDim], \") != shape[\").concat(_d + batchDim, \"] (\").concat(shape[_d + batchDim], \")\"));\n    }\n  }\n}\n/**\r\n * Validate scatter nd inputs.\r\n *\r\n * @param update The tensor contains the update values.\r\n * @param indices The tensor contains the indices for the update values.\r\n * @param shape The shape of the output tensor.\r\n */\n\nexport function validateInput(updates, indices, shape) {\n  if (indices.rank < 1) {\n    throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' + \" but the rank was \".concat(indices.rank, \".\"));\n  }\n\n  if (updates.rank < 1) {\n    throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' + \" but the rank was \".concat(updates.rank, \".\"));\n  }\n\n  if (indices.dtype !== 'int32') {\n    throw new Error(\"The dtype of 'indices' should be int32, but got dtype: \".concat(indices.dtype));\n  }\n\n  if (shape.length < 1) {\n    throw new Error(\"Output rank must be greater or equal to 1, but got shape: \".concat(shape));\n  }\n\n  if (shape.length === 0) {\n    if (indices.size === 0) {\n      throw new Error(\"Indices specified for empty output. indices shape: \".concat(indices.shape));\n    }\n\n    if (updates.size === 0) {\n      throw new Error(\"Updates specified for empty output. updates shape: \".concat(updates.shape));\n    }\n  }\n\n  validateUpdateShape(shape, indices, updates);\n}\n/**\r\n * Calculate the shape information for the output.\r\n *\r\n * @param update The tensor contains the update values.\r\n * @param indices The tensor contains the indices for the update values.\r\n * @param shape The shape of the output tensor.\r\n *\r\n * @returns ScatterShapeInfo\r\n */\n\nexport function calculateShapes(updates, indices, shape) {\n  // Calculate the number of dimensions in indices\n  var indicesRank = indices.shape.length;\n  var sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1; // Calculate the number of elements that make up each slice of our updated\n  // tensor. This allows us to work with flattened tensors and copy over whole\n  // slices at a time.\n\n  var totalNd = shape.length;\n  var sliceSize = 1;\n\n  for (var i = sliceRank; i < totalNd; ++i) {\n    sliceSize *= shape[i];\n  }\n\n  var safeSliceDim = sliceRank < 1 ? 1 : sliceRank;\n  var numUpdates = sizeFromShape(indices.shape) / safeSliceDim;\n  var strides = [].concat(_toConsumableArray(computeStrides(shape.slice(0, sliceRank))), [1]);\n  var outputSize = sizeFromShape(shape);\n  return {\n    sliceRank: sliceRank,\n    numUpdates: numUpdates,\n    sliceSize: sliceSize,\n    strides: strides,\n    outputSize: outputSize\n  };\n}","map":{"version":3,"sources":["../../src/ops/scatter_nd_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { computeStrides, sizeFromShape } from '../util';\r\n/**\r\n * Check whether updates.shape = indices.shape[:batchDim] +\r\n * shape[sliceDim:]\r\n *\r\n * @param x The input tensor.\r\n */\r\nexport function validateUpdateShape(shape, indices, updates) {\r\n    const sliceDim = (indices.rank > 1) ? indices.shape[indices.rank - 1] : 1;\r\n    const batchDim = (indices.rank > 1) ? indices.rank - 1 : 1;\r\n    const shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' +\r\n        `shape[sliceDim:], got updates.shape: ${updates.shape}` +\r\n        `, indices.shape: ${indices.shape}, shape: ${shape}` +\r\n        `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;\r\n    if (updates.rank < batchDim) {\r\n        throw new Error(shapeError + ` update.rank < ${batchDim}. `);\r\n    }\r\n    if (shape.length < sliceDim + (updates.rank - batchDim)) {\r\n        throw new Error(shapeError +\r\n            ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);\r\n    }\r\n    if (updates.rank !== batchDim + shape.length - sliceDim) {\r\n        throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);\r\n    }\r\n    for (let d = 0; d < batchDim; ++d) {\r\n        if (updates.shape[d] !== indices.shape[d]) {\r\n            throw new Error(shapeError +\r\n                ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);\r\n        }\r\n    }\r\n    for (let d = 0; d < updates.rank - batchDim; ++d) {\r\n        if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {\r\n            throw new Error(shapeError +\r\n                ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Validate scatter nd inputs.\r\n *\r\n * @param update The tensor contains the update values.\r\n * @param indices The tensor contains the indices for the update values.\r\n * @param shape The shape of the output tensor.\r\n */\r\nexport function validateInput(updates, indices, shape) {\r\n    if (indices.rank < 1) {\r\n        throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' +\r\n            ` but the rank was ${indices.rank}.`);\r\n    }\r\n    if (updates.rank < 1) {\r\n        throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' +\r\n            ` but the rank was ${updates.rank}.`);\r\n    }\r\n    if (indices.dtype !== 'int32') {\r\n        throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);\r\n    }\r\n    if (shape.length < 1) {\r\n        throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);\r\n    }\r\n    if (shape.length === 0) {\r\n        if (indices.size === 0) {\r\n            throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);\r\n        }\r\n        if (updates.size === 0) {\r\n            throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);\r\n        }\r\n    }\r\n    validateUpdateShape(shape, indices, updates);\r\n}\r\n/**\r\n * Calculate the shape information for the output.\r\n *\r\n * @param update The tensor contains the update values.\r\n * @param indices The tensor contains the indices for the update values.\r\n * @param shape The shape of the output tensor.\r\n *\r\n * @returns ScatterShapeInfo\r\n */\r\nexport function calculateShapes(updates, indices, shape) {\r\n    // Calculate the number of dimensions in indices\r\n    const indicesRank = indices.shape.length;\r\n    const sliceRank = (indicesRank > 1) ? indices.shape[indicesRank - 1] : 1;\r\n    // Calculate the number of elements that make up each slice of our updated\r\n    // tensor. This allows us to work with flattened tensors and copy over whole\r\n    // slices at a time.\r\n    const totalNd = shape.length;\r\n    let sliceSize = 1;\r\n    for (let i = sliceRank; i < totalNd; ++i) {\r\n        sliceSize *= shape[i];\r\n    }\r\n    const safeSliceDim = (sliceRank < 1) ? 1 : sliceRank;\r\n    const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;\r\n    const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];\r\n    const outputSize = sizeFromShape(shape);\r\n    return { sliceRank, numUpdates, sliceSize, strides, outputSize };\r\n}\r\n//# sourceMappingURL=scatter_nd_util.js.map"]},"metadata":{},"sourceType":"module"}