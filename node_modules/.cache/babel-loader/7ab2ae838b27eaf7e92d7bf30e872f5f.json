{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from './engine';\nimport { env } from './environment';\nimport { Tensor } from './tensor';\nimport { assert, flatten, inferDtype, isTypedArray, toTypedArray } from './util';\nexport function inferShape(val, dtype) {\n  var firstElem = val;\n\n  if (isTypedArray(val)) {\n    return dtype === 'string' ? [] : [val.length];\n  }\n\n  if (!Array.isArray(val)) {\n    return []; // Scalar.\n  }\n\n  var shape = [];\n\n  while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== 'string') {\n    shape.push(firstElem.length);\n    firstElem = firstElem[0];\n  }\n\n  if (Array.isArray(val) && env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {\n    deepAssertShapeConsistency(val, shape, []);\n  }\n\n  return shape;\n}\n\nfunction deepAssertShapeConsistency(val, shape, indices) {\n  indices = indices || [];\n\n  if (!Array.isArray(val) && !isTypedArray(val)) {\n    assert(shape.length === 0, function () {\n      return \"Element arr[\".concat(indices.join(']['), \"] is a primitive, \") + \"but should be an array/TypedArray of \".concat(shape[0], \" elements\");\n    });\n    return;\n  }\n\n  assert(shape.length > 0, function () {\n    return \"Element arr[\".concat(indices.join(']['), \"] should be a primitive, \") + \"but is an array of \".concat(val.length, \" elements\");\n  });\n  assert(val.length === shape[0], function () {\n    return \"Element arr[\".concat(indices.join(']['), \"] should have \").concat(shape[0], \" \") + \"elements, but has \".concat(val.length, \" elements\");\n  });\n  var subShape = shape.slice(1);\n\n  for (var i = 0; i < val.length; ++i) {\n    deepAssertShapeConsistency(val[i], subShape, indices.concat(i));\n  }\n}\n\nfunction assertDtype(expectedDtype, actualDType, argName, functionName) {\n  if (expectedDtype == null) {\n    return;\n  }\n\n  if (expectedDtype !== 'numeric' && expectedDtype !== actualDType || expectedDtype === 'numeric' && actualDType === 'string') {\n    throw new Error(\"Argument '\".concat(argName, \"' passed to '\").concat(functionName, \"' must \") + \"be \".concat(expectedDtype, \" tensor, but got \").concat(actualDType, \" tensor\"));\n  }\n}\n\nexport function convertToTensor(x, argName, functionName) {\n  var parseAsDtype = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'numeric';\n\n  if (x instanceof Tensor) {\n    assertDtype(parseAsDtype, x.dtype, argName, functionName);\n    return x;\n  }\n\n  var inferredDtype = inferDtype(x); // If the user expects a bool/int/float, use that info to update the\n  // inferredDtype when it is not a string.\n\n  if (inferredDtype !== 'string' && ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {\n    inferredDtype = parseAsDtype;\n  }\n\n  assertDtype(parseAsDtype, inferredDtype, argName, functionName);\n\n  if (x == null || !isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' && typeof x !== 'boolean' && typeof x !== 'string') {\n    var type = x == null ? 'null' : x.constructor.name;\n    throw new Error(\"Argument '\".concat(argName, \"' passed to '\").concat(functionName, \"' must be a \") + \"Tensor or TensorLike, but got '\".concat(type, \"'\"));\n  }\n\n  var inferredShape = inferShape(x, inferredDtype);\n\n  if (!isTypedArray(x) && !Array.isArray(x)) {\n    x = [x];\n  }\n\n  var skipTypedArray = true;\n  var values = inferredDtype !== 'string' ? toTypedArray(x, inferredDtype) : flatten(x, [], skipTypedArray);\n  return ENGINE.makeTensor(values, inferredShape, inferredDtype);\n}\nexport function convertToTensorArray(arg, argName, functionName) {\n  var parseAsDtype = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'numeric';\n\n  if (!Array.isArray(arg)) {\n    throw new Error(\"Argument \".concat(argName, \" passed to \").concat(functionName, \" must be a \") + '`Tensor[]` or `TensorLike[]`');\n  }\n\n  var tensors = arg;\n  return tensors.map(function (t, i) {\n    return convertToTensor(t, \"\".concat(argName, \"[\").concat(i, \"]\"), functionName);\n  }, parseAsDtype);\n}","map":{"version":3,"sources":["../src/tensor_util_env.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from './engine';\r\nimport { env } from './environment';\r\nimport { Tensor } from './tensor';\r\nimport { assert, flatten, inferDtype, isTypedArray, toTypedArray } from './util';\r\nexport function inferShape(val, dtype) {\r\n    let firstElem = val;\r\n    if (isTypedArray(val)) {\r\n        return dtype === 'string' ? [] : [val.length];\r\n    }\r\n    if (!Array.isArray(val)) {\r\n        return []; // Scalar.\r\n    }\r\n    const shape = [];\r\n    while (Array.isArray(firstElem) ||\r\n        isTypedArray(firstElem) && dtype !== 'string') {\r\n        shape.push(firstElem.length);\r\n        firstElem = firstElem[0];\r\n    }\r\n    if (Array.isArray(val) &&\r\n        env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {\r\n        deepAssertShapeConsistency(val, shape, []);\r\n    }\r\n    return shape;\r\n}\r\nfunction deepAssertShapeConsistency(val, shape, indices) {\r\n    indices = indices || [];\r\n    if (!(Array.isArray(val)) && !isTypedArray(val)) {\r\n        assert(shape.length === 0, () => `Element arr[${indices.join('][')}] is a primitive, ` +\r\n            `but should be an array/TypedArray of ${shape[0]} elements`);\r\n        return;\r\n    }\r\n    assert(shape.length > 0, () => `Element arr[${indices.join('][')}] should be a primitive, ` +\r\n        `but is an array of ${val.length} elements`);\r\n    assert(val.length === shape[0], () => `Element arr[${indices.join('][')}] should have ${shape[0]} ` +\r\n        `elements, but has ${val.length} elements`);\r\n    const subShape = shape.slice(1);\r\n    for (let i = 0; i < val.length; ++i) {\r\n        deepAssertShapeConsistency(val[i], subShape, indices.concat(i));\r\n    }\r\n}\r\nfunction assertDtype(expectedDtype, actualDType, argName, functionName) {\r\n    if (expectedDtype == null) {\r\n        return;\r\n    }\r\n    if (expectedDtype !== 'numeric' && expectedDtype !== actualDType ||\r\n        expectedDtype === 'numeric' && actualDType === 'string') {\r\n        throw new Error(`Argument '${argName}' passed to '${functionName}' must ` +\r\n            `be ${expectedDtype} tensor, but got ${actualDType} tensor`);\r\n    }\r\n}\r\nexport function convertToTensor(x, argName, functionName, parseAsDtype = 'numeric') {\r\n    if (x instanceof Tensor) {\r\n        assertDtype(parseAsDtype, x.dtype, argName, functionName);\r\n        return x;\r\n    }\r\n    let inferredDtype = inferDtype(x);\r\n    // If the user expects a bool/int/float, use that info to update the\r\n    // inferredDtype when it is not a string.\r\n    if (inferredDtype !== 'string' &&\r\n        ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {\r\n        inferredDtype = parseAsDtype;\r\n    }\r\n    assertDtype(parseAsDtype, inferredDtype, argName, functionName);\r\n    if ((x == null) ||\r\n        (!isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' &&\r\n            typeof x !== 'boolean' && typeof x !== 'string')) {\r\n        const type = x == null ? 'null' : x.constructor.name;\r\n        throw new Error(`Argument '${argName}' passed to '${functionName}' must be a ` +\r\n            `Tensor or TensorLike, but got '${type}'`);\r\n    }\r\n    const inferredShape = inferShape(x, inferredDtype);\r\n    if (!isTypedArray(x) && !Array.isArray(x)) {\r\n        x = [x];\r\n    }\r\n    const skipTypedArray = true;\r\n    const values = inferredDtype !== 'string' ?\r\n        toTypedArray(x, inferredDtype) :\r\n        flatten(x, [], skipTypedArray);\r\n    return ENGINE.makeTensor(values, inferredShape, inferredDtype);\r\n}\r\nexport function convertToTensorArray(arg, argName, functionName, parseAsDtype = 'numeric') {\r\n    if (!Array.isArray(arg)) {\r\n        throw new Error(`Argument ${argName} passed to ${functionName} must be a ` +\r\n            '`Tensor[]` or `TensorLike[]`');\r\n    }\r\n    const tensors = arg;\r\n    return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName), parseAsDtype);\r\n}\r\n//# sourceMappingURL=tensor_util_env.js.map"]},"metadata":{},"sourceType":"module"}