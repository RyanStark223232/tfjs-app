{"ast":null,"code":"import _slicedToArray from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nexport var ResizeBilinearBackpropProgram = function ResizeBilinearBackpropProgram(dy, x, alignCorners) {\n  _classCallCheck(this, ResizeBilinearBackpropProgram);\n\n  this.variableNames = ['dy'];\n  this.outputShape = [];\n  this.outputShape = x.shape;\n\n  var _x$shape = _slicedToArray(x.shape, 3),\n      xHeight = _x$shape[1],\n      xWidth = _x$shape[2];\n\n  var _dy$shape = _slicedToArray(dy.shape, 3),\n      yHeight = _dy$shape[1],\n      yWidth = _dy$shape[2]; // In the backwards pass, we want to find the pixels that were generated for\n  // each pixel in the input image the forward pass and add the corresponding\n  // coefficient from dy to the gradient (with some interpolation).\n\n\n  var effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n  var effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n  var heightScale = effectiveXSize[0] / effectiveYSize[0];\n  var widthScale = effectiveXSize[1] / effectiveYSize[1];\n  var invHeightScale = 1 / heightScale;\n  var invWidthScale = 1 / widthScale; // This defines the size of the window of values around a particular\n  // index in dy that we want to search for contributions to dx.\n\n  var winHeight = Math.ceil(invHeightScale) * 2 + 2;\n  var winWidth = Math.ceil(invWidthScale) * 2 + 2;\n  this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\".concat(heightScale, \");\\n        const float widthScale = float(\").concat(widthScale, \");\\n\\n        const float invHeightScale = float(\").concat(invHeightScale, \");\\n        const float invWidthScale = float(\").concat(invWidthScale, \");\\n\\n        const int winHeight = int(\").concat(winHeight, \");\\n        const int winWidth = int(\").concat(winWidth, \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(startRLerp - float(winHeight / 2));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(startCLerp - float(winWidth / 2));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \").concat(yHeight, \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \").concat(yWidth, \") {\\n              continue;\\n            }\\n\\n            float dxR = float(dyR) * heightScale;\\n            int topDxRIndex = int(floor(dxR));\\n            int bottomDxRIndex = int(min(ceil(dxR), \").concat(xHeight - 1, \".0));\\n            float dxRLerp = dxR - float(topDxRIndex);\\n            float inverseDxRLerp = 1.0 - dxRLerp;\\n\\n            float dxC = float(dyC) * widthScale;\\n            int leftDxCIndex = int(floor(dxC));\\n            int rightDxCIndex = int(min(ceil(dxC), \").concat(xWidth - 1, \".0));\\n            float dxCLerp = dxC - float(leftDxCIndex);\\n            float inverseDxCLerp = 1.0 - dxCLerp;\\n\\n            if (r == topDxRIndex && c == leftDxCIndex) {\\n              // topLeft\\n              accumulator +=\\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == topDxRIndex && c == rightDxCIndex) {\\n              // topRight\\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\\n              // bottomLeft\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\\n              // bottomRight\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \");\n};","map":{"version":3,"sources":["../src/resize_bilinear_backprop_gpu.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;;;AAeG;AAKH,WAAa,6BAAb,GAKE,uCAAY,EAAZ,EAA0B,CAA1B,EAAuC,YAAvC,EAA4D;AAAA;;AAJ5D,OAAA,aAAA,GAAgB,CAAC,IAAD,CAAhB;AACA,OAAA,WAAA,GAAwB,EAAxB;AAIE,OAAK,WAAL,GAAmB,CAAC,CAAC,KAArB;;AAD0D,gCAE5B,CAAC,CAAC,KAF0B;AAAA,MAEjD,OAFiD;AAAA,MAExC,MAFwC;;AAAA,iCAG9B,EAAE,CAAC,KAH2B;AAAA,MAGjD,OAHiD;AAAA,MAGxC,MAHwC,iBAK1D;AACA;AACA;;;AAEA,MAAM,cAAc,GAAqB,CACtC,YAAY,IAAI,OAAO,GAAG,CAA3B,GAAgC,OAAO,GAAG,CAA1C,GAA8C,OADP,EAEtC,YAAY,IAAI,MAAM,GAAG,CAA1B,GAA+B,MAAM,GAAG,CAAxC,GAA4C,MAFL,CAAzC;AAKA,MAAM,cAAc,GAAqB,CACtC,YAAY,IAAI,OAAO,GAAG,CAA3B,GAAgC,OAAO,GAAG,CAA1C,GAA8C,OADP,EAEtC,YAAY,IAAI,MAAM,GAAG,CAA1B,GAA+B,MAAM,GAAG,CAAxC,GAA4C,MAFL,CAAzC;AAKA,MAAM,WAAW,GAAG,cAAc,CAAC,CAAD,CAAd,GAAoB,cAAc,CAAC,CAAD,CAAtD;AACA,MAAM,UAAU,GAAG,cAAc,CAAC,CAAD,CAAd,GAAoB,cAAc,CAAC,CAAD,CAArD;AAEA,MAAM,cAAc,GAAG,IAAI,WAA3B;AACA,MAAM,aAAa,GAAG,IAAI,UAA1B,CAvB0D,CAyB1D;AACA;;AACA,MAAM,SAAS,GAAI,IAAI,CAAC,IAAL,CAAU,cAAV,IAA4B,CAA7B,GAAkC,CAApD;AACA,MAAM,QAAQ,GAAI,IAAI,CAAC,IAAL,CAAU,aAAV,IAA2B,CAA5B,GAAiC,CAAlD;AAEA,OAAK,QAAL,6QAUsC,WAVtC,wDAWqC,UAXrC,8DAayC,cAbzC,2DAcwC,aAdxC,qDAgBgC,SAhBhC,kDAiB+B,QAjB/B,wjBA+B8B,OA/B9B,qRAuCgC,MAvChC,mNA6CkD,OAAO,GAAG,CA7C5D,sRAmDiD,MAAM,GAAG,CAnD1D;AAkFD,CArHH","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nexport class ResizeBilinearBackpropProgram {\r\n    constructor(dy, x, alignCorners) {\r\n        this.variableNames = ['dy'];\r\n        this.outputShape = [];\r\n        this.outputShape = x.shape;\r\n        const [, xHeight, xWidth,] = x.shape;\r\n        const [, yHeight, yWidth] = dy.shape;\r\n        // In the backwards pass, we want to find the pixels that were generated for\r\n        // each pixel in the input image the forward pass and add the corresponding\r\n        // coefficient from dy to the gradient (with some interpolation).\r\n        const effectiveXSize = [\r\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\r\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\r\n        ];\r\n        const effectiveYSize = [\r\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\r\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\r\n        ];\r\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\r\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\r\n        const invHeightScale = 1 / heightScale;\r\n        const invWidthScale = 1 / widthScale;\r\n        // This defines the size of the window of values around a particular\r\n        // index in dy that we want to search for contributions to dx.\r\n        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\r\n        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\r\n        this.userCode = `\r\n      void main() {\r\n        ivec4 coords = getOutputCoords();\r\n        int b = coords[0];\r\n        int d = coords[3];\r\n        int r = coords[1];\r\n        int c = coords[2];\r\n\r\n        float accumulator = 0.0;\r\n\r\n        const float heightScale = float(${heightScale});\r\n        const float widthScale = float(${widthScale});\r\n\r\n        const float invHeightScale = float(${invHeightScale});\r\n        const float invWidthScale = float(${invWidthScale});\r\n\r\n        const int winHeight = int(${winHeight});\r\n        const int winWidth = int(${winWidth});\r\n\r\n        // Compute bounds for where in dy we will look\r\n        float startRLerp = floor(float(r) * invHeightScale);\r\n        int startDyR = int(startRLerp - float(winHeight / 2));\r\n\r\n        float startCLerp = floor(float(c) * invWidthScale);\r\n        int startDyC = int(startCLerp - float(winWidth / 2));\r\n\r\n        // Loop over dy\r\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\r\n          int dyR = dyROffset + startDyR;\r\n\r\n          // Guard against the window exceeding the bounds of dy\r\n          if (dyR < 0 || dyR >= ${yHeight}) {\r\n            continue;\r\n          }\r\n\r\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\r\n            int dyC = dyCOffset + startDyC;\r\n\r\n            // Guard against the window exceeding the bounds of dy\r\n            if (dyC < 0 || dyC >= ${yWidth}) {\r\n              continue;\r\n            }\r\n\r\n            float dxR = float(dyR) * heightScale;\r\n            int topDxRIndex = int(floor(dxR));\r\n            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));\r\n            float dxRLerp = dxR - float(topDxRIndex);\r\n            float inverseDxRLerp = 1.0 - dxRLerp;\r\n\r\n            float dxC = float(dyC) * widthScale;\r\n            int leftDxCIndex = int(floor(dxC));\r\n            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));\r\n            float dxCLerp = dxC - float(leftDxCIndex);\r\n            float inverseDxCLerp = 1.0 - dxCLerp;\r\n\r\n            if (r == topDxRIndex && c == leftDxCIndex) {\r\n              // topLeft\r\n              accumulator +=\r\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\r\n            }\r\n\r\n            if (r == topDxRIndex && c == rightDxCIndex) {\r\n              // topRight\r\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\r\n            }\r\n\r\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\r\n              // bottomLeft\r\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\r\n            }\r\n\r\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\r\n              // bottomRight\r\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\r\n            }\r\n          }\r\n        }\r\n        // End loop over dy\r\n\r\n        setOutput(accumulator);\r\n      }\r\n    `;\r\n    }\r\n}\r\n//# sourceMappingURL=resize_bilinear_backprop_gpu.js.map"]},"metadata":{},"sourceType":"module"}