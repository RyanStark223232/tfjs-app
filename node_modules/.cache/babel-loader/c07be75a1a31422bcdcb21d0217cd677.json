{"ast":null,"code":"import _slicedToArray from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../../engine';\nimport { dispose } from '../../globals';\nimport { assert } from '../../util';\nimport { clone } from '../clone';\nimport { concat } from '../concat';\nimport { div } from '../div';\nimport { eye } from '../eye';\nimport { greater } from '../greater';\nimport { matMul } from '../mat_mul';\nimport { mul } from '../mul';\nimport { neg } from '../neg';\nimport { norm } from '../norm';\nimport { op } from '../operation';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { stack } from '../stack';\nimport { sub } from '../sub';\nimport { tensor2d } from '../tensor2d';\nimport { transpose } from '../transpose';\nimport { unstack } from '../unstack';\nimport { where } from '../where';\n/**\r\n * Compute QR decomposition of m-by-n matrix using Householder transformation.\r\n *\r\n * Implementation based on\r\n *   [http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf]\r\n * (http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf)\r\n *\r\n * ```js\r\n * const a = tf.tensor2d([[1, 2], [3, 4]]);\r\n * let [q, r] = tf.linalg.qr(a);\r\n * console.log('Q');\r\n * q.print();\r\n * console.log('R');\r\n * r.print();\r\n * console.log('Orthogonalized');\r\n * q.dot(q.transpose()).print()  // should be nearly the identity matrix.\r\n * console.log('Reconstructed');\r\n * q.dot(r).print(); // should be nearly [[1, 2], [3, 4]];\r\n * ```\r\n *\r\n * @param x The `tf.Tensor` to be QR-decomposed. Must have rank >= 2. Suppose\r\n *   it has the shape `[..., M, N]`.\r\n * @param fullMatrices An optional boolean parameter. Defaults to `false`.\r\n *   If `true`, compute full-sized `Q`. If `false` (the default),\r\n *   compute only the leading N columns of `Q` and `R`.\r\n * @returns An `Array` of two `tf.Tensor`s: `[Q, R]`. `Q` is a unitary matrix,\r\n *   i.e., its columns all have unit norm and are mutually orthogonal.\r\n *   If `M >= N`,\r\n *     If `fullMatrices` is `false` (default),\r\n *       - `Q` has a shape of `[..., M, N]`,\r\n *       - `R` has a shape of `[..., N, N]`.\r\n *     If `fullMatrices` is `true` (default),\r\n *       - `Q` has a shape of `[..., M, M]`,\r\n *       - `R` has a shape of `[..., M, N]`.\r\n *   If `M < N`,\r\n *     - `Q` has a shape of `[..., M, M]`,\r\n *     - `R` has a shape of `[..., M, N]`.\r\n * @throws If the rank of `x` is less than 2.\r\n *\r\n * @doc {heading:'Operations',\r\n *       subheading:'Linear Algebra',\r\n *       namespace:'linalg'}\r\n */\n\nfunction qr_(x) {\n  var fullMatrices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assert(x.rank >= 2, function () {\n    return \"qr() requires input tensor to have a rank >= 2, but got rank \".concat(x.rank);\n  });\n\n  if (x.rank === 2) {\n    return qr2d(x, fullMatrices);\n  } else {\n    // Rank > 2.\n    // TODO(cais): Below we split the input into individual 2D tensors,\n    //   perform QR decomposition on them and then stack the results back\n    //   together. We should explore whether this can be parallelized.\n    var outerDimsProd = x.shape.slice(0, x.shape.length - 2).reduce(function (value, prev) {\n      return value * prev;\n    });\n    var x2ds = unstack(reshape(x, [outerDimsProd, x.shape[x.shape.length - 2], x.shape[x.shape.length - 1]]), 0);\n    var q2ds = [];\n    var r2ds = [];\n    x2ds.forEach(function (x2d) {\n      var _qr2d = qr2d(x2d, fullMatrices),\n          _qr2d2 = _slicedToArray(_qr2d, 2),\n          q2d = _qr2d2[0],\n          r2d = _qr2d2[1];\n\n      q2ds.push(q2d);\n      r2ds.push(r2d);\n    });\n    var q = reshape(stack(q2ds, 0), x.shape);\n    var r = reshape(stack(r2ds, 0), x.shape);\n    return [q, r];\n  }\n}\n\nfunction qr2d(x) {\n  var fullMatrices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return ENGINE.tidy(function () {\n    assert(x.shape.length === 2, function () {\n      return \"qr2d() requires a 2D Tensor, but got a \".concat(x.shape.length, \"D Tensor.\");\n    });\n    var m = x.shape[0];\n    var n = x.shape[1];\n    var q = eye(m); // Orthogonal transform so far.\n\n    var r = clone(x); // Transformed matrix so far.\n\n    var one2D = tensor2d([[1]], [1, 1]);\n    var w = clone(one2D);\n    var iters = m >= n ? n : m;\n\n    var _loop = function _loop(j) {\n      // This tidy within the for-loop ensures we clean up temporary\n      // tensors as soon as they are no longer needed.\n      var rTemp = r;\n      var wTemp = w;\n      var qTemp = q;\n\n      var _ENGINE$tidy = ENGINE.tidy(function () {\n        // Find H = I - tau * w * w', to put zeros below R(j, j).\n        var rjEnd1 = slice(r, [j, j], [m - j, 1]);\n        var normX = norm(rjEnd1);\n        var rjj = slice(r, [j, j], [1, 1]); // The sign() function returns 0 on 0, which causes division by zero.\n\n        var s = where(greater(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));\n        var u1 = sub(rjj, mul(s, normX));\n        var wPre = div(rjEnd1, u1);\n\n        if (wPre.shape[0] === 1) {\n          w = clone(one2D);\n        } else {\n          w = concat([one2D, slice(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])], 0);\n        }\n\n        var tau = neg(div(matMul(s, u1), normX)); // -- R := HR, Q := QH.\n\n        var rjEndAll = slice(r, [j, 0], [m - j, n]);\n        var tauTimesW = mul(tau, w);\n        var wT = transpose(w);\n\n        if (j === 0) {\n          r = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));\n        } else {\n          var rTimesTau = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));\n          r = concat([slice(r, [0, 0], [j, n]), rTimesTau], 0);\n        }\n\n        var tawTimesWT = transpose(tauTimesW);\n        var qAllJEnd = slice(q, [0, j], [m, q.shape[1] - j]);\n\n        if (j === 0) {\n          q = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));\n        } else {\n          var qTimesTau = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));\n          q = concat([slice(q, [0, 0], [m, j]), qTimesTau], 1);\n        }\n\n        return [w, r, q];\n      });\n\n      var _ENGINE$tidy2 = _slicedToArray(_ENGINE$tidy, 3);\n\n      w = _ENGINE$tidy2[0];\n      r = _ENGINE$tidy2[1];\n      q = _ENGINE$tidy2[2];\n      dispose([rTemp, wTemp, qTemp]);\n    };\n\n    for (var j = 0; j < iters; ++j) {\n      _loop(j);\n    }\n\n    if (!fullMatrices && m > n) {\n      q = slice(q, [0, 0], [m, n]);\n      r = slice(r, [0, 0], [n, n]);\n    }\n\n    return [q, r];\n  });\n}\n\nexport var qr = op({\n  qr_: qr_\n});","map":{"version":3,"sources":["../../../src/ops/linalg/qr.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { ENGINE } from '../../engine';\r\nimport { dispose } from '../../globals';\r\nimport { assert } from '../../util';\r\nimport { clone } from '../clone';\r\nimport { concat } from '../concat';\r\nimport { div } from '../div';\r\nimport { eye } from '../eye';\r\nimport { greater } from '../greater';\r\nimport { matMul } from '../mat_mul';\r\nimport { mul } from '../mul';\r\nimport { neg } from '../neg';\r\nimport { norm } from '../norm';\r\nimport { op } from '../operation';\r\nimport { reshape } from '../reshape';\r\nimport { slice } from '../slice';\r\nimport { stack } from '../stack';\r\nimport { sub } from '../sub';\r\nimport { tensor2d } from '../tensor2d';\r\nimport { transpose } from '../transpose';\r\nimport { unstack } from '../unstack';\r\nimport { where } from '../where';\r\n/**\r\n * Compute QR decomposition of m-by-n matrix using Householder transformation.\r\n *\r\n * Implementation based on\r\n *   [http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf]\r\n * (http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf)\r\n *\r\n * ```js\r\n * const a = tf.tensor2d([[1, 2], [3, 4]]);\r\n * let [q, r] = tf.linalg.qr(a);\r\n * console.log('Q');\r\n * q.print();\r\n * console.log('R');\r\n * r.print();\r\n * console.log('Orthogonalized');\r\n * q.dot(q.transpose()).print()  // should be nearly the identity matrix.\r\n * console.log('Reconstructed');\r\n * q.dot(r).print(); // should be nearly [[1, 2], [3, 4]];\r\n * ```\r\n *\r\n * @param x The `tf.Tensor` to be QR-decomposed. Must have rank >= 2. Suppose\r\n *   it has the shape `[..., M, N]`.\r\n * @param fullMatrices An optional boolean parameter. Defaults to `false`.\r\n *   If `true`, compute full-sized `Q`. If `false` (the default),\r\n *   compute only the leading N columns of `Q` and `R`.\r\n * @returns An `Array` of two `tf.Tensor`s: `[Q, R]`. `Q` is a unitary matrix,\r\n *   i.e., its columns all have unit norm and are mutually orthogonal.\r\n *   If `M >= N`,\r\n *     If `fullMatrices` is `false` (default),\r\n *       - `Q` has a shape of `[..., M, N]`,\r\n *       - `R` has a shape of `[..., N, N]`.\r\n *     If `fullMatrices` is `true` (default),\r\n *       - `Q` has a shape of `[..., M, M]`,\r\n *       - `R` has a shape of `[..., M, N]`.\r\n *   If `M < N`,\r\n *     - `Q` has a shape of `[..., M, M]`,\r\n *     - `R` has a shape of `[..., M, N]`.\r\n * @throws If the rank of `x` is less than 2.\r\n *\r\n * @doc {heading:'Operations',\r\n *       subheading:'Linear Algebra',\r\n *       namespace:'linalg'}\r\n */\r\nfunction qr_(x, fullMatrices = false) {\r\n    assert(x.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${x.rank}`);\r\n    if (x.rank === 2) {\r\n        return qr2d(x, fullMatrices);\r\n    }\r\n    else {\r\n        // Rank > 2.\r\n        // TODO(cais): Below we split the input into individual 2D tensors,\r\n        //   perform QR decomposition on them and then stack the results back\r\n        //   together. We should explore whether this can be parallelized.\r\n        const outerDimsProd = x.shape.slice(0, x.shape.length - 2)\r\n            .reduce((value, prev) => value * prev);\r\n        const x2ds = unstack(reshape(x, [\r\n            outerDimsProd, x.shape[x.shape.length - 2],\r\n            x.shape[x.shape.length - 1]\r\n        ]), 0);\r\n        const q2ds = [];\r\n        const r2ds = [];\r\n        x2ds.forEach(x2d => {\r\n            const [q2d, r2d] = qr2d(x2d, fullMatrices);\r\n            q2ds.push(q2d);\r\n            r2ds.push(r2d);\r\n        });\r\n        const q = reshape(stack(q2ds, 0), x.shape);\r\n        const r = reshape(stack(r2ds, 0), x.shape);\r\n        return [q, r];\r\n    }\r\n}\r\nfunction qr2d(x, fullMatrices = false) {\r\n    return ENGINE.tidy(() => {\r\n        assert(x.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${x.shape.length}D Tensor.`);\r\n        const m = x.shape[0];\r\n        const n = x.shape[1];\r\n        let q = eye(m); // Orthogonal transform so far.\r\n        let r = clone(x); // Transformed matrix so far.\r\n        const one2D = tensor2d([[1]], [1, 1]);\r\n        let w = clone(one2D);\r\n        const iters = m >= n ? n : m;\r\n        for (let j = 0; j < iters; ++j) {\r\n            // This tidy within the for-loop ensures we clean up temporary\r\n            // tensors as soon as they are no longer needed.\r\n            const rTemp = r;\r\n            const wTemp = w;\r\n            const qTemp = q;\r\n            [w, r, q] = ENGINE.tidy(() => {\r\n                // Find H = I - tau * w * w', to put zeros below R(j, j).\r\n                const rjEnd1 = slice(r, [j, j], [m - j, 1]);\r\n                const normX = norm(rjEnd1);\r\n                const rjj = slice(r, [j, j], [1, 1]);\r\n                // The sign() function returns 0 on 0, which causes division by zero.\r\n                const s = where(greater(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));\r\n                const u1 = sub(rjj, mul(s, normX));\r\n                const wPre = div(rjEnd1, u1);\r\n                if (wPre.shape[0] === 1) {\r\n                    w = clone(one2D);\r\n                }\r\n                else {\r\n                    w = concat([\r\n                        one2D,\r\n                        slice(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])\r\n                    ], 0);\r\n                }\r\n                const tau = neg(div(matMul(s, u1), normX));\r\n                // -- R := HR, Q := QH.\r\n                const rjEndAll = slice(r, [j, 0], [m - j, n]);\r\n                const tauTimesW = mul(tau, w);\r\n                const wT = transpose(w);\r\n                if (j === 0) {\r\n                    r = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));\r\n                }\r\n                else {\r\n                    const rTimesTau = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));\r\n                    r = concat([slice(r, [0, 0], [j, n]), rTimesTau], 0);\r\n                }\r\n                const tawTimesWT = transpose(tauTimesW);\r\n                const qAllJEnd = slice(q, [0, j], [m, q.shape[1] - j]);\r\n                if (j === 0) {\r\n                    q = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));\r\n                }\r\n                else {\r\n                    const qTimesTau = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));\r\n                    q = concat([slice(q, [0, 0], [m, j]), qTimesTau], 1);\r\n                }\r\n                return [w, r, q];\r\n            });\r\n            dispose([rTemp, wTemp, qTemp]);\r\n        }\r\n        if (!fullMatrices && m > n) {\r\n            q = slice(q, [0, 0], [m, n]);\r\n            r = slice(r, [0, 0], [n, n]);\r\n        }\r\n        return [q, r];\r\n    });\r\n}\r\nexport const qr = op({ qr_ });\r\n//# sourceMappingURL=qr.js.map"]},"metadata":{},"sourceType":"module"}