{"ast":null,"code":"import _classCallCheck from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport var ConcatPackedProgram = function ConcatPackedProgram(shapes, axis) {\n  _classCallCheck(this, ConcatPackedProgram);\n\n  this.packedInputs = true;\n  this.packedOutput = true;\n  this.outputShape = [];\n  this.outputShape = backend_util.computeOutShape(shapes, axis);\n  var shape = this.outputShape;\n  var rank = shape.length;\n  var dtype = getCoordsDataType(rank);\n  var coords = getChannels('coords', rank);\n  var channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n  this.variableNames = shapes.map(function (_, i) {\n    return \"T\".concat(i);\n  });\n  var offsets = new Array(shapes.length - 1);\n  offsets[0] = shapes[0][axis];\n\n  for (var i = 1; i < offsets.length; i++) {\n    offsets[i] = offsets[i - 1] + shapes[i][axis];\n  }\n\n  var channel = channels[axis];\n  var lastChannels = channels.slice(-2);\n  var allChannels = channels.join();\n  var getValueSnippet = \"if (\".concat(channel, \" < \").concat(offsets[0], \") {\\n        return getChannel(\\n            getT0(\").concat(allChannels, \"), vec2(\").concat(lastChannels.join(), \"));\\n        }\");\n\n  for (var _i = 1; _i < offsets.length; _i++) {\n    var _shift = offsets[_i - 1]; // Note: the >= comparison below may seem unnecessary given the check\n    // above but is needed to workaround branch execution issues on some\n    // devices. It makes all the conditions exclusive without relying on\n    // execution order.\n\n    getValueSnippet += \"\\n        if (\".concat(channel, \" < \").concat(offsets[_i], \"  && \").concat(channel, \" >= \").concat(offsets[_i - 1], \") {\\n          return getChannel(\\n            getT\").concat(_i, \"(\").concat(shiftedChannels(channels, channel, _shift), \"),\\n            vec2(\").concat(shiftedChannels(lastChannels, channel, _shift), \"));\\n        }\");\n  }\n\n  var lastIndex = offsets.length;\n  var shift = offsets[offsets.length - 1];\n  getValueSnippet += \"\\n        return getChannel(\\n          getT\".concat(lastIndex, \"(\").concat(shiftedChannels(channels, channel, shift), \"),\\n          vec2(\").concat(shiftedChannels(lastChannels, channel, shift), \"));\");\n  this.userCode = \"\\n      float getValue(\".concat(channels.map(function (x) {\n    return 'int ' + x;\n  }), \") {\\n        \").concat(getValueSnippet, \"\\n      }\\n\\n      void main() {\\n        \").concat(dtype, \" coords = getOutputCoords();\\n        vec4 result = vec4(getValue(\").concat(coords, \"), 0., 0., 0.);\\n\\n        \").concat(coords[rank - 1], \" = \").concat(coords[rank - 1], \" + 1;\\n        if (\").concat(coords[rank - 1], \" < \").concat(shape[rank - 1], \") {\\n          result.g = getValue(\").concat(coords, \");\\n        }\\n\\n        \").concat(coords[rank - 2], \" = \").concat(coords[rank - 2], \" + 1;\\n        if (\").concat(coords[rank - 2], \" < \").concat(shape[rank - 2], \") {\\n          result.a = getValue(\").concat(coords, \");\\n        }\\n\\n        \").concat(coords[rank - 1], \" = \").concat(coords[rank - 1], \" - 1;\\n        if (\").concat(coords[rank - 2], \" < \").concat(shape[rank - 2], \" &&\\n            \").concat(coords[rank - 1], \" < \").concat(shape[rank - 1], \") {\\n          result.b = getValue(\").concat(coords, \");\\n        }\\n        setOutput(result);\\n      }\\n    \");\n};\n/**\r\n * Return an expression for coordinates into a vector where a given channel\r\n * will be offset by [shift].\r\n *\r\n * @param channels the channels to consider\r\n * @param channel the channel we want shifted\r\n * @param shift  the amount to subtract from the channel.\r\n *\r\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\r\n * have the shift applied.\r\n */\n\nfunction shiftedChannels(channels, channel, shift) {\n  var channelIdx = channels.indexOf(channel);\n  var res = channels.map(function (c, idx) {\n    if (idx === channelIdx) {\n      return \"\".concat(c, \" - \").concat(shift);\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n}","map":{"version":3,"sources":["../src/concat_packed_gpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { backend_util } from '@tensorflow/tfjs-core';\r\nimport { getChannels } from './packing_util';\r\nimport { getCoordsDataType } from './shader_compiler';\r\nexport class ConcatPackedProgram {\r\n    constructor(shapes, axis) {\r\n        this.packedInputs = true;\r\n        this.packedOutput = true;\r\n        this.outputShape = [];\r\n        this.outputShape = backend_util.computeOutShape(shapes, axis);\r\n        const shape = this.outputShape;\r\n        const rank = shape.length;\r\n        const dtype = getCoordsDataType(rank);\r\n        const coords = getChannels('coords', rank);\r\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\r\n        this.variableNames = shapes.map((_, i) => `T${i}`);\r\n        const offsets = new Array(shapes.length - 1);\r\n        offsets[0] = shapes[0][axis];\r\n        for (let i = 1; i < offsets.length; i++) {\r\n            offsets[i] = offsets[i - 1] + shapes[i][axis];\r\n        }\r\n        const channel = channels[axis];\r\n        const lastChannels = channels.slice(-2);\r\n        const allChannels = channels.join();\r\n        let getValueSnippet = `if (${channel} < ${offsets[0]}) {\r\n        return getChannel(\r\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\r\n        }`;\r\n        for (let i = 1; i < offsets.length; i++) {\r\n            const shift = offsets[i - 1];\r\n            // Note: the >= comparison below may seem unnecessary given the check\r\n            // above but is needed to workaround branch execution issues on some\r\n            // devices. It makes all the conditions exclusive without relying on\r\n            // execution order.\r\n            getValueSnippet += `\r\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\r\n          return getChannel(\r\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\r\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\r\n        }`;\r\n        }\r\n        const lastIndex = offsets.length;\r\n        const shift = offsets[offsets.length - 1];\r\n        getValueSnippet += `\r\n        return getChannel(\r\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\r\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\r\n        this.userCode = `\r\n      float getValue(${channels.map(x => 'int ' + x)}) {\r\n        ${getValueSnippet}\r\n      }\r\n\r\n      void main() {\r\n        ${dtype} coords = getOutputCoords();\r\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\r\n\r\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\r\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\r\n          result.g = getValue(${coords});\r\n        }\r\n\r\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\r\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\r\n          result.a = getValue(${coords});\r\n        }\r\n\r\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\r\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\r\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\r\n          result.b = getValue(${coords});\r\n        }\r\n        setOutput(result);\r\n      }\r\n    `;\r\n    }\r\n}\r\n/**\r\n * Return an expression for coordinates into a vector where a given channel\r\n * will be offset by [shift].\r\n *\r\n * @param channels the channels to consider\r\n * @param channel the channel we want shifted\r\n * @param shift  the amount to subtract from the channel.\r\n *\r\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\r\n * have the shift applied.\r\n */\r\nfunction shiftedChannels(channels, channel, shift) {\r\n    const channelIdx = channels.indexOf(channel);\r\n    const res = channels.map((c, idx) => {\r\n        if (idx === channelIdx) {\r\n            return `${c} - ${shift}`;\r\n        }\r\n        else {\r\n            return c;\r\n        }\r\n    });\r\n    return res.join();\r\n}\r\n//# sourceMappingURL=concat_packed_gpu.js.map"]},"metadata":{},"sourceType":"module"}