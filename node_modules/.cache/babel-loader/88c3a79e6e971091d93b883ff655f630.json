{"ast":null,"code":"import { env } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nexport var CHECK_NAN_SNIPPET_UNARY = \"if (isnan(x)) return x;\";\nexport var CHECK_NAN_SNIPPET_BINARY = \"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\";\nexport var CHECK_NAN_SNIPPET_BINARY_PACKED = \"\\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\";\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippets Op snippet to create `UnaryOpProgram`.\n */\n\nexport function unaryKernelFunc(opSnippet) {\n  return function (_ref) {\n    var inputs = _ref.inputs,\n        backend = _ref.backend;\n    var x = inputs.x;\n    var webglBackend = backend;\n    var program = new UnaryOpProgram(x.shape, opSnippet);\n    return webglBackend.runWebGLProgram(program, [x], x.dtype);\n  };\n}\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\n\nexport function binaryKernelFunc(opSnippet, packedOpSnippet, checkOutOfBoundsForPackedProgram, dtype) {\n  // TODO(jingjin): handle complex64.\n  return function (_ref2) {\n    var inputs = _ref2.inputs,\n        backend = _ref2.backend;\n    var a = inputs.a,\n        b = inputs.b;\n    var webglBackend = backend;\n    var program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ? new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, !!checkOutOfBoundsForPackedProgram) : new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    var $dtype = dtype || a.dtype;\n    var output = webglBackend.runWebGLProgram(program, [a, b], $dtype);\n    return output;\n  };\n}","map":{"version":3,"sources":["../../src/kernel_utils/kernel_funcs_utils.ts"],"names":[],"mappings":"AAAA,SAAgC,GAAhC,QAAmE,uBAAnE;AAGA,SAAQ,eAAR,QAA8B,iBAA9B;AACA,SAAQ,qBAAR,QAAoC,wBAApC;AACA,SAAQ,cAAR,QAA6B,gBAA7B;AAEA,OAAO,IAAM,uBAAuB,4BAA7B;AAEP,OAAO,IAAM,wBAAwB,6DAA9B;AAKP,OAAO,IAAM,+BAA+B,2LAArC;AAOP;;;AAGG;;AACH,OAAM,SAAU,eAAV,CAA0B,SAA1B,EAA2C;AAC/C,SAAO,gBAAsB;AAAA,QAApB,MAAoB,QAApB,MAAoB;AAAA,QAAZ,OAAY,QAAZ,OAAY;AAAA,QACpB,CADoB,GACf,MADe,CACpB,CADoB;AAE3B,QAAM,YAAY,GAAG,OAArB;AACA,QAAM,OAAO,GAAG,IAAI,cAAJ,CAAmB,CAAC,CAAC,KAArB,EAA4B,SAA5B,CAAhB;AACA,WAAO,YAAY,CAAC,eAAb,CAA6B,OAA7B,EAAsC,CAAC,CAAD,CAAtC,EAA2C,CAAC,CAAC,KAA7C,CAAP;AACD,GALD;AAMD;AAED;;;;;;;;;AASG;;AACH,OAAM,SAAU,gBAAV,CACF,SADE,EACiB,eADjB,EAEF,gCAFE,EAE0C,KAF1C,EAE0D;AAC9D;AAEA,SAAO,iBAAsB;AAAA,QAApB,MAAoB,SAApB,MAAoB;AAAA,QAAZ,OAAY,SAAZ,OAAY;AAAA,QACpB,CADoB,GACZ,MADY,CACpB,CADoB;AAAA,QACjB,CADiB,GACZ,MADY,CACjB,CADiB;AAE3B,QAAM,YAAY,GAAG,OAArB;AACA,QAAM,OAAO,GAAG,GAAG,GAAG,OAAN,CAAc,8BAAd,IACZ,IAAI,qBAAJ,CACI,eADJ,EACqB,CAAC,CAAC,KADvB,EAC8B,CAAC,CAAC,KADhC,EAEI,CAAC,CAAC,gCAFN,CADY,GAIZ,IAAI,eAAJ,CAAoB,SAApB,EAA+B,CAAC,CAAC,KAAjC,EAAwC,CAAC,CAAC,KAA1C,CAJJ;AAKA,QAAM,MAAM,GAAG,KAAK,IAAI,CAAC,CAAC,KAA1B;AACA,QAAM,MAAM,GAAG,YAAY,CAAC,eAAb,CAA6B,OAA7B,EAAsC,CAAC,CAAD,EAAI,CAAJ,CAAtC,EAA8C,MAA9C,CAAf;AACA,WAAO,MAAP;AACD,GAXD;AAYD","sourceRoot":"","sourcesContent":["import { env } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\nexport const CHECK_NAN_SNIPPET_BINARY = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippets Op snippet to create `UnaryOpProgram`.\n */\nexport function unaryKernelFunc(opSnippet) {\n    return ({ inputs, backend }) => {\n        const { x } = inputs;\n        const webglBackend = backend;\n        const program = new UnaryOpProgram(x.shape, opSnippet);\n        return webglBackend.runWebGLProgram(program, [x], x.dtype);\n    };\n}\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc(opSnippet, packedOpSnippet, checkOutOfBoundsForPackedProgram, dtype) {\n    // TODO(jingjin): handle complex64.\n    return ({ inputs, backend }) => {\n        const { a, b } = inputs;\n        const webglBackend = backend;\n        const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n            new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, !!checkOutOfBoundsForPackedProgram) :\n            new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        const $dtype = dtype || a.dtype;\n        const output = webglBackend.runWebGLProgram(program, [a, b], $dtype);\n        return output;\n    };\n}\n//# sourceMappingURL=kernel_funcs_utils.js.map"]},"metadata":{},"sourceType":"module"}