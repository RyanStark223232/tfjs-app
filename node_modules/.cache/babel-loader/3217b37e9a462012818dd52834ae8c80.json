{"ast":null,"code":"import _classCallCheck from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nexport var Pool2DProgram = function Pool2DProgram(convInfo, poolType, computePositions) {\n  var flattenPositions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var includeBatchInIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  _classCallCheck(this, Pool2DProgram);\n\n  this.variableNames = ['x'];\n\n  if (poolType === 'avg' && computePositions) {\n    throw new Error('Cannot compute positions for average pool.');\n  }\n\n  var filterWidth = convInfo.filterWidth;\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var dilationHeight = convInfo.dilationHeight;\n  var dilationWidth = convInfo.dilationWidth;\n  var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  var padTop = convInfo.padInfo.top;\n  var padLeft = convInfo.padInfo.left;\n  this.outputShape = convInfo.outShape;\n  var isAvgPool = poolType === 'avg';\n  var batchFlattenPositionStr = \"((batch  * \".concat(convInfo.inHeight, \" + xR) * \").concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + d\");\n  var flattenPositionStr = \"(xR * \".concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + d\");\n  var initializationValue = '0.0';\n\n  if (!isAvgPool) {\n    // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n    initializationValue = '-1.0 / 1e-20';\n  }\n\n  if (computePositions) {\n    var _compareOp = '>=';\n    this.userCode = \"\\n        const ivec2 strides = ivec2(\".concat(strideHeight, \", \").concat(strideWidth, \");\\n        const ivec2 pads = ivec2(\").concat(padTop, \", \").concat(padLeft, \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n              wR += \").concat(dilationHeight, \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \").concat(effectiveFilterWidth, \";\\n                wC += \").concat(dilationWidth, \") {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value \").concat(_compareOp, \" currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = \").concat(flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : \"wR * \".concat(effectiveFilterWidth, \" + wC\"), \";\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \");\n    return;\n  }\n\n  var compareOp = 'max';\n  var returnValue = \"\".concat(poolType, \"(\").concat(poolType, \"(\").concat(poolType, \"(\") + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n  if (poolType === 'avg') {\n    returnValue = \"avgValue / count\";\n  }\n\n  var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n  var filterWidthVec4Remainder = filterWidth % 4;\n  var updateSnippet = \"\\n      if (\".concat(isAvgPool, \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \").concat(compareOp, \"(values, minMaxValue);\\n      }\\n    \");\n  this.userCode = \"\\n      const ivec2 strides = ivec2(\".concat(strideHeight, \", \").concat(strideWidth, \");\\n      const ivec2 pads = ivec2(\").concat(padTop, \", \").concat(padLeft, \");\\n      const float initializationValue = \").concat(initializationValue, \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\").concat(initializationValue, \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n            wR += \").concat(dilationHeight, \") {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \").concat(filterWidthNearestVec4, \"; wC += 4) {\\n            int xC = xCCorner + wC * \").concat(dilationWidth, \";\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \").concat(dilationWidth, \", d),\\n              getValue(batch, xR, xC + 2 * \").concat(dilationWidth, \", d),\\n              getValue(batch, xR, xC + 3 * \").concat(dilationWidth, \", d)\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          }\\n\\n          int xC = xCCorner + \").concat(filterWidthNearestVec4, \";\\n          if (\").concat(filterWidthVec4Remainder === 1, \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          } else if (\").concat(filterWidthVec4Remainder === 2, \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \").concat(dilationWidth, \", d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          } else if (\").concat(filterWidthVec4Remainder === 3, \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \").concat(dilationWidth, \", d),\\n              getValue(batch, xR, xC + 2 * \").concat(dilationWidth, \", d),\\n              initializationValue\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          }\\n        }\\n        setOutput(\").concat(returnValue, \");\\n      }\\n    \");\n};\nexport var Pool3DProgram = function Pool3DProgram(convInfo, poolType, computePositions) {\n  var flattenPositions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var includeBatchInIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  _classCallCheck(this, Pool3DProgram);\n\n  this.variableNames = ['x'];\n\n  if (poolType === 'avg' && computePositions) {\n    throw new Error('Cannot compute positions for average pool.');\n  }\n\n  var filterWidth = convInfo.filterWidth;\n  var strideDepth = convInfo.strideDepth;\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var dilationDepth = convInfo.dilationDepth;\n  var dilationHeight = convInfo.dilationHeight;\n  var dilationWidth = convInfo.dilationWidth;\n  var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  var padFront = convInfo.padInfo.front;\n  var padTop = convInfo.padInfo.top;\n  var padLeft = convInfo.padInfo.left;\n  this.outputShape = convInfo.outShape;\n  var isAvgPool = poolType === 'avg';\n  var initializationValue = '0.0';\n\n  if (!isAvgPool) {\n    // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n    initializationValue = '-1.0 / 1e-20';\n  }\n\n  if (computePositions) {\n    var _compareOp2 = '>=';\n    this.userCode = \"\\n        const ivec3 strides =\\n            ivec3(\".concat(strideDepth, \", \").concat(strideHeight, \", \").concat(strideWidth, \");\\n        const ivec3 pads = ivec3(\").concat(padFront, \", \").concat(padTop, \", \").concat(padLeft, \");\\n\\n        void main() {\\n          ivec5 coords = getOutputCoords();\\n          int batch = coords.x;\\n          int ch = coords.u;\\n\\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n          int xDCorner = xCorner.x;\\n          int xRCorner = xCorner.y;\\n          int xCCorner = xCorner.z;\\n\\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n\\n          for (int wD = 0; wD < \").concat(effectiveFilterDepth, \";\\n              wD += \").concat(dilationDepth, \") {\\n            int xD = xDCorner + wD;\\n\\n            if (xD < 0 || xD >= \").concat(convInfo.inDepth, \") {\\n              continue;\\n            }\\n\\n            for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n                wR += \").concat(dilationHeight, \") {\\n              int xR = xRCorner + wR;\\n\\n              if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n                continue;\\n              }\\n\\n              for (int wC = 0; wC < \").concat(effectiveFilterWidth, \";\\n                  wC += \").concat(dilationWidth, \") {\\n                int xC = xCCorner + wC;\\n\\n                if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n                  continue;\\n                }\\n\\n                float value = getX(batch, xD, xR, xC, ch);\\n\\n                // If a min / max value has already been found, use it. If not,\\n                // use the current value.\\n                float currMinMaxValue = mix(\\n                    value, minMaxValue, minMaxValueFound);\\n                if (value \").concat(_compareOp2, \" currMinMaxValue) {\\n                  minMaxValue = value;\\n                  minMaxValueFound = 1.0;\\n                  minMaxPosition = \").concat(flattenPositions ? includeBatchInIndex ? \"(((batch * \".concat(convInfo.inDepth, \" + xD) * \").concat(convInfo.inHeight, \" + xR) * \").concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + ch\") : \"((xD * \".concat(convInfo.inHeight, \" + xR) * \").concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + ch\") : \"wD * \".concat(effectiveFilterHeight, \" * \").concat(effectiveFilterWidth, \" +\\n                      wR * \").concat(effectiveFilterWidth, \" + wC\"), \";\\n                }\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \");\n    return;\n  }\n\n  var compareOp = 'max';\n  var returnValue = \"\".concat(poolType, \"(\").concat(poolType, \"(\").concat(poolType, \"(\") + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n  if (poolType === 'avg') {\n    returnValue = \"avgValue / count\";\n  }\n\n  var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n  var filterWidthVec4Remainder = filterWidth % 4;\n  var updateSnippet = \"\\n      if (\".concat(isAvgPool, \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \").concat(compareOp, \"(values, minMaxValue);\\n      }\\n    \");\n  this.userCode = \"\\n      const ivec3 strides =\\n        ivec3(\".concat(strideDepth, \", \").concat(strideHeight, \", \").concat(strideWidth, \");\\n      const ivec3 pads = ivec3(\").concat(padFront, \", \").concat(padTop, \", \").concat(padLeft, \");\\n      const float initializationValue = \").concat(initializationValue, \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\\n        if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xD, xR, xC, ch);\\n      }\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xDCorner = xCorner.x;\\n        int xRCorner = xCorner.y;\\n        int xCCorner = xCorner.z;\\n\\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\").concat(initializationValue, \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wD = 0; wD < \").concat(effectiveFilterDepth, \";\\n            wD += \").concat(dilationDepth, \") {\\n          int xD = xDCorner + wD;\\n\\n          if (xD < 0 || xD >= \").concat(convInfo.inDepth, \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n            wR += \").concat(dilationHeight, \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \").concat(filterWidthNearestVec4, \"; wC += 4) {\\n              int xC = xCCorner + wC * \").concat(dilationWidth, \";\\n\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \").concat(dilationWidth, \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \").concat(dilationWidth, \", ch),\\n                getValue(batch, xD, xR, xC + 3 * \").concat(dilationWidth, \", ch)\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            }\\n\\n            int xC = xCCorner + \").concat(filterWidthNearestVec4, \";\\n            if (\").concat(filterWidthVec4Remainder === 1, \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                initializationValue,\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            } else if (\").concat(filterWidthVec4Remainder === 2, \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \").concat(dilationWidth, \", ch),\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            } else if (\").concat(filterWidthVec4Remainder === 3, \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \").concat(dilationWidth, \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \").concat(dilationWidth, \", ch),\\n                initializationValue\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            }\\n          }\\n          setOutput(\").concat(returnValue, \");\\n        }\\n      }\\n    \");\n};","map":{"version":3,"sources":["../src/pool_gpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nexport class Pool2DProgram {\r\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\r\n        this.variableNames = ['x'];\r\n        if (poolType === 'avg' && computePositions) {\r\n            throw new Error('Cannot compute positions for average pool.');\r\n        }\r\n        const filterWidth = convInfo.filterWidth;\r\n        const strideHeight = convInfo.strideHeight;\r\n        const strideWidth = convInfo.strideWidth;\r\n        const dilationHeight = convInfo.dilationHeight;\r\n        const dilationWidth = convInfo.dilationWidth;\r\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\r\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\r\n        const padTop = convInfo.padInfo.top;\r\n        const padLeft = convInfo.padInfo.left;\r\n        this.outputShape = convInfo.outShape;\r\n        const isAvgPool = poolType === 'avg';\r\n        const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\r\n        const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\r\n        let initializationValue = '0.0';\r\n        if (!isAvgPool) {\r\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\r\n            initializationValue = '-1.0 / 1e-20';\r\n        }\r\n        if (computePositions) {\r\n            const compareOp = '>=';\r\n            this.userCode = `\r\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\r\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\r\n\r\n        void main() {\r\n          ivec4 coords = getOutputCoords();\r\n          int batch = coords[0];\r\n          int d = coords[3];\r\n\r\n          ivec2 xRCCorner = coords.yz * strides - pads;\r\n          int xRCorner = xRCCorner.x;\r\n          int xCCorner = xRCCorner.y;\r\n\r\n          // max/min x(?, ?, d) to get y(yR, yC, d).\r\n          // ? = to be determined\r\n          float minMaxValue = 0.0;\r\n          float minMaxValueFound = 0.0;\r\n          int minMaxPosition = 0;\r\n          float avgValue = 0.0;\r\n\r\n          for (int wR = 0; wR < ${effectiveFilterHeight};\r\n              wR += ${dilationHeight}) {\r\n            int xR = xRCorner + wR;\r\n\r\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\r\n              continue;\r\n            }\r\n\r\n            for (int wC = 0; wC < ${effectiveFilterWidth};\r\n                wC += ${dilationWidth}) {\r\n              int xC = xCCorner + wC;\r\n\r\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\r\n                continue;\r\n              }\r\n\r\n              float value = getX(batch, xR, xC, d);\r\n\r\n              // If a min / max value has already been found, use it. If not,\r\n              // use the current value.\r\n              float currMinMaxValue = mix(\r\n                  value, minMaxValue, minMaxValueFound);\r\n              if (value ${compareOp} currMinMaxValue) {\r\n                minMaxValue = value;\r\n                minMaxValueFound = 1.0;\r\n                minMaxPosition = ${flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\r\n                flattenPositionStr) :\r\n                `wR * ${effectiveFilterWidth} + wC`};\r\n              }\r\n            }\r\n          }\r\n          setOutput(float(minMaxPosition));\r\n        }\r\n      `;\r\n            return;\r\n        }\r\n        const compareOp = 'max';\r\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\r\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\r\n        if (poolType === 'avg') {\r\n            returnValue = `avgValue / count`;\r\n        }\r\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\r\n        const filterWidthVec4Remainder = filterWidth % 4;\r\n        const updateSnippet = `\r\n      if (${isAvgPool}) {\r\n        avgValue += dot(values, ones);\r\n      } else {\r\n        minMaxValue = ${compareOp}(values, minMaxValue);\r\n      }\r\n    `;\r\n        this.userCode = `\r\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\r\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\r\n      const float initializationValue = ${initializationValue};\r\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\n      float count = 0.0;\r\n\r\n      float getValue(int batch, int xR, int xC, int d) {\r\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\r\n          return initializationValue;\r\n        }\r\n        count += 1.0;\r\n        return getX(batch, xR, xC, d);\r\n      }\r\n\r\n      void main() {\r\n        ivec4 coords = getOutputCoords();\r\n        int batch = coords[0];\r\n        int d = coords[3];\r\n\r\n        ivec2 xRCCorner = coords.yz * strides - pads;\r\n        int xRCorner = xRCCorner.x;\r\n        int xCCorner = xRCCorner.y;\r\n\r\n        // max/min x(?, ?, d) to get y(yR, yC, d).\r\n        // ? = to be determined\r\n        vec4 minMaxValue = vec4(${initializationValue});\r\n        float avgValue = 0.0;\r\n        count = 0.0;\r\n\r\n        for (int wR = 0; wR < ${effectiveFilterHeight};\r\n            wR += ${dilationHeight}) {\r\n          int xR = xRCorner + wR;\r\n\r\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\r\n            continue;\r\n          }\r\n\r\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\r\n            int xC = xCCorner + wC * ${dilationWidth};\r\n\r\n            vec4 values = vec4(\r\n              getValue(batch, xR, xC, d),\r\n              getValue(batch, xR, xC + ${dilationWidth}, d),\r\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\r\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\r\n            );\r\n\r\n            ${updateSnippet}\r\n          }\r\n\r\n          int xC = xCCorner + ${filterWidthNearestVec4};\r\n          if (${filterWidthVec4Remainder === 1}) {\r\n            vec4 values = vec4(\r\n              getValue(batch, xR, xC, d),\r\n              initializationValue,\r\n              initializationValue,\r\n              initializationValue\r\n            );\r\n\r\n            ${updateSnippet}\r\n          } else if (${filterWidthVec4Remainder === 2}) {\r\n            vec4 values = vec4(\r\n              getValue(batch, xR, xC, d),\r\n              getValue(batch, xR, xC + ${dilationWidth}, d),\r\n              initializationValue,\r\n              initializationValue\r\n            );\r\n\r\n            ${updateSnippet}\r\n          } else if (${filterWidthVec4Remainder === 3}) {\r\n            vec4 values = vec4(\r\n              getValue(batch, xR, xC, d),\r\n              getValue(batch, xR, xC + ${dilationWidth}, d),\r\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\r\n              initializationValue\r\n            );\r\n\r\n            ${updateSnippet}\r\n          }\r\n        }\r\n        setOutput(${returnValue});\r\n      }\r\n    `;\r\n    }\r\n}\r\nexport class Pool3DProgram {\r\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\r\n        this.variableNames = ['x'];\r\n        if (poolType === 'avg' && computePositions) {\r\n            throw new Error('Cannot compute positions for average pool.');\r\n        }\r\n        const filterWidth = convInfo.filterWidth;\r\n        const strideDepth = convInfo.strideDepth;\r\n        const strideHeight = convInfo.strideHeight;\r\n        const strideWidth = convInfo.strideWidth;\r\n        const dilationDepth = convInfo.dilationDepth;\r\n        const dilationHeight = convInfo.dilationHeight;\r\n        const dilationWidth = convInfo.dilationWidth;\r\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\r\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\r\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\r\n        const padFront = convInfo.padInfo.front;\r\n        const padTop = convInfo.padInfo.top;\r\n        const padLeft = convInfo.padInfo.left;\r\n        this.outputShape = convInfo.outShape;\r\n        const isAvgPool = poolType === 'avg';\r\n        let initializationValue = '0.0';\r\n        if (!isAvgPool) {\r\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\r\n            initializationValue = '-1.0 / 1e-20';\r\n        }\r\n        if (computePositions) {\r\n            const compareOp = '>=';\r\n            this.userCode = `\r\n        const ivec3 strides =\r\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\r\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\r\n\r\n        void main() {\r\n          ivec5 coords = getOutputCoords();\r\n          int batch = coords.x;\r\n          int ch = coords.u;\r\n\r\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\r\n          int xDCorner = xCorner.x;\r\n          int xRCorner = xCorner.y;\r\n          int xCCorner = xCorner.z;\r\n\r\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\r\n          // ? = to be determined\r\n          float minMaxValue = 0.0;\r\n          float minMaxValueFound = 0.0;\r\n          int minMaxPosition = 0;\r\n\r\n          for (int wD = 0; wD < ${effectiveFilterDepth};\r\n              wD += ${dilationDepth}) {\r\n            int xD = xDCorner + wD;\r\n\r\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\r\n              continue;\r\n            }\r\n\r\n            for (int wR = 0; wR < ${effectiveFilterHeight};\r\n                wR += ${dilationHeight}) {\r\n              int xR = xRCorner + wR;\r\n\r\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\r\n                continue;\r\n              }\r\n\r\n              for (int wC = 0; wC < ${effectiveFilterWidth};\r\n                  wC += ${dilationWidth}) {\r\n                int xC = xCCorner + wC;\r\n\r\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\r\n                  continue;\r\n                }\r\n\r\n                float value = getX(batch, xD, xR, xC, ch);\r\n\r\n                // If a min / max value has already been found, use it. If not,\r\n                // use the current value.\r\n                float currMinMaxValue = mix(\r\n                    value, minMaxValue, minMaxValueFound);\r\n                if (value ${compareOp} currMinMaxValue) {\r\n                  minMaxValue = value;\r\n                  minMaxValueFound = 1.0;\r\n                  minMaxPosition = ${flattenPositions ?\r\n                (includeBatchInIndex ?\r\n                    `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` :\r\n                    `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\r\n                `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\r\n                      wR * ${effectiveFilterWidth} + wC`};\r\n                }\r\n              }\r\n            }\r\n          }\r\n          setOutput(float(minMaxPosition));\r\n        }\r\n      `;\r\n            return;\r\n        }\r\n        const compareOp = 'max';\r\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\r\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\r\n        if (poolType === 'avg') {\r\n            returnValue = `avgValue / count`;\r\n        }\r\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\r\n        const filterWidthVec4Remainder = filterWidth % 4;\r\n        const updateSnippet = `\r\n      if (${isAvgPool}) {\r\n        avgValue += dot(values, ones);\r\n      } else {\r\n        minMaxValue = ${compareOp}(values, minMaxValue);\r\n      }\r\n    `;\r\n        this.userCode = `\r\n      const ivec3 strides =\r\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\r\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\r\n      const float initializationValue = ${initializationValue};\r\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\n      float count = 0.0;\r\n\r\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\r\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\r\n          return initializationValue;\r\n        }\r\n        count += 1.0;\r\n        return getX(batch, xD, xR, xC, ch);\r\n      }\r\n\r\n      void main() {\r\n        ivec5 coords = getOutputCoords();\r\n        int batch = coords.x;\r\n        int ch = coords.u;\r\n\r\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\r\n        int xDCorner = xCorner.x;\r\n        int xRCorner = xCorner.y;\r\n        int xCCorner = xCorner.z;\r\n\r\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\r\n        // ? = to be determined\r\n        vec4 minMaxValue = vec4(${initializationValue});\r\n        float avgValue = 0.0;\r\n        count = 0.0;\r\n\r\n        for (int wD = 0; wD < ${effectiveFilterDepth};\r\n            wD += ${dilationDepth}) {\r\n          int xD = xDCorner + wD;\r\n\r\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\r\n            continue;\r\n          }\r\n\r\n          for (int wR = 0; wR < ${effectiveFilterHeight};\r\n            wR += ${dilationHeight}) {\r\n            int xR = xRCorner + wR;\r\n\r\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\r\n              continue;\r\n            }\r\n\r\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\r\n              int xC = xCCorner + wC * ${dilationWidth};\r\n\r\n              vec4 values = vec4(\r\n                getValue(batch, xD, xR, xC, ch),\r\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\r\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\r\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\r\n              );\r\n\r\n              ${updateSnippet}\r\n            }\r\n\r\n            int xC = xCCorner + ${filterWidthNearestVec4};\r\n            if (${filterWidthVec4Remainder === 1}) {\r\n              vec4 values = vec4(\r\n                getValue(batch, xD, xR, xC, ch),\r\n                initializationValue,\r\n                initializationValue,\r\n                initializationValue\r\n              );\r\n\r\n              ${updateSnippet}\r\n            } else if (${filterWidthVec4Remainder === 2}) {\r\n              vec4 values = vec4(\r\n                getValue(batch, xD, xR, xC, ch),\r\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\r\n                initializationValue,\r\n                initializationValue\r\n              );\r\n\r\n              ${updateSnippet}\r\n            } else if (${filterWidthVec4Remainder === 3}) {\r\n              vec4 values = vec4(\r\n                getValue(batch, xD, xR, xC, ch),\r\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\r\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\r\n                initializationValue\r\n              );\r\n\r\n              ${updateSnippet}\r\n            }\r\n          }\r\n          setOutput(${returnValue});\r\n        }\r\n      }\r\n    `;\r\n    }\r\n}\r\n//# sourceMappingURL=pool_gpu.js.map"]},"metadata":{},"sourceType":"module"}