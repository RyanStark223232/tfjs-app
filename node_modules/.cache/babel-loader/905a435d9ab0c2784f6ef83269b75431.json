{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { isNode } from '../../utils/is';\nimport { escape, stringify } from '../../utils/string';\nimport { isSafeProperty } from '../../utils/customs';\nimport { hasOwnProperty } from '../../utils/object';\nimport { factory } from '../../utils/factory';\nvar name = 'ObjectNode';\nvar dependencies = ['Node'];\nexport var createObjectNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\r\n   * @constructor ObjectNode\r\n   * @extends {Node}\r\n   * Holds an object with keys/values\r\n   * @param {Object.<string, Node>} [properties]   object with key/value pairs\r\n   */\n\n  function ObjectNode(properties) {\n    if (!(this instanceof ObjectNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.properties = properties || {}; // validate input\n\n    if (properties) {\n      if (!(_typeof(properties) === 'object') || !Object.keys(properties).every(function (key) {\n        return isNode(properties[key]);\n      })) {\n        throw new TypeError('Object containing Nodes expected');\n      }\n    }\n  }\n\n  ObjectNode.prototype = new Node();\n  ObjectNode.prototype.type = 'ObjectNode';\n  ObjectNode.prototype.isObjectNode = true;\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\n\n  ObjectNode.prototype._compile = function (math, argNames) {\n    var evalEntries = {};\n\n    for (var key in this.properties) {\n      if (hasOwnProperty(this.properties, key)) {\n        // we stringify/parse the key here to resolve unicode characters,\n        // so you cannot create a key like {\"co\\\\u006Estructor\": null}\n        var stringifiedKey = stringify(key);\n        var parsedKey = JSON.parse(stringifiedKey);\n\n        if (!isSafeProperty(this.properties, parsedKey)) {\n          throw new Error('No access to property \"' + parsedKey + '\"');\n        }\n\n        evalEntries[parsedKey] = this.properties[key]._compile(math, argNames);\n      }\n    }\n\n    return function evalObjectNode(scope, args, context) {\n      var obj = {};\n\n      for (var _key in evalEntries) {\n        if (hasOwnProperty(evalEntries, _key)) {\n          obj[_key] = evalEntries[_key](scope, args, context);\n        }\n      }\n\n      return obj;\n    };\n  };\n  /**\r\n   * Execute a callback for each of the child nodes of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\n\n\n  ObjectNode.prototype.forEach = function (callback) {\n    for (var key in this.properties) {\n      if (hasOwnProperty(this.properties, key)) {\n        callback(this.properties[key], 'properties[' + stringify(key) + ']', this);\n      }\n    }\n  };\n  /**\r\n   * Create a new ObjectNode having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n   * @returns {ObjectNode} Returns a transformed copy of the node\r\n   */\n\n\n  ObjectNode.prototype.map = function (callback) {\n    var properties = {};\n\n    for (var key in this.properties) {\n      if (hasOwnProperty(this.properties, key)) {\n        properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));\n      }\n    }\n\n    return new ObjectNode(properties);\n  };\n  /**\r\n   * Create a clone of this node, a shallow copy\r\n   * @return {ObjectNode}\r\n   */\n\n\n  ObjectNode.prototype.clone = function () {\n    var properties = {};\n\n    for (var key in this.properties) {\n      if (hasOwnProperty(this.properties, key)) {\n        properties[key] = this.properties[key];\n      }\n    }\n\n    return new ObjectNode(properties);\n  };\n  /**\r\n   * Get string representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\n\n\n  ObjectNode.prototype._toString = function (options) {\n    var entries = [];\n\n    for (var key in this.properties) {\n      if (hasOwnProperty(this.properties, key)) {\n        entries.push(stringify(key) + ': ' + this.properties[key].toString(options));\n      }\n    }\n\n    return '{' + entries.join(', ') + '}';\n  };\n  /**\r\n   * Get a JSON representation of the node\r\n   * @returns {Object}\r\n   */\n\n\n  ObjectNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ObjectNode',\n      properties: this.properties\n    };\n  };\n  /**\r\n   * Instantiate an OperatorNode from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"ObjectNode\", \"properties\": {...}}`,\r\n   *                       where mathjs is optional\r\n   * @returns {ObjectNode}\r\n   */\n\n\n  ObjectNode.fromJSON = function (json) {\n    return new ObjectNode(json.properties);\n  };\n  /**\r\n   * Get HTML representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\n\n\n  ObjectNode.prototype.toHTML = function (options) {\n    var entries = [];\n\n    for (var key in this.properties) {\n      if (hasOwnProperty(this.properties, key)) {\n        entries.push('<span class=\"math-symbol math-property\">' + escape(key) + '</span>' + '<span class=\"math-operator math-assignment-operator math-property-assignment-operator math-binary-operator\">:</span>' + this.properties[key].toHTML(options));\n      }\n    }\n\n    return '<span class=\"math-parenthesis math-curly-parenthesis\">{</span>' + entries.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-curly-parenthesis\">}</span>';\n  };\n  /**\r\n   * Get LaTeX representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   */\n\n\n  ObjectNode.prototype._toTex = function (options) {\n    var entries = [];\n\n    for (var key in this.properties) {\n      if (hasOwnProperty(this.properties, key)) {\n        entries.push('\\\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\\\\\');\n      }\n    }\n\n    return \"\\\\left\\\\{\\\\begin{array}{ll}\".concat(entries.join('\\n'), \"\\\\end{array}\\\\right\\\\}\");\n  };\n\n  return ObjectNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/mathjs/es/expression/node/ObjectNode.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","isNode","escape","stringify","isSafeProperty","hasOwnProperty","factory","name","dependencies","createObjectNode","_ref","Node","ObjectNode","properties","SyntaxError","Object","keys","every","key","TypeError","type","isObjectNode","_compile","math","argNames","evalEntries","stringifiedKey","parsedKey","JSON","parse","Error","evalObjectNode","scope","args","context","_key","forEach","callback","map","_ifNode","clone","_toString","options","entries","push","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","isClass"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nimport { isNode } from '../../utils/is';\r\nimport { escape, stringify } from '../../utils/string';\r\nimport { isSafeProperty } from '../../utils/customs';\r\nimport { hasOwnProperty } from '../../utils/object';\r\nimport { factory } from '../../utils/factory';\r\nvar name = 'ObjectNode';\r\nvar dependencies = ['Node'];\r\nexport var createObjectNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\r\n  var Node = _ref.Node;\r\n\r\n  /**\r\n   * @constructor ObjectNode\r\n   * @extends {Node}\r\n   * Holds an object with keys/values\r\n   * @param {Object.<string, Node>} [properties]   object with key/value pairs\r\n   */\r\n  function ObjectNode(properties) {\r\n    if (!(this instanceof ObjectNode)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n\r\n    this.properties = properties || {}; // validate input\r\n\r\n    if (properties) {\r\n      if (!(_typeof(properties) === 'object') || !Object.keys(properties).every(function (key) {\r\n        return isNode(properties[key]);\r\n      })) {\r\n        throw new TypeError('Object containing Nodes expected');\r\n      }\r\n    }\r\n  }\r\n\r\n  ObjectNode.prototype = new Node();\r\n  ObjectNode.prototype.type = 'ObjectNode';\r\n  ObjectNode.prototype.isObjectNode = true;\r\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\r\n\r\n  ObjectNode.prototype._compile = function (math, argNames) {\r\n    var evalEntries = {};\r\n\r\n    for (var key in this.properties) {\r\n      if (hasOwnProperty(this.properties, key)) {\r\n        // we stringify/parse the key here to resolve unicode characters,\r\n        // so you cannot create a key like {\"co\\\\u006Estructor\": null}\r\n        var stringifiedKey = stringify(key);\r\n        var parsedKey = JSON.parse(stringifiedKey);\r\n\r\n        if (!isSafeProperty(this.properties, parsedKey)) {\r\n          throw new Error('No access to property \"' + parsedKey + '\"');\r\n        }\r\n\r\n        evalEntries[parsedKey] = this.properties[key]._compile(math, argNames);\r\n      }\r\n    }\r\n\r\n    return function evalObjectNode(scope, args, context) {\r\n      var obj = {};\r\n\r\n      for (var _key in evalEntries) {\r\n        if (hasOwnProperty(evalEntries, _key)) {\r\n          obj[_key] = evalEntries[_key](scope, args, context);\r\n        }\r\n      }\r\n\r\n      return obj;\r\n    };\r\n  };\r\n  /**\r\n   * Execute a callback for each of the child nodes of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\r\n\r\n\r\n  ObjectNode.prototype.forEach = function (callback) {\r\n    for (var key in this.properties) {\r\n      if (hasOwnProperty(this.properties, key)) {\r\n        callback(this.properties[key], 'properties[' + stringify(key) + ']', this);\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Create a new ObjectNode having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n   * @returns {ObjectNode} Returns a transformed copy of the node\r\n   */\r\n\r\n\r\n  ObjectNode.prototype.map = function (callback) {\r\n    var properties = {};\r\n\r\n    for (var key in this.properties) {\r\n      if (hasOwnProperty(this.properties, key)) {\r\n        properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));\r\n      }\r\n    }\r\n\r\n    return new ObjectNode(properties);\r\n  };\r\n  /**\r\n   * Create a clone of this node, a shallow copy\r\n   * @return {ObjectNode}\r\n   */\r\n\r\n\r\n  ObjectNode.prototype.clone = function () {\r\n    var properties = {};\r\n\r\n    for (var key in this.properties) {\r\n      if (hasOwnProperty(this.properties, key)) {\r\n        properties[key] = this.properties[key];\r\n      }\r\n    }\r\n\r\n    return new ObjectNode(properties);\r\n  };\r\n  /**\r\n   * Get string representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\r\n\r\n\r\n  ObjectNode.prototype._toString = function (options) {\r\n    var entries = [];\r\n\r\n    for (var key in this.properties) {\r\n      if (hasOwnProperty(this.properties, key)) {\r\n        entries.push(stringify(key) + ': ' + this.properties[key].toString(options));\r\n      }\r\n    }\r\n\r\n    return '{' + entries.join(', ') + '}';\r\n  };\r\n  /**\r\n   * Get a JSON representation of the node\r\n   * @returns {Object}\r\n   */\r\n\r\n\r\n  ObjectNode.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'ObjectNode',\r\n      properties: this.properties\r\n    };\r\n  };\r\n  /**\r\n   * Instantiate an OperatorNode from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"ObjectNode\", \"properties\": {...}}`,\r\n   *                       where mathjs is optional\r\n   * @returns {ObjectNode}\r\n   */\r\n\r\n\r\n  ObjectNode.fromJSON = function (json) {\r\n    return new ObjectNode(json.properties);\r\n  };\r\n  /**\r\n   * Get HTML representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\r\n\r\n\r\n  ObjectNode.prototype.toHTML = function (options) {\r\n    var entries = [];\r\n\r\n    for (var key in this.properties) {\r\n      if (hasOwnProperty(this.properties, key)) {\r\n        entries.push('<span class=\"math-symbol math-property\">' + escape(key) + '</span>' + '<span class=\"math-operator math-assignment-operator math-property-assignment-operator math-binary-operator\">:</span>' + this.properties[key].toHTML(options));\r\n      }\r\n    }\r\n\r\n    return '<span class=\"math-parenthesis math-curly-parenthesis\">{</span>' + entries.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-curly-parenthesis\">}</span>';\r\n  };\r\n  /**\r\n   * Get LaTeX representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   */\r\n\r\n\r\n  ObjectNode.prototype._toTex = function (options) {\r\n    var entries = [];\r\n\r\n    for (var key in this.properties) {\r\n      if (hasOwnProperty(this.properties, key)) {\r\n        entries.push('\\\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\\\\\');\r\n      }\r\n    }\r\n\r\n    return \"\\\\left\\\\{\\\\begin{array}{ll}\".concat(entries.join('\\n'), \"\\\\end{array}\\\\right\\\\}\");\r\n  };\r\n\r\n  return ObjectNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}