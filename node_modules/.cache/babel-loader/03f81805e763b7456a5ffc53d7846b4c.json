{"ast":null,"code":"import _classCallCheck from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nvar CHECK_NAN_SNIPPET = \"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\";\nexport var ADD = 'return a + b;';\nexport var SUB = 'return a - b;';\nexport var MUL = 'return a * b;'; // We use native integer division to deal with floating point imprecision. Since\n// we implement floor division and glsl implements truncated division, we\n// correct for this by subtracting 1 from result when the result is negative and\n// there is a remainder.\n\nexport var INT_DIV = \"\\n  float s = sign(a) * sign(b);\\n  int ia = round(a);\\n  int ib = round(b);\\n  if (ib != 0) {\\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\\n    return float(idiv(ia, ib, s));\\n  } else {\\n    return NAN;\\n  }\\n\";\nexport var POW = \"\\nif(a < 0.0 && floor(b) < b){\\n  return NAN;\\n}\\nif (b == 0.0) {\\n  return 1.0;\\n}\\nreturn (round(mod(b, 2.0)) != 1) ?\\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\\n\";\nexport var SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\nexport var EQUAL = \"return float(a == b);\";\nexport var NOT_EQUAL = \"return float(a != b);\";\nexport var LESS = \"return float(a < b);\";\nexport var LESS_EQUAL = \"return float(a <= b);\";\nexport var GREATER = \"return float(a > b);\";\nexport var GREATER_EQUAL = \"return float(a >= b);\";\nexport var LOGICAL_AND = \"return float(a >= 1.0 && b >= 1.0);\";\nexport var LOGICAL_OR = \"return float(a >= 1.0 || b >= 1.0);\";\nexport var MAX = CHECK_NAN_SNIPPET + \"\\n  return max(a, b);\\n\";\nexport var MIN = CHECK_NAN_SNIPPET + \"\\n  return min(a, b);\\n\";\nexport var MOD = \"if (b == 0.0) return NAN;\\n  return mod(a, b);\";\nexport var ELU_DER = \"return (b >= 1.0) ? a : a * (b + 1.0);\";\nexport var PRELU = \"return (a < 0.) ? b * a : a;\";\nexport var BinaryOpProgram = function BinaryOpProgram(op, aShape, bShape) {\n  _classCallCheck(this, BinaryOpProgram);\n\n  this.variableNames = ['A', 'B'];\n  this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n  this.userCode = \"\\n      float binaryOperation(float a, float b) {\\n        \".concat(op, \"\\n      }\\n\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        setOutput(binaryOperation(a, b));\\n      }\\n    \");\n};","map":{"version":3,"sources":["../src/binaryop_gpu.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,YAAR,QAA2B,uBAA3B;AAIA,IAAM,iBAAiB,6DAAvB;AAKA,OAAO,IAAM,GAAG,GAAG,eAAZ;AACP,OAAO,IAAM,GAAG,GAAG,eAAZ;AACP,OAAO,IAAM,GAAG,GAAG,eAAZ,C,CAEP;AACA;AACA;AACA;;AACA,OAAO,IAAM,OAAO,yPAAb;AAYP,OAAO,IAAM,GAAG,8KAAT;AAUP,OAAO,IAAM,kBAAkB,GAAG,2BAA3B;AAEP,OAAO,IAAM,KAAK,0BAAX;AAEP,OAAO,IAAM,SAAS,0BAAf;AAEP,OAAO,IAAM,IAAI,yBAAV;AAEP,OAAO,IAAM,UAAU,0BAAhB;AAEP,OAAO,IAAM,OAAO,yBAAb;AAEP,OAAO,IAAM,aAAa,0BAAnB;AAEP,OAAO,IAAM,WAAW,wCAAjB;AAEP,OAAO,IAAM,UAAU,wCAAhB;AAEP,OAAO,IAAM,GAAG,GAAG,iBAAiB,4BAA7B;AAGP,OAAO,IAAM,GAAG,GAAG,iBAAiB,4BAA7B;AAGP,OAAO,IAAM,GAAG,mDAAT;AAGP,OAAO,IAAM,OAAO,2CAAb;AAEP,OAAO,IAAM,KAAK,iCAAX;AAEP,WAAa,eAAb,GAKE,yBAAY,EAAZ,EAAwB,MAAxB,EAA0C,MAA1C,EAA0D;AAAA;;AAJ1D,OAAA,aAAA,GAAgB,CAAC,GAAD,EAAM,GAAN,CAAhB;AAKE,OAAK,WAAL,GAAmB,YAAY,CAAC,0BAAb,CAAwC,MAAxC,EAAgD,MAAhD,CAAnB;AACA,OAAK,QAAL,wEAEM,EAFN;AAWD,CAlBH","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { backend_util } from '@tensorflow/tfjs-core';\r\nconst CHECK_NAN_SNIPPET = `\r\n  if (isnan(a)) return a;\r\n  if (isnan(b)) return b;\r\n`;\r\nexport const ADD = 'return a + b;';\r\nexport const SUB = 'return a - b;';\r\nexport const MUL = 'return a * b;';\r\n// We use native integer division to deal with floating point imprecision. Since\r\n// we implement floor division and glsl implements truncated division, we\r\n// correct for this by subtracting 1 from result when the result is negative and\r\n// there is a remainder.\r\nexport const INT_DIV = `\r\n  float s = sign(a) * sign(b);\r\n  int ia = round(a);\r\n  int ib = round(b);\r\n  if (ib != 0) {\r\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\r\n    return float(idiv(ia, ib, s));\r\n  } else {\r\n    return NAN;\r\n  }\r\n`;\r\nexport const POW = `\r\nif(a < 0.0 && floor(b) < b){\r\n  return NAN;\r\n}\r\nif (b == 0.0) {\r\n  return 1.0;\r\n}\r\nreturn (round(mod(b, 2.0)) != 1) ?\r\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\r\n`;\r\nexport const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\r\nexport const EQUAL = `return float(a == b);`;\r\nexport const NOT_EQUAL = `return float(a != b);`;\r\nexport const LESS = `return float(a < b);`;\r\nexport const LESS_EQUAL = `return float(a <= b);`;\r\nexport const GREATER = `return float(a > b);`;\r\nexport const GREATER_EQUAL = `return float(a >= b);`;\r\nexport const LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;\r\nexport const LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;\r\nexport const MAX = CHECK_NAN_SNIPPET + `\r\n  return max(a, b);\r\n`;\r\nexport const MIN = CHECK_NAN_SNIPPET + `\r\n  return min(a, b);\r\n`;\r\nexport const MOD = `if (b == 0.0) return NAN;\r\n  return mod(a, b);`;\r\nexport const ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;\r\nexport const PRELU = `return (a < 0.) ? b * a : a;`;\r\nexport class BinaryOpProgram {\r\n    constructor(op, aShape, bShape) {\r\n        this.variableNames = ['A', 'B'];\r\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\r\n        this.userCode = `\r\n      float binaryOperation(float a, float b) {\r\n        ${op}\r\n      }\r\n\r\n      void main() {\r\n        float a = getAAtOutCoords();\r\n        float b = getBAtOutCoords();\r\n        setOutput(binaryOperation(a, b));\r\n      }\r\n    `;\r\n    }\r\n}\r\n//# sourceMappingURL=binaryop_gpu.js.map"]},"metadata":{},"sourceType":"module"}