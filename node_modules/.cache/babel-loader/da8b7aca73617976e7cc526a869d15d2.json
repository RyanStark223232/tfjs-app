{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\n\n/**\r\n * Returns the dimensions in the input shape that are broadcasted to\r\n * produce the provided output shape.\r\n *\r\n * The returned dimensions are 0-indexed and sorted. An example:\r\n * inShape = [4, 1, 3]\r\n * outShape = [5, 4, 3, 3]\r\n * result = [1]. Dimension 1 (2nd dimension of input) gets broadcasted 1 => 3.\r\n */\nexport function getBroadcastDims(inShape, outShape) {\n  var inRank = inShape.length;\n  var dims = [];\n\n  for (var i = 0; i < inRank; i++) {\n    var dim = inRank - 1 - i;\n    var a = inShape[dim] || 1;\n    var b = outShape[outShape.length - 1 - i] || 1;\n\n    if (b > 1 && a === 1) {\n      dims.unshift(dim);\n    }\n  }\n\n  return dims;\n}\n/**\r\n * Returns the axes in the output space that should be reduced to produce\r\n * the input space.\r\n */\n\nexport function getReductionAxes(inShape, outShape) {\n  var result = [];\n\n  for (var i = 0; i < outShape.length; i++) {\n    var inDim = inShape[inShape.length - i - 1];\n    var outAxis = outShape.length - i - 1;\n    var outDim = outShape[outAxis];\n\n    if (inDim == null || inDim === 1 && outDim > 1) {\n      result.unshift(outAxis);\n    }\n  }\n\n  return result;\n}\nexport function assertAndGetBroadcastShape(shapeA, shapeB) {\n  var result = [];\n  var l = Math.max(shapeA.length, shapeB.length);\n\n  for (var i = 0; i < l; i++) {\n    var a = shapeA[shapeA.length - i - 1];\n\n    if (a == null) {\n      a = 1;\n    }\n\n    var b = shapeB[shapeB.length - i - 1];\n\n    if (b == null) {\n      b = 1;\n    }\n\n    if (a === 1) {\n      result.unshift(b);\n    } else if (b === 1) {\n      result.unshift(a);\n    } else if (a !== b) {\n      var errMsg = \"Operands could not be broadcast together with shapes \" + \"\".concat(shapeA, \" and \").concat(shapeB, \".\");\n      throw Error(errMsg);\n    } else {\n      result.unshift(a);\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../src/ops/broadcast_util.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;;AAEH;;;;;;;;AAQG;AACH,OAAM,SAAU,gBAAV,CACF,OADE,EACiB,QADjB,EACmC;AACvC,MAAM,MAAM,GAAG,OAAO,CAAC,MAAvB;AACA,MAAM,IAAI,GAAa,EAAvB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAApB,EAA4B,CAAC,EAA7B,EAAiC;AAC/B,QAAM,GAAG,GAAG,MAAM,GAAG,CAAT,GAAa,CAAzB;AACA,QAAM,CAAC,GAAG,OAAO,CAAC,GAAD,CAAP,IAAgB,CAA1B;AACA,QAAM,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAT,GAAkB,CAAlB,GAAsB,CAAvB,CAAR,IAAqC,CAA/C;;AACA,QAAI,CAAC,GAAG,CAAJ,IAAS,CAAC,KAAK,CAAnB,EAAsB;AACpB,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb;AACD;AACF;;AACD,SAAO,IAAP;AACD;AAED;;;AAGG;;AACH,OAAM,SAAU,gBAAV,CACF,OADE,EACiB,QADjB,EACmC;AACvC,MAAM,MAAM,GAAa,EAAzB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACxC,QAAM,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAjB,GAAqB,CAAtB,CAArB;AACA,QAAM,OAAO,GAAG,QAAQ,CAAC,MAAT,GAAkB,CAAlB,GAAsB,CAAtC;AACA,QAAM,MAAM,GAAG,QAAQ,CAAC,OAAD,CAAvB;;AACA,QAAI,KAAK,IAAI,IAAT,IAAkB,KAAK,KAAK,CAAV,IAAe,MAAM,GAAG,CAA9C,EAAkD;AAChD,MAAA,MAAM,CAAC,OAAP,CAAe,OAAf;AACD;AACF;;AACD,SAAO,MAAP;AACD;AAED,OAAM,SAAU,0BAAV,CACF,MADE,EACgB,MADhB,EACgC;AACpC,MAAM,MAAM,GAAa,EAAzB;AACA,MAAM,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,MAAhB,EAAwB,MAAM,CAAC,MAA/B,CAAV;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AAC1B,QAAI,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,MAAP,GAAgB,CAAhB,GAAoB,CAArB,CAAd;;AACA,QAAI,CAAC,IAAI,IAAT,EAAe;AACb,MAAA,CAAC,GAAG,CAAJ;AACD;;AACD,QAAI,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,MAAP,GAAgB,CAAhB,GAAoB,CAArB,CAAd;;AACA,QAAI,CAAC,IAAI,IAAT,EAAe;AACb,MAAA,CAAC,GAAG,CAAJ;AACD;;AACD,QAAI,CAAC,KAAK,CAAV,EAAa;AACX,MAAA,MAAM,CAAC,OAAP,CAAe,CAAf;AACD,KAFD,MAEO,IAAI,CAAC,KAAK,CAAV,EAAa;AAClB,MAAA,MAAM,CAAC,OAAP,CAAe,CAAf;AACD,KAFM,MAEA,IAAI,CAAC,KAAK,CAAV,EAAa;AAClB,UAAM,MAAM,GAAG,oEACR,MADQ,kBACM,MADN,MAAf;AAEA,YAAM,KAAK,CAAC,MAAD,CAAX;AACD,KAJM,MAIA;AACL,MAAA,MAAM,CAAC,OAAP,CAAe,CAAf;AACD;AACF;;AACD,SAAO,MAAP;AACD","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n/**\r\n * Returns the dimensions in the input shape that are broadcasted to\r\n * produce the provided output shape.\r\n *\r\n * The returned dimensions are 0-indexed and sorted. An example:\r\n * inShape = [4, 1, 3]\r\n * outShape = [5, 4, 3, 3]\r\n * result = [1]. Dimension 1 (2nd dimension of input) gets broadcasted 1 => 3.\r\n */\r\nexport function getBroadcastDims(inShape, outShape) {\r\n    const inRank = inShape.length;\r\n    const dims = [];\r\n    for (let i = 0; i < inRank; i++) {\r\n        const dim = inRank - 1 - i;\r\n        const a = inShape[dim] || 1;\r\n        const b = outShape[outShape.length - 1 - i] || 1;\r\n        if (b > 1 && a === 1) {\r\n            dims.unshift(dim);\r\n        }\r\n    }\r\n    return dims;\r\n}\r\n/**\r\n * Returns the axes in the output space that should be reduced to produce\r\n * the input space.\r\n */\r\nexport function getReductionAxes(inShape, outShape) {\r\n    const result = [];\r\n    for (let i = 0; i < outShape.length; i++) {\r\n        const inDim = inShape[inShape.length - i - 1];\r\n        const outAxis = outShape.length - i - 1;\r\n        const outDim = outShape[outAxis];\r\n        if (inDim == null || (inDim === 1 && outDim > 1)) {\r\n            result.unshift(outAxis);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexport function assertAndGetBroadcastShape(shapeA, shapeB) {\r\n    const result = [];\r\n    const l = Math.max(shapeA.length, shapeB.length);\r\n    for (let i = 0; i < l; i++) {\r\n        let a = shapeA[shapeA.length - i - 1];\r\n        if (a == null) {\r\n            a = 1;\r\n        }\r\n        let b = shapeB[shapeB.length - i - 1];\r\n        if (b == null) {\r\n            b = 1;\r\n        }\r\n        if (a === 1) {\r\n            result.unshift(b);\r\n        }\r\n        else if (b === 1) {\r\n            result.unshift(a);\r\n        }\r\n        else if (a !== b) {\r\n            const errMsg = `Operands could not be broadcast together with shapes ` +\r\n                `${shapeA} and ${shapeB}.`;\r\n            throw Error(errMsg);\r\n        }\r\n        else {\r\n            result.unshift(a);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=broadcast_util.js.map"]},"metadata":{},"sourceType":"module"}