{"ast":null,"code":"import _classCallCheck from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nexport var SegmentOpProgram = function SegmentOpProgram(segOpInfo, segOpType) {\n  _classCallCheck(this, SegmentOpProgram);\n\n  this.variableNames = ['x', 'segmentIds'];\n  var windowSize = segOpInfo.windowSize;\n  var batchSize = segOpInfo.batchSize;\n  var inSize = segOpInfo.inSize;\n  var numSegments = segOpInfo.numSegments;\n  var outSize = numSegments * Math.ceil(inSize / windowSize);\n  this.outputShape = [batchSize, outSize];\n  var initializationValue = '0.0';\n  var returnValue = \"sumValue\";\n  var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n  var windowSizeVec4Remainder = windowSize % 4;\n  var updateSnippet = \"\\n        sumValue += dot(values, segFilter);\\n    \";\n  var checkValueOutOfBounds = '';\n\n  if (inSize % windowSize > 0) {\n    checkValueOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \".concat(inSize, \") {\\n          return initializationValue;\\n        }\\n      \");\n  }\n\n  var checkSegmentIdOutOfBounds = '';\n\n  if (inSize % windowSize > 0) {\n    checkSegmentIdOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \".concat(inSize, \") {\\n          return -1.0;\\n        }\\n      \");\n  }\n\n  this.userCode = \"\\n      const float initializationValue = \".concat(initializationValue, \";\\n\\n      float getValue(int batch, int inIdx) {\\n        \").concat(checkValueOutOfBounds, \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \").concat(checkSegmentIdOutOfBounds, \"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \").concat(numSegments, \")) * float(\").concat(windowSize, \"));\\n        int currentSeg = int(mod(float(outIdx), float(\").concat(numSegments, \")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \").concat(windowSizeNearestVec4, \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        }\\n\\n        int inIdx = inOffset + \").concat(windowSizeNearestVec4, \";\\n        if (\").concat(windowSizeVec4Remainder === 1, \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        } else if (\").concat(windowSizeVec4Remainder === 2, \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        } else if (\").concat(windowSizeVec4Remainder === 3, \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        }\\n        setOutput(\").concat(returnValue, \");\\n      }\\n    \");\n};","map":{"version":3,"sources":["../src/segment_gpu.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;AAeG;AAKH,WAAa,gBAAb,GAKE,0BACI,SADJ,EAEI,SAFJ,EAEmC;AAAA;;AANnC,OAAA,aAAA,GAAgB,CAAC,GAAD,EAAM,YAAN,CAAhB;AAOE,MAAM,UAAU,GAAG,SAAS,CAAC,UAA7B;AACA,MAAM,SAAS,GAAG,SAAS,CAAC,SAA5B;AACA,MAAM,MAAM,GAAG,SAAS,CAAC,MAAzB;AACA,MAAM,WAAW,GAAG,SAAS,CAAC,WAA9B;AACA,MAAM,OAAO,GAAG,WAAW,GAAG,IAAI,CAAC,IAAL,CAAU,MAAM,GAAG,UAAnB,CAA9B;AACA,OAAK,WAAL,GAAmB,CAAC,SAAD,EAAY,OAAZ,CAAnB;AAEA,MAAM,mBAAmB,GAAG,KAA5B;AACA,MAAM,WAAW,aAAjB;AAEA,MAAM,qBAAqB,GAAG,IAAI,CAAC,KAAL,CAAW,UAAU,GAAG,CAAxB,IAA6B,CAA3D;AACA,MAAM,uBAAuB,GAAG,UAAU,GAAG,CAA7C;AAEA,MAAM,aAAa,wDAAnB;AAIA,MAAI,qBAAqB,GAAG,EAA5B;;AACA,MAAI,MAAM,GAAG,UAAT,GAAsB,CAA1B,EAA6B;AAC3B,IAAA,qBAAqB,iDACS,MADT,kEAArB;AAKD;;AAED,MAAI,yBAAyB,GAAG,EAAhC;;AACA,MAAI,MAAM,GAAG,UAAT,GAAsB,CAA1B,EAA6B;AAC3B,IAAA,yBAAyB,iDACK,MADL,mDAAzB;AAKD;;AAED,OAAK,QAAL,uDACsC,mBADtC,wEAIM,qBAJN,oHASM,yBATN,oQAkBQ,WAlBR,wBAkBiC,UAlBjC,wEAmBoD,WAnBpD,kFAuB0B,qBAvB1B,omBAuCQ,aAvCR,2DA0C6B,qBA1C7B,4BA2CU,uBAAuB,KAAK,CA3CtC,ubA4DQ,aA5DR,kCA6DiB,uBAAuB,KAAK,CA7D7C,6bA4EQ,aA5ER,kCA6EiB,uBAAuB,KAAK,CA7E7C,wfA4FQ,aA5FR,4CA8FgB,WA9FhB;AAiGD,CA5IH","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nexport class SegmentOpProgram {\r\n    constructor(segOpInfo, segOpType) {\r\n        this.variableNames = ['x', 'segmentIds'];\r\n        const windowSize = segOpInfo.windowSize;\r\n        const batchSize = segOpInfo.batchSize;\r\n        const inSize = segOpInfo.inSize;\r\n        const numSegments = segOpInfo.numSegments;\r\n        const outSize = numSegments * Math.ceil(inSize / windowSize);\r\n        this.outputShape = [batchSize, outSize];\r\n        const initializationValue = '0.0';\r\n        const returnValue = `sumValue`;\r\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\r\n        const windowSizeVec4Remainder = windowSize % 4;\r\n        const updateSnippet = `\r\n        sumValue += dot(values, segFilter);\r\n    `;\r\n        let checkValueOutOfBounds = '';\r\n        if (inSize % windowSize > 0) {\r\n            checkValueOutOfBounds = `\r\n        if (inIdx < 0 || inIdx >= ${inSize}) {\r\n          return initializationValue;\r\n        }\r\n      `;\r\n        }\r\n        let checkSegmentIdOutOfBounds = '';\r\n        if (inSize % windowSize > 0) {\r\n            checkSegmentIdOutOfBounds = `\r\n        if (inIdx < 0 || inIdx >= ${inSize}) {\r\n          return -1.0;\r\n        }\r\n      `;\r\n        }\r\n        this.userCode = `\r\n      const float initializationValue = ${initializationValue};\r\n\r\n      float getValue(int batch, int inIdx) {\r\n        ${checkValueOutOfBounds}\r\n        return getX(batch, inIdx);\r\n      }\r\n\r\n      float getSegmentIdAtIndex(int inIdx) {\r\n        ${checkSegmentIdOutOfBounds}\r\n        return getSegmentIds(inIdx);\r\n      }\r\n\r\n      void main() {\r\n        ivec2 coords = getOutputCoords();\r\n        int batch = coords[0];\r\n        int outIdx = coords[1];\r\n        int inOffset = int(floor(float(outIdx) / float(\r\n          ${numSegments})) * float(${windowSize}));\r\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\r\n\r\n        float sumValue = 0.0;\r\n\r\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\r\n          int inIdx = inOffset + i;\r\n          vec4 values = vec4(\r\n            getValue(batch, inIdx),\r\n            getValue(batch, inIdx + 1),\r\n            getValue(batch, inIdx + 2),\r\n            getValue(batch, inIdx + 3)\r\n          );\r\n\r\n          vec4 segFilter = vec4(\r\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\r\n          );\r\n\r\n          ${updateSnippet}\r\n        }\r\n\r\n        int inIdx = inOffset + ${windowSizeNearestVec4};\r\n        if (${windowSizeVec4Remainder === 1}) {\r\n          vec4 values = vec4(\r\n            getValue(batch, inIdx),\r\n            initializationValue,\r\n            initializationValue,\r\n            initializationValue\r\n          );\r\n\r\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\r\n\r\n          vec4 segFilter = vec4(\r\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\r\n            0,\r\n            0,\r\n            0\r\n          );\r\n\r\n          ${updateSnippet}\r\n        } else if (${windowSizeVec4Remainder === 2}) {\r\n          vec4 values = vec4(\r\n            getValue(batch, inIdx),\r\n            getValue(batch, inIdx + 1),\r\n            initializationValue,\r\n            initializationValue\r\n          );\r\n\r\n          vec4 segFilter = vec4(\r\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\r\n              0,\r\n              0\r\n          );\r\n\r\n          ${updateSnippet}\r\n        } else if (${windowSizeVec4Remainder === 3}) {\r\n          vec4 values = vec4(\r\n            getValue(batch, inIdx),\r\n            getValue(batch, inIdx + 1),\r\n            getValue(batch, inIdx + 2),\r\n            initializationValue\r\n          );\r\n\r\n          vec4 segFilter = vec4(\r\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\r\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\r\n            0\r\n          );\r\n\r\n          ${updateSnippet}\r\n        }\r\n        setOutput(${returnValue});\r\n      }\r\n    `;\r\n    }\r\n}\r\n//# sourceMappingURL=segment_gpu.js.map"]},"metadata":{},"sourceType":"module"}