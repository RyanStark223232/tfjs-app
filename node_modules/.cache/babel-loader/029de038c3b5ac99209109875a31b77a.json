{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { TensorArray } from '../../executor/tensor_array';\nimport { fromTensor, reserve, scatter, split } from '../../executor/tensor_list';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport var executeOp = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(node, tensorMap, context) {\n    var thenFunc, elseFunc, cond, args, condValue, _ret, pred, _pred, data, inputName, _data, frameId, _data2, _data3, _data4, size, dtype, elementShape, dynamicSize, clearAfterRead, identicalElementShapes, name, tensorArray, id, index, writeTensor, writeTensorArray, readId, readIndex, readTensorArray, gatherId, gatherIndices, gatherDtype, gatherTensorArray, scatterId, scatterIndices, scatterTensor, scatterTensorArray, concatId, concatTensorArray, concatDtype, splitId, splitTensor, lengths, splitTensorArray, sizeId, sizeTensorArray, closeId, closeTensorArray, idTensor, _index, _writeTensor, tensorList, _idTensor, _readIndex, _elementShape, elementDType, _tensorList, _scatterIndices, _scatterTensor, _elementShape2, numElements, _tensorList2, _elementShape3, elementDtype, _numElements, _tensorList3, _gatherId, _gatherIndices, _elementShape4, _elementDtype, _tensorList4, _idTensor2, _elementShape5, _elementDtype2, _numElements2, _tensorList5, tensor, _elementShape6, _elementDtype3, _tensorList6, _concatId, _tensorList7, _concatDtype, _elementShape7, _idTensor3, _writeTensor2, _tensorList8, _idTensor4, _elementShape8, _elementDType, _tensorList9, _splitTensor, _elementShape9, _lengths, _tensorList10;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.t0 = node.op;\n            _context3.next = _context3.t0 === 'If' ? 3 : _context3.t0 === 'StatelessIf' ? 3 : _context3.t0 === 'While' ? 15 : _context3.t0 === 'StatelessWhile' ? 15 : _context3.t0 === 'LoopCond' ? 19 : _context3.t0 === 'Switch' ? 21 : _context3.t0 === 'Merge' ? 32 : _context3.t0 === 'Enter' ? 37 : _context3.t0 === 'Exit' ? 41 : _context3.t0 === 'NextIteration' ? 44 : _context3.t0 === 'TensorArrayV3' ? 47 : _context3.t0 === 'TensorArrayWriteV3' ? 57 : _context3.t0 === 'TensorArrayReadV3' ? 63 : _context3.t0 === 'TensorArrayGatherV3' ? 67 : _context3.t0 === 'TensorArrayScatterV3' ? 72 : _context3.t0 === 'TensorArrayConcatV3' ? 78 : _context3.t0 === 'TensorArraySplitV3' ? 82 : _context3.t0 === 'TensorArraySizeV3' ? 88 : _context3.t0 === 'TensorArrayCloseV3' ? 91 : _context3.t0 === 'TensorListSetItem' ? 95 : _context3.t0 === 'TensorListGetItem' ? 101 : _context3.t0 === 'TensorListScatterV2' ? 107 : _context3.t0 === 'TensorListScatter' ? 107 : _context3.t0 === 'TensorListReserve' ? 114 : _context3.t0 === 'TensorListGather' ? 120 : _context3.t0 === 'TensorListStack' ? 126 : _context3.t0 === 'TensorListFromTensor' ? 132 : _context3.t0 === 'TensorListConcat' ? 138 : _context3.t0 === 'TensorListPushBack' ? 143 : _context3.t0 === 'TensorListPopBack' ? 148 : _context3.t0 === 'TensorListSplit' ? 153 : 159;\n            break;\n\n          case 3:\n            thenFunc = getParamValue('thenBranch', node, tensorMap, context);\n            elseFunc = getParamValue('elseBranch', node, tensorMap, context);\n            cond = getParamValue('cond', node, tensorMap, context);\n            args = getParamValue('args', node, tensorMap, context);\n            _context3.next = 9;\n            return cond.data();\n\n          case 9:\n            condValue = _context3.sent;\n\n            if (!condValue[0]) {\n              _context3.next = 14;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap));\n\n          case 14:\n            return _context3.abrupt(\"return\", context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap));\n\n          case 15:\n            return _context3.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              var bodyFunc, condFunc, args, condResult, argIds, condValue, result, _loop;\n\n              return _regeneratorRuntime.wrap(function _callee$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                      bodyFunc = getParamValue('body', node, tensorMap, context);\n                      condFunc = getParamValue('cond', node, tensorMap, context);\n                      args = getParamValue('args', node, tensorMap, context); // Calculate the condition of the loop\n\n                      _context2.next = 5;\n                      return context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n\n                    case 5:\n                      condResult = _context2.sent;\n                      argIds = args.map(function (tensor) {\n                        return tensor.id;\n                      });\n                      _context2.next = 9;\n                      return condResult[0].data();\n\n                    case 9:\n                      condValue = _context2.sent;\n                      // Dispose the intermediate tensors for condition function\n                      condResult.forEach(function (tensor) {\n                        if (!tensor.kept && argIds.indexOf(tensor.id) === -1) {\n                          tensor.dispose();\n                        }\n                      });\n                      result = args;\n                      _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {\n                        var origResult, resultIds, condResult;\n                        return _regeneratorRuntime.wrap(function _loop$(_context) {\n                          while (1) {\n                            switch (_context.prev = _context.next) {\n                              case 0:\n                                // Record the previous result for intermediate tensor tracking\n                                origResult = result; // Execution the body of the loop\n\n                                _context.next = 3;\n                                return context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n\n                              case 3:\n                                result = _context.sent;\n                                resultIds = result.map(function (tensor) {\n                                  return tensor.id;\n                                }); // Dispose the intermediate tensor for body function that is not global\n                                // kept, not input/output of the body function\n\n                                origResult.forEach(function (tensor) {\n                                  if (!tensor.kept && argIds.indexOf(tensor.id) === -1 && resultIds.indexOf(tensor.id) === -1) {\n                                    tensor.dispose();\n                                  }\n                                }); // Recalcuate the condition of the loop using the latest results.\n\n                                _context.next = 8;\n                                return context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n\n                              case 8:\n                                condResult = _context.sent;\n                                _context.next = 11;\n                                return condResult[0].data();\n\n                              case 11:\n                                condValue = _context.sent;\n                                // Dispose the intermediate tensors for condition function\n                                condResult.forEach(function (tensor) {\n                                  if (!tensor.kept && argIds.indexOf(tensor.id) === -1 && resultIds.indexOf(tensor.id) === -1) {\n                                    tensor.dispose();\n                                  }\n                                });\n\n                              case 13:\n                              case \"end\":\n                                return _context.stop();\n                            }\n                          }\n                        }, _loop);\n                      });\n\n                    case 13:\n                      if (!condValue[0]) {\n                        _context2.next = 17;\n                        break;\n                      }\n\n                      return _context2.delegateYield(_loop(), \"t0\", 15);\n\n                    case 15:\n                      _context2.next = 13;\n                      break;\n\n                    case 17:\n                      return _context2.abrupt(\"return\", {\n                        v: result\n                      });\n\n                    case 18:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _callee);\n            })(), \"t1\", 16);\n\n          case 16:\n            _ret = _context3.t1;\n\n            if (!(typeof _ret === \"object\")) {\n              _context3.next = 19;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", _ret.v);\n\n          case 19:\n            pred = getParamValue('pred', node, tensorMap, context);\n            return _context3.abrupt(\"return\", [cloneTensor(pred)]);\n\n          case 21:\n            _pred = getParamValue('pred', node, tensorMap, context);\n            data = getParamValue('data', node, tensorMap, context);\n\n            if (!data.kept) {\n              data = cloneTensor(data);\n            } // Outputs nodes :0 => false, :1 => true\n\n\n            _context3.next = 26;\n            return _pred.data();\n\n          case 26:\n            if (!_context3.sent[0]) {\n              _context3.next = 30;\n              break;\n            }\n\n            _context3.t2 = [undefined, data];\n            _context3.next = 31;\n            break;\n\n          case 30:\n            _context3.t2 = [data, undefined];\n\n          case 31:\n            return _context3.abrupt(\"return\", _context3.t2);\n\n          case 32:\n            inputName = node.inputNames.find(function (name) {\n              return getTensor(name, tensorMap, context) !== undefined;\n            });\n\n            if (!inputName) {\n              _context3.next = 36;\n              break;\n            }\n\n            _data = getTensor(inputName, tensorMap, context);\n            return _context3.abrupt(\"return\", [cloneTensor(_data)]);\n\n          case 36:\n            return _context3.abrupt(\"return\", undefined);\n\n          case 37:\n            frameId = getParamValue('frameName', node, tensorMap, context);\n            _data2 = getParamValue('tensor', node, tensorMap, context);\n            context.enterFrame(frameId);\n            return _context3.abrupt(\"return\", [cloneTensor(_data2)]);\n\n          case 41:\n            _data3 = getParamValue('tensor', node, tensorMap, context);\n            context.exitFrame();\n            return _context3.abrupt(\"return\", [cloneTensor(_data3)]);\n\n          case 44:\n            _data4 = getParamValue('tensor', node, tensorMap, context);\n            context.nextIteration();\n            return _context3.abrupt(\"return\", [cloneTensor(_data4)]);\n\n          case 47:\n            size = getParamValue('size', node, tensorMap, context);\n            dtype = getParamValue('dtype', node, tensorMap, context);\n            elementShape = getParamValue('elementShape', node, tensorMap, context);\n            dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\n            clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\n            identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\n            name = getParamValue('name', node, tensorMap, context);\n            tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n            context.addTensorArray(tensorArray);\n            return _context3.abrupt(\"return\", [tensorArray.idTensor, scalar(1.0)]);\n\n          case 57:\n            id = getParamValue('tensorArrayId', node, tensorMap, context);\n            index = getParamValue('index', node, tensorMap, context);\n            writeTensor = getParamValue('tensor', node, tensorMap, context);\n            writeTensorArray = context.getTensorArray(id.id);\n            writeTensorArray.write(index, writeTensor);\n            return _context3.abrupt(\"return\", [writeTensorArray.idTensor]);\n\n          case 63:\n            readId = getParamValue('tensorArrayId', node, tensorMap, context);\n            readIndex = getParamValue('index', node, tensorMap, context);\n            readTensorArray = context.getTensorArray(readId.id);\n            return _context3.abrupt(\"return\", [readTensorArray.read(readIndex)]);\n\n          case 67:\n            gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\n            gatherIndices = getParamValue('indices', node, tensorMap, context);\n            gatherDtype = getParamValue('dtype', node, tensorMap, context);\n            gatherTensorArray = context.getTensorArray(gatherId.id);\n            return _context3.abrupt(\"return\", [gatherTensorArray.gather(gatherIndices, gatherDtype)]);\n\n          case 72:\n            scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\n            scatterIndices = getParamValue('indices', node, tensorMap, context);\n            scatterTensor = getParamValue('tensor', node, tensorMap, context);\n            scatterTensorArray = context.getTensorArray(scatterId.id);\n            scatterTensorArray.scatter(scatterIndices, scatterTensor);\n            return _context3.abrupt(\"return\", [scatterTensorArray.idTensor]);\n\n          case 78:\n            concatId = getParamValue('tensorArrayId', node, tensorMap, context);\n            concatTensorArray = context.getTensorArray(concatId.id);\n            concatDtype = getParamValue('dtype', node, tensorMap, context);\n            return _context3.abrupt(\"return\", [concatTensorArray.concat(concatDtype)]);\n\n          case 82:\n            splitId = getParamValue('tensorArrayId', node, tensorMap, context);\n            splitTensor = getParamValue('tensor', node, tensorMap, context);\n            lengths = getParamValue('lengths', node, tensorMap, context);\n            splitTensorArray = context.getTensorArray(splitId.id);\n            splitTensorArray.split(lengths, splitTensor);\n            return _context3.abrupt(\"return\", [splitTensorArray.idTensor]);\n\n          case 88:\n            sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\n            sizeTensorArray = context.getTensorArray(sizeId.id);\n            return _context3.abrupt(\"return\", [scalar(sizeTensorArray.size(), 'int32')]);\n\n          case 91:\n            closeId = getParamValue('tensorArrayId', node, tensorMap, context);\n            closeTensorArray = context.getTensorArray(closeId.id);\n            closeTensorArray.clearAndClose();\n            return _context3.abrupt(\"return\", [closeTensorArray.idTensor]);\n\n          case 95:\n            idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            _index = getParamValue('index', node, tensorMap, context);\n            _writeTensor = getParamValue('tensor', node, tensorMap, context);\n            tensorList = context.getTensorList(idTensor.id);\n            tensorList.setItem(_index, _writeTensor);\n            return _context3.abrupt(\"return\", [tensorList.idTensor]);\n\n          case 101:\n            _idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            _readIndex = getParamValue('index', node, tensorMap, context);\n            _elementShape = getParamValue('elementShape', node, tensorMap, context);\n            elementDType = getParamValue('elementDType', node, tensorMap, context);\n            _tensorList = context.getTensorList(_idTensor.id);\n            return _context3.abrupt(\"return\", [_tensorList.getItem(_readIndex, _elementShape, elementDType)]);\n\n          case 107:\n            _scatterIndices = getParamValue('indices', node, tensorMap, context);\n            _scatterTensor = getParamValue('tensor', node, tensorMap, context);\n            _elementShape2 = getParamValue('elementShape', node, tensorMap, context);\n            numElements = getParamValue('numElements', node, tensorMap, context);\n            _tensorList2 = scatter(_scatterTensor, _scatterIndices, _elementShape2, numElements);\n            context.addTensorList(_tensorList2);\n            return _context3.abrupt(\"return\", [_tensorList2.idTensor]);\n\n          case 114:\n            _elementShape3 = getParamValue('elementShape', node, tensorMap, context);\n            elementDtype = getParamValue('elementDType', node, tensorMap, context);\n            _numElements = getParamValue('numElements', node, tensorMap, context);\n            _tensorList3 = reserve(_elementShape3, elementDtype, _numElements);\n            context.addTensorList(_tensorList3);\n            return _context3.abrupt(\"return\", [_tensorList3.idTensor]);\n\n          case 120:\n            _gatherId = getParamValue('tensorListId', node, tensorMap, context);\n            _gatherIndices = getParamValue('indices', node, tensorMap, context);\n            _elementShape4 = getParamValue('elementShape', node, tensorMap, context);\n            _elementDtype = getParamValue('elementDType', node, tensorMap, context);\n            _tensorList4 = context.getTensorList(_gatherId.id);\n            return _context3.abrupt(\"return\", [_tensorList4.gather(_gatherIndices, _elementDtype, _elementShape4)]);\n\n          case 126:\n            _idTensor2 = getParamValue('tensorListId', node, tensorMap, context);\n            _elementShape5 = getParamValue('elementShape', node, tensorMap, context);\n            _elementDtype2 = getParamValue('elementDType', node, tensorMap, context);\n            _numElements2 = getParamValue('numElements', node, tensorMap, context);\n            _tensorList5 = context.getTensorList(_idTensor2.id);\n            return _context3.abrupt(\"return\", [_tensorList5.stack(_elementShape5, _elementDtype2, _numElements2)]);\n\n          case 132:\n            tensor = getParamValue('tensor', node, tensorMap, context);\n            _elementShape6 = getParamValue('elementShape', node, tensorMap, context);\n            _elementDtype3 = getParamValue('elementDType', node, tensorMap, context);\n            _tensorList6 = fromTensor(tensor, _elementShape6, _elementDtype3);\n            context.addTensorList(_tensorList6);\n            return _context3.abrupt(\"return\", [_tensorList6.idTensor]);\n\n          case 138:\n            _concatId = getParamValue('tensorListId', node, tensorMap, context);\n            _tensorList7 = context.getTensorList(_concatId.id);\n            _concatDtype = getParamValue('dtype', node, tensorMap, context);\n            _elementShape7 = getParamValue('elementShape', node, tensorMap, context);\n            return _context3.abrupt(\"return\", [_tensorList7.concat(_concatDtype, _elementShape7)]);\n\n          case 143:\n            _idTensor3 = getParamValue('tensorListId', node, tensorMap, context);\n            _writeTensor2 = getParamValue('tensor', node, tensorMap, context);\n            _tensorList8 = context.getTensorList(_idTensor3.id);\n\n            _tensorList8.pushBack(_writeTensor2);\n\n            return _context3.abrupt(\"return\", [_tensorList8.idTensor]);\n\n          case 148:\n            _idTensor4 = getParamValue('tensorListId', node, tensorMap, context);\n            _elementShape8 = getParamValue('elementShape', node, tensorMap, context);\n            _elementDType = getParamValue('elementDType', node, tensorMap, context);\n            _tensorList9 = context.getTensorList(_idTensor4.id);\n            return _context3.abrupt(\"return\", [_tensorList9.popBack(_elementShape8, _elementDType)]);\n\n          case 153:\n            _splitTensor = getParamValue('tensor', node, tensorMap, context);\n            _elementShape9 = getParamValue('elementShape', node, tensorMap, context);\n            _lengths = getParamValue('lengths', node, tensorMap, context);\n            _tensorList10 = split(_splitTensor, _lengths, _elementShape9);\n            context.addTensorList(_tensorList10);\n            return _context3.abrupt(\"return\", [_tensorList10.idTensor]);\n\n          case 159:\n            throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n\n          case 160:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function executeOp(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var CATEGORY = 'control';","map":{"version":3,"sources":["../../../src/operations/executors/control_executor.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAkB,MAAlB,QAAuC,uBAAvC;AAIA,SAAQ,WAAR,QAA0B,6BAA1B;AACA,SAAQ,UAAR,EAAoB,OAApB,EAA6B,OAA7B,EAAsC,KAAtC,QAAkD,4BAAlD;AAGA,SAAQ,WAAR,EAAqB,aAArB,EAAoC,SAApC,QAAoD,SAApD;AAEA,OAAO,IAAM,SAAS;AAAA,sEAA4B,kBAC9C,IAD8C,EAClC,SADkC,EAE9C,OAF8C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,2BAGxC,IAAI,CAAC,EAHmC;AAAA,8CAIzC,IAJyC,wBAKzC,aALyC,wBAqBzC,OArByC,yBAsBzC,gBAtByC,yBA4EzC,UA5EyC,yBAgFzC,QAhFyC,yBAyFzC,OAzFyC,yBAkGzC,OAlGyC,yBAyGzC,MAzGyC,yBA8GzC,eA9GyC,yBAmHzC,eAnHyC,yBAuIzC,oBAvIyC,yBAiJzC,mBAjJyC,yBAyJzC,qBAzJyC,yBAmKzC,sBAnKyC,yBA8KzC,qBA9KyC,yBAsLzC,oBAtLyC,yBAiMzC,mBAjMyC,yBAuMzC,oBAvMyC,yBA8MzC,mBA9MyC,yBAwNzC,mBAxNyC,0BAqOzC,qBArOyC,0BAsOzC,mBAtOyC,0BAoPzC,mBApPyC,0BA+PzC,kBA/PyC,0BA2QzC,iBA3QyC,0BAuRzC,sBAvRyC,0BAkSzC,kBAlSyC,0BA4SzC,oBA5SyC,0BAqTzC,mBArTyC,0BA+TzC,iBA/TyC;AAAA;;AAAA;AAMtC,YAAA,QANsC,GAOxC,aAAa,CAAC,YAAD,EAAe,IAAf,EAAqB,SAArB,EAAgC,OAAhC,CAP2B;AAQtC,YAAA,QARsC,GASxC,aAAa,CAAC,YAAD,EAAe,IAAf,EAAqB,SAArB,EAAgC,OAAhC,CAT2B;AAUtC,YAAA,IAVsC,GAU/B,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAVkB;AAWtC,YAAA,IAXsC,GAW/B,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAXkB;AAAA;AAAA,mBAYpB,IAAI,CAAC,IAAL,EAZoB;;AAAA;AAYtC,YAAA,SAZsC;;AAAA,iBAaxC,SAAS,CAAC,CAAD,CAb+B;AAAA;AAAA;AAAA;;AAAA,8CAcnC,OAAO,CAAC,WAAR,CAAoB,QAApB,EAA8B,oBAA9B,CACH,IADG,EACG,OAAO,CAAC,cADX,EAC2B,OAAO,CAAC,aADnC,CAdmC;;AAAA;AAAA,8CAiBnC,OAAO,CAAC,WAAR,CAAoB,QAApB,EAA8B,oBAA9B,CACH,IADG,EACG,OAAO,CAAC,cADX,EAC2B,OAAO,CAAC,aADnC,CAjBmC;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAuBtC,sBAAA,QAvBsC,GAwBxC,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAxB2B;AAyBtC,sBAAA,QAzBsC,GA0BxC,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CA1B2B;AA2BtC,sBAAA,IA3BsC,GA2B/B,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CA3BkB,EA6B5C;;AA7B4C;AAAA,6BA+BjC,OAAO,CAAC,WAAR,CAAoB,QAApB,EAA8B,oBAA9B,CACH,IADG,EACG,OAAO,CAAC,cADX,EAC2B,OAAO,CAAC,aADnC,CA/BiC;;AAAA;AA8BtC,sBAAA,UA9BsC;AAiCtC,sBAAA,MAjCsC,GAiC7B,IAAI,CAAC,GAAL,CAAS,UAAA,MAAM;AAAA,+BAAI,MAAM,CAAC,EAAX;AAAA,uBAAf,CAjC6B;AAAA;AAAA,6BAkCtB,UAAU,CAAC,CAAD,CAAV,CAAc,IAAd,EAlCsB;;AAAA;AAkCxC,sBAAA,SAlCwC;AAmC5C;AACA,sBAAA,UAAU,CAAC,OAAX,CAAmB,UAAA,MAAM,EAAG;AAC1B,4BAAI,CAAC,MAAM,CAAC,IAAR,IAAgB,MAAM,CAAC,OAAP,CAAe,MAAM,CAAC,EAAtB,MAA8B,CAAC,CAAnD,EAAsD;AACpD,0BAAA,MAAM,CAAC,OAAP;AACD;AACF,uBAJD;AAMI,sBAAA,MA1CwC,GA0CrB,IA1CqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6C1C;AACM,gCAAA,UA9CoC,GA8CvB,MA9CuB,EA+C1C;;AA/C0C;AAAA,uCAgD3B,OAAO,CAAC,WAAR,CAAoB,QAApB,EAA8B,oBAA9B,CACX,MADW,EACH,OAAO,CAAC,cADL,EACqB,OAAO,CAAC,aAD7B,CAhD2B;;AAAA;AAgD1C,gCAAA,MAhD0C;AAkDpC,gCAAA,SAlDoC,GAkDxB,MAAM,CAAC,GAAP,CAAW,UAAA,MAAM;AAAA,yCAAI,MAAM,CAAC,EAAX;AAAA,iCAAjB,CAlDwB,EAoD1C;AACA;;AACA,gCAAA,UAAU,CAAC,OAAX,CAAmB,UAAA,MAAM,EAAG;AAC1B,sCAAI,CAAC,MAAM,CAAC,IAAR,IAAgB,MAAM,CAAC,OAAP,CAAe,MAAM,CAAC,EAAtB,MAA8B,CAAC,CAA/C,IACA,SAAS,CAAC,OAAV,CAAkB,MAAM,CAAC,EAAzB,MAAiC,CAAC,CADtC,EACyC;AACvC,oCAAA,MAAM,CAAC,OAAP;AACD;AACF,iCALD,EAtD0C,CA6D1C;;AA7D0C;AAAA,uCA+D/B,OAAO,CAAC,WAAR,CAAoB,QAApB,EAA8B,oBAA9B,CACH,MADG,EACK,OAAO,CAAC,cADb,EAC6B,OAAO,CAAC,aADrC,CA/D+B;;AAAA;AA8DpC,gCAAA,UA9DoC;AAAA;AAAA,uCAiExB,UAAU,CAAC,CAAD,CAAV,CAAc,IAAd,EAjEwB;;AAAA;AAiE1C,gCAAA,SAjE0C;AAkE1C;AACA,gCAAA,UAAU,CAAC,OAAX,CAAmB,UAAA,MAAM,EAAG;AAC1B,sCAAI,CAAC,MAAM,CAAC,IAAR,IAAgB,MAAM,CAAC,OAAP,CAAe,MAAM,CAAC,EAAtB,MAA8B,CAAC,CAA/C,IACA,SAAS,CAAC,OAAV,CAAkB,MAAM,CAAC,EAAzB,MAAiC,CAAC,CADtC,EACyC;AACvC,oCAAA,MAAM,CAAC,OAAP;AACD;AACF,iCALD;;AAnE0C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,2BA4CrC,SAAS,CAAC,CAAD,CA5C4B;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,2BA0ErC;AA1EqC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AA6EtC,YAAA,IA7EsC,GA6E/B,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CA7EkB;AAAA,8CA8ErC,CAAC,WAAW,CAAC,IAAD,CAAZ,CA9EqC;;AAAA;AAiFtC,YAAA,KAjFsC,GAiF/B,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAjFkB;AAkFxC,YAAA,IAlFwC,GAkFjC,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAlFoB;;AAmF5C,gBAAI,CAAC,IAAI,CAAC,IAAV,EAAgB;AACd,cAAA,IAAI,GAAG,WAAW,CAAC,IAAD,CAAlB;AACD,aArF2C,CAsF5C;;;AAtF4C;AAAA,mBAuF9B,KAAI,CAAC,IAAL,EAvF8B;;AAAA;AAAA,gCAuFjB,CAvFiB;AAAA;AAAA;AAAA;;AAAA,2BAuFZ,CAAC,SAAD,EAAY,IAAZ,CAvFY;AAAA;AAAA;;AAAA;AAAA,2BAuFQ,CAAC,IAAD,EAAO,SAAP,CAvFR;;AAAA;AAAA;;AAAA;AA0FtC,YAAA,SA1FsC,GA0F1B,IAAI,CAAC,UAAL,CAAgB,IAAhB,CACd,UAAA,IAAI;AAAA,qBAAI,SAAS,CAAC,IAAD,EAAO,SAAP,EAAkB,OAAlB,CAAT,KAAwC,SAA5C;AAAA,aADU,CA1F0B;;AAAA,iBA4FxC,SA5FwC;AAAA;AAAA;AAAA;;AA6FpC,YAAA,KA7FoC,GA6F7B,SAAS,CAAC,SAAD,EAAY,SAAZ,EAAuB,OAAvB,CA7FoB;AAAA,8CA8FnC,CAAC,WAAW,CAAC,KAAD,CAAZ,CA9FmC;;AAAA;AAAA,8CAgGrC,SAhGqC;;AAAA;AAmGtC,YAAA,OAnGsC,GAoGxC,aAAa,CAAC,WAAD,EAAc,IAAd,EAAoB,SAApB,EAA+B,OAA/B,CApG2B;AAqGtC,YAAA,MArGsC,GAqG/B,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CArGkB;AAsG5C,YAAA,OAAO,CAAC,UAAR,CAAmB,OAAnB;AAtG4C,8CAuGrC,CAAC,WAAW,CAAC,MAAD,CAAZ,CAvGqC;;AAAA;AA0GtC,YAAA,MA1GsC,GA0G/B,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CA1GkB;AA2G5C,YAAA,OAAO,CAAC,SAAR;AA3G4C,8CA4GrC,CAAC,WAAW,CAAC,MAAD,CAAZ,CA5GqC;;AAAA;AA+GtC,YAAA,MA/GsC,GA+G/B,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CA/GkB;AAgH5C,YAAA,OAAO,CAAC,aAAR;AAhH4C,8CAiHrC,CAAC,WAAW,CAAC,MAAD,CAAZ,CAjHqC;;AAAA;AAoHtC,YAAA,IApHsC,GAoH/B,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CApHkB;AAqHtC,YAAA,KArHsC,GAsHxC,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CAtH2B;AAuHtC,YAAA,YAvHsC,GAwHxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAxH2B;AAyHtC,YAAA,WAzHsC,GA0HxC,aAAa,CAAC,aAAD,EAAgB,IAAhB,EAAsB,SAAtB,EAAiC,OAAjC,CA1H2B;AA2HtC,YAAA,cA3HsC,GA4HxC,aAAa,CAAC,gBAAD,EAAmB,IAAnB,EAAyB,SAAzB,EAAoC,OAApC,CA5H2B;AA6HtC,YAAA,sBA7HsC,GA8HxC,aAAa,CAAC,wBAAD,EAA2B,IAA3B,EAAiC,SAAjC,EAA4C,OAA5C,CA9H2B;AAgItC,YAAA,IAhIsC,GAgI/B,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAhIkB;AAiItC,YAAA,WAjIsC,GAiIxB,IAAI,WAAJ,CAChB,IADgB,EACV,KADU,EACH,IADG,EACG,YADH,EACiB,sBADjB,EACyC,WADzC,EAEhB,cAFgB,CAjIwB;AAoI5C,YAAA,OAAO,CAAC,cAAR,CAAuB,WAAvB;AApI4C,8CAqIrC,CAAC,WAAW,CAAC,QAAb,EAAuB,MAAM,CAAC,GAAD,CAA7B,CArIqC;;AAAA;AAwItC,YAAA,EAxIsC,GAyIxC,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CAzI2B;AA0ItC,YAAA,KA1IsC,GA0I9B,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CA1IiB;AA2ItC,YAAA,WA3IsC,GA4IxC,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CA5I2B;AA6ItC,YAAA,gBA7IsC,GA6InB,OAAO,CAAC,cAAR,CAAuB,EAAE,CAAC,EAA1B,CA7ImB;AA8I5C,YAAA,gBAAgB,CAAC,KAAjB,CAAuB,KAAvB,EAA8B,WAA9B;AA9I4C,8CA+IrC,CAAC,gBAAgB,CAAC,QAAlB,CA/IqC;;AAAA;AAkJtC,YAAA,MAlJsC,GAmJxC,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CAnJ2B;AAoJtC,YAAA,SApJsC,GAqJxC,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CArJ2B;AAsJtC,YAAA,eAtJsC,GAsJpB,OAAO,CAAC,cAAR,CAAuB,MAAM,CAAC,EAA9B,CAtJoB;AAAA,8CAuJrC,CAAC,eAAe,CAAC,IAAhB,CAAqB,SAArB,CAAD,CAvJqC;;AAAA;AA0JtC,YAAA,QA1JsC,GA2JxC,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CA3J2B;AA4JtC,YAAA,aA5JsC,GA6JxC,aAAa,CAAC,SAAD,EAAY,IAAZ,EAAkB,SAAlB,EAA6B,OAA7B,CA7J2B;AA8JtC,YAAA,WA9JsC,GA+JxC,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CA/J2B;AAgKtC,YAAA,iBAhKsC,GAgKlB,OAAO,CAAC,cAAR,CAAuB,QAAQ,CAAC,EAAhC,CAhKkB;AAAA,8CAiKrC,CAAC,iBAAiB,CAAC,MAAlB,CAAyB,aAAzB,EAAwC,WAAxC,CAAD,CAjKqC;;AAAA;AAoKtC,YAAA,SApKsC,GAqKxC,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CArK2B;AAsKtC,YAAA,cAtKsC,GAuKxC,aAAa,CAAC,SAAD,EAAY,IAAZ,EAAkB,SAAlB,EAA6B,OAA7B,CAvK2B;AAwKtC,YAAA,aAxKsC,GAyKxC,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CAzK2B;AA0KtC,YAAA,kBA1KsC,GA0KjB,OAAO,CAAC,cAAR,CAAuB,SAAS,CAAC,EAAjC,CA1KiB;AA2K5C,YAAA,kBAAkB,CAAC,OAAnB,CAA2B,cAA3B,EAA2C,aAA3C;AA3K4C,8CA4KrC,CAAC,kBAAkB,CAAC,QAApB,CA5KqC;;AAAA;AA+KtC,YAAA,QA/KsC,GAgLxC,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CAhL2B;AAiLtC,YAAA,iBAjLsC,GAiLlB,OAAO,CAAC,cAAR,CAAuB,QAAQ,CAAC,EAAhC,CAjLkB;AAkLtC,YAAA,WAlLsC,GAmLxC,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CAnL2B;AAAA,8CAoLrC,CAAC,iBAAiB,CAAC,MAAlB,CAAyB,WAAzB,CAAD,CApLqC;;AAAA;AAuLtC,YAAA,OAvLsC,GAwLxC,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CAxL2B;AAyLtC,YAAA,WAzLsC,GA0LxC,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CA1L2B;AA2LtC,YAAA,OA3LsC,GA4LxC,aAAa,CAAC,SAAD,EAAY,IAAZ,EAAkB,SAAlB,EAA6B,OAA7B,CA5L2B;AA6LtC,YAAA,gBA7LsC,GA6LnB,OAAO,CAAC,cAAR,CAAuB,OAAO,CAAC,EAA/B,CA7LmB;AA8L5C,YAAA,gBAAgB,CAAC,KAAjB,CAAuB,OAAvB,EAAgC,WAAhC;AA9L4C,8CA+LrC,CAAC,gBAAgB,CAAC,QAAlB,CA/LqC;;AAAA;AAkMtC,YAAA,MAlMsC,GAmMxC,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CAnM2B;AAoMtC,YAAA,eApMsC,GAoMpB,OAAO,CAAC,cAAR,CAAuB,MAAM,CAAC,EAA9B,CApMoB;AAAA,8CAqMrC,CAAC,MAAM,CAAC,eAAe,CAAC,IAAhB,EAAD,EAAyB,OAAzB,CAAP,CArMqC;;AAAA;AAwMtC,YAAA,OAxMsC,GAyMxC,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CAzM2B;AA0MtC,YAAA,gBA1MsC,GA0MnB,OAAO,CAAC,cAAR,CAAuB,OAAO,CAAC,EAA/B,CA1MmB;AA2M5C,YAAA,gBAAgB,CAAC,aAAjB;AA3M4C,8CA4MrC,CAAC,gBAAgB,CAAC,QAAlB,CA5MqC;;AAAA;AA+MtC,YAAA,QA/MsC,GAgNxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAhN2B;AAiNtC,YAAA,MAjNsC,GAiN9B,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CAjNiB;AAkNtC,YAAA,YAlNsC,GAmNxC,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CAnN2B;AAoNtC,YAAA,UApNsC,GAoNzB,OAAO,CAAC,aAAR,CAAsB,QAAQ,CAAC,EAA/B,CApNyB;AAqN5C,YAAA,UAAU,CAAC,OAAX,CAAmB,MAAnB,EAA0B,YAA1B;AArN4C,8CAsNrC,CAAC,UAAU,CAAC,QAAZ,CAtNqC;;AAAA;AAyNtC,YAAA,SAzNsC,GA0NxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CA1N2B;AA2NtC,YAAA,UA3NsC,GA4NxC,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CA5N2B;AA6NtC,YAAA,aA7NsC,GA8NxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CA9N2B;AAgOtC,YAAA,YAhOsC,GAiOxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAjO2B;AAkOtC,YAAA,WAlOsC,GAkOzB,OAAO,CAAC,aAAR,CAAsB,SAAQ,CAAC,EAA/B,CAlOyB;AAAA,8CAmOrC,CAAC,WAAU,CAAC,OAAX,CAAmB,UAAnB,EAA8B,aAA9B,EAA4C,YAA5C,CAAD,CAnOqC;;AAAA;AAuOtC,YAAA,eAvOsC,GAwOxC,aAAa,CAAC,SAAD,EAAY,IAAZ,EAAkB,SAAlB,EAA6B,OAA7B,CAxO2B;AAyOtC,YAAA,cAzOsC,GA0OxC,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CA1O2B;AA2OtC,YAAA,cA3OsC,GA4OxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CA5O2B;AA6OtC,YAAA,WA7OsC,GA8OxC,aAAa,CAAC,aAAD,EAAgB,IAAhB,EAAsB,SAAtB,EAAiC,OAAjC,CA9O2B;AA+OtC,YAAA,YA/OsC,GAgPxC,OAAO,CAAC,cAAD,EAAgB,eAAhB,EAAgC,cAAhC,EAA8C,WAA9C,CAhPiC;AAiP5C,YAAA,OAAO,CAAC,aAAR,CAAsB,YAAtB;AAjP4C,8CAkPrC,CAAC,YAAU,CAAC,QAAZ,CAlPqC;;AAAA;AAqPtC,YAAA,cArPsC,GAsPxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAtP2B;AAuPtC,YAAA,YAvPsC,GAwPxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAxP2B;AAyPtC,YAAA,YAzPsC,GA0PxC,aAAa,CAAC,aAAD,EAAgB,IAAhB,EAAsB,SAAtB,EAAiC,OAAjC,CA1P2B;AA2PtC,YAAA,YA3PsC,GA2PzB,OAAO,CAAC,cAAD,EAAe,YAAf,EAA6B,YAA7B,CA3PkB;AA4P5C,YAAA,OAAO,CAAC,aAAR,CAAsB,YAAtB;AA5P4C,8CA6PrC,CAAC,YAAU,CAAC,QAAZ,CA7PqC;;AAAA;AAgQtC,YAAA,SAhQsC,GAiQxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAjQ2B;AAkQtC,YAAA,cAlQsC,GAmQxC,aAAa,CAAC,SAAD,EAAY,IAAZ,EAAkB,SAAlB,EAA6B,OAA7B,CAnQ2B;AAoQtC,YAAA,cApQsC,GAqQxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CArQ2B;AAsQtC,YAAA,aAtQsC,GAuQxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAvQ2B;AAwQtC,YAAA,YAxQsC,GAwQzB,OAAO,CAAC,aAAR,CAAsB,SAAQ,CAAC,EAA/B,CAxQyB;AAAA,8CAyQrC,CAAC,YAAU,CAAC,MAAX,CAAkB,cAAlB,EAAiC,aAAjC,EAA+C,cAA/C,CAAD,CAzQqC;;AAAA;AA4QtC,YAAA,UA5QsC,GA6QxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CA7Q2B;AA8QtC,YAAA,cA9QsC,GA+QxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CA/Q2B;AAgRtC,YAAA,cAhRsC,GAiRxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAjR2B;AAkRtC,YAAA,aAlRsC,GAmRxC,aAAa,CAAC,aAAD,EAAgB,IAAhB,EAAsB,SAAtB,EAAiC,OAAjC,CAnR2B;AAoRtC,YAAA,YApRsC,GAoRzB,OAAO,CAAC,aAAR,CAAsB,UAAQ,CAAC,EAA/B,CApRyB;AAAA,8CAqRrC,CAAC,YAAU,CAAC,KAAX,CAAiB,cAAjB,EAA+B,cAA/B,EAA6C,aAA7C,CAAD,CArRqC;;AAAA;AAwRtC,YAAA,MAxRsC,GAyRxC,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CAzR2B;AA0RtC,YAAA,cA1RsC,GA2RxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CA3R2B;AA4RtC,YAAA,cA5RsC,GA6RxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CA7R2B;AA8RtC,YAAA,YA9RsC,GA8RzB,UAAU,CAAC,MAAD,EAAS,cAAT,EAAuB,cAAvB,CA9Re;AA+R5C,YAAA,OAAO,CAAC,aAAR,CAAsB,YAAtB;AA/R4C,8CAgSrC,CAAC,YAAU,CAAC,QAAZ,CAhSqC;;AAAA;AAmStC,YAAA,SAnSsC,GAoSxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CApS2B;AAqStC,YAAA,YArSsC,GAqSzB,OAAO,CAAC,aAAR,CAAsB,SAAQ,CAAC,EAA/B,CArSyB;AAsStC,YAAA,YAtSsC,GAuSxC,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CAvS2B;AAwStC,YAAA,cAxSsC,GAySxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAzS2B;AAAA,8CA0SrC,CAAC,YAAU,CAAC,MAAX,CAAkB,YAAlB,EAA+B,cAA/B,CAAD,CA1SqC;;AAAA;AA6StC,YAAA,UA7SsC,GA8SxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CA9S2B;AA+StC,YAAA,aA/SsC,GAgTxC,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CAhT2B;AAiTtC,YAAA,YAjTsC,GAiTzB,OAAO,CAAC,aAAR,CAAsB,UAAQ,CAAC,EAA/B,CAjTyB;;AAkT5C,YAAA,YAAU,CAAC,QAAX,CAAoB,aAApB;;AAlT4C,8CAmTrC,CAAC,YAAU,CAAC,QAAZ,CAnTqC;;AAAA;AAsTtC,YAAA,UAtTsC,GAuTxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAvT2B;AAwTtC,YAAA,cAxTsC,GAyTxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAzT2B;AA0TtC,YAAA,aA1TsC,GA2TxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CA3T2B;AA4TtC,YAAA,YA5TsC,GA4TzB,OAAO,CAAC,aAAR,CAAsB,UAAQ,CAAC,EAA/B,CA5TyB;AAAA,8CA6TrC,CAAC,YAAU,CAAC,OAAX,CAAmB,cAAnB,EAAiC,aAAjC,CAAD,CA7TqC;;AAAA;AAgUtC,YAAA,YAhUsC,GAiUxC,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CAjU2B;AAkUtC,YAAA,cAlUsC,GAmUxC,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CAnU2B;AAoUtC,YAAA,QApUsC,GAqUxC,aAAa,CAAC,SAAD,EAAY,IAAZ,EAAkB,SAAlB,EAA6B,OAA7B,CArU2B;AAuUtC,YAAA,aAvUsC,GAuUzB,KAAK,CAAC,YAAD,EAAc,QAAd,EAAuB,cAAvB,CAvUoB;AAwU5C,YAAA,OAAO,CAAC,aAAR,CAAsB,aAAtB;AAxU4C,8CAyUrC,CAAC,aAAU,CAAC,QAAZ,CAzUqC;;AAAA;AAAA,kBA4UtC,SAAS,qBAAc,IAAI,CAAC,EAAnB,yBA5U6B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAA5B;;AAAA,kBAAT,SAAS;AAAA;AAAA;AAAA,GAAf;AAgVP,OAAO,IAAM,QAAQ,GAAG,SAAjB","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { scalar } from '@tensorflow/tfjs-core';\r\nimport { TensorArray } from '../../executor/tensor_array';\r\nimport { fromTensor, reserve, scatter, split } from '../../executor/tensor_list';\r\nimport { cloneTensor, getParamValue, getTensor } from './utils';\r\nexport const executeOp = async (node, tensorMap, context) => {\r\n    switch (node.op) {\r\n        case 'If':\r\n        case 'StatelessIf': {\r\n            const thenFunc = getParamValue('thenBranch', node, tensorMap, context);\r\n            const elseFunc = getParamValue('elseBranch', node, tensorMap, context);\r\n            const cond = getParamValue('cond', node, tensorMap, context);\r\n            const args = getParamValue('args', node, tensorMap, context);\r\n            const condValue = await cond.data();\r\n            if (condValue[0]) {\r\n                return context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\r\n            }\r\n            else {\r\n                return context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\r\n            }\r\n        }\r\n        case 'While':\r\n        case 'StatelessWhile': {\r\n            const bodyFunc = getParamValue('body', node, tensorMap, context);\r\n            const condFunc = getParamValue('cond', node, tensorMap, context);\r\n            const args = getParamValue('args', node, tensorMap, context);\r\n            // Calculate the condition of the loop\r\n            const condResult = (await context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap));\r\n            const argIds = args.map(tensor => tensor.id);\r\n            let condValue = await condResult[0].data();\r\n            // Dispose the intermediate tensors for condition function\r\n            condResult.forEach(tensor => {\r\n                if (!tensor.kept && argIds.indexOf(tensor.id) === -1) {\r\n                    tensor.dispose();\r\n                }\r\n            });\r\n            let result = args;\r\n            while (condValue[0]) {\r\n                // Record the previous result for intermediate tensor tracking\r\n                const origResult = result;\r\n                // Execution the body of the loop\r\n                result = await context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\r\n                const resultIds = result.map(tensor => tensor.id);\r\n                // Dispose the intermediate tensor for body function that is not global\r\n                // kept, not input/output of the body function\r\n                origResult.forEach(tensor => {\r\n                    if (!tensor.kept && argIds.indexOf(tensor.id) === -1 &&\r\n                        resultIds.indexOf(tensor.id) === -1) {\r\n                        tensor.dispose();\r\n                    }\r\n                });\r\n                // Recalcuate the condition of the loop using the latest results.\r\n                const condResult = (await context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap));\r\n                condValue = await condResult[0].data();\r\n                // Dispose the intermediate tensors for condition function\r\n                condResult.forEach(tensor => {\r\n                    if (!tensor.kept && argIds.indexOf(tensor.id) === -1 &&\r\n                        resultIds.indexOf(tensor.id) === -1) {\r\n                        tensor.dispose();\r\n                    }\r\n                });\r\n            }\r\n            return result;\r\n        }\r\n        case 'LoopCond': {\r\n            const pred = getParamValue('pred', node, tensorMap, context);\r\n            return [cloneTensor(pred)];\r\n        }\r\n        case 'Switch': {\r\n            const pred = getParamValue('pred', node, tensorMap, context);\r\n            let data = getParamValue('data', node, tensorMap, context);\r\n            if (!data.kept) {\r\n                data = cloneTensor(data);\r\n            }\r\n            // Outputs nodes :0 => false, :1 => true\r\n            return (await pred.data())[0] ? [undefined, data] : [data, undefined];\r\n        }\r\n        case 'Merge': {\r\n            const inputName = node.inputNames.find(name => getTensor(name, tensorMap, context) !== undefined);\r\n            if (inputName) {\r\n                const data = getTensor(inputName, tensorMap, context);\r\n                return [cloneTensor(data)];\r\n            }\r\n            return undefined;\r\n        }\r\n        case 'Enter': {\r\n            const frameId = getParamValue('frameName', node, tensorMap, context);\r\n            const data = getParamValue('tensor', node, tensorMap, context);\r\n            context.enterFrame(frameId);\r\n            return [cloneTensor(data)];\r\n        }\r\n        case 'Exit': {\r\n            const data = getParamValue('tensor', node, tensorMap, context);\r\n            context.exitFrame();\r\n            return [cloneTensor(data)];\r\n        }\r\n        case 'NextIteration': {\r\n            const data = getParamValue('tensor', node, tensorMap, context);\r\n            context.nextIteration();\r\n            return [cloneTensor(data)];\r\n        }\r\n        case 'TensorArrayV3': {\r\n            const size = getParamValue('size', node, tensorMap, context);\r\n            const dtype = getParamValue('dtype', node, tensorMap, context);\r\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\r\n            const dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\r\n            const clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\r\n            const identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\r\n            const name = getParamValue('name', node, tensorMap, context);\r\n            const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\r\n            context.addTensorArray(tensorArray);\r\n            return [tensorArray.idTensor, scalar(1.0)];\r\n        }\r\n        case 'TensorArrayWriteV3': {\r\n            const id = getParamValue('tensorArrayId', node, tensorMap, context);\r\n            const index = getParamValue('index', node, tensorMap, context);\r\n            const writeTensor = getParamValue('tensor', node, tensorMap, context);\r\n            const writeTensorArray = context.getTensorArray(id.id);\r\n            writeTensorArray.write(index, writeTensor);\r\n            return [writeTensorArray.idTensor];\r\n        }\r\n        case 'TensorArrayReadV3': {\r\n            const readId = getParamValue('tensorArrayId', node, tensorMap, context);\r\n            const readIndex = getParamValue('index', node, tensorMap, context);\r\n            const readTensorArray = context.getTensorArray(readId.id);\r\n            return [readTensorArray.read(readIndex)];\r\n        }\r\n        case 'TensorArrayGatherV3': {\r\n            const gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\r\n            const gatherIndices = getParamValue('indices', node, tensorMap, context);\r\n            const gatherDtype = getParamValue('dtype', node, tensorMap, context);\r\n            const gatherTensorArray = context.getTensorArray(gatherId.id);\r\n            return [gatherTensorArray.gather(gatherIndices, gatherDtype)];\r\n        }\r\n        case 'TensorArrayScatterV3': {\r\n            const scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\r\n            const scatterIndices = getParamValue('indices', node, tensorMap, context);\r\n            const scatterTensor = getParamValue('tensor', node, tensorMap, context);\r\n            const scatterTensorArray = context.getTensorArray(scatterId.id);\r\n            scatterTensorArray.scatter(scatterIndices, scatterTensor);\r\n            return [scatterTensorArray.idTensor];\r\n        }\r\n        case 'TensorArrayConcatV3': {\r\n            const concatId = getParamValue('tensorArrayId', node, tensorMap, context);\r\n            const concatTensorArray = context.getTensorArray(concatId.id);\r\n            const concatDtype = getParamValue('dtype', node, tensorMap, context);\r\n            return [concatTensorArray.concat(concatDtype)];\r\n        }\r\n        case 'TensorArraySplitV3': {\r\n            const splitId = getParamValue('tensorArrayId', node, tensorMap, context);\r\n            const splitTensor = getParamValue('tensor', node, tensorMap, context);\r\n            const lengths = getParamValue('lengths', node, tensorMap, context);\r\n            const splitTensorArray = context.getTensorArray(splitId.id);\r\n            splitTensorArray.split(lengths, splitTensor);\r\n            return [splitTensorArray.idTensor];\r\n        }\r\n        case 'TensorArraySizeV3': {\r\n            const sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\r\n            const sizeTensorArray = context.getTensorArray(sizeId.id);\r\n            return [scalar(sizeTensorArray.size(), 'int32')];\r\n        }\r\n        case 'TensorArrayCloseV3': {\r\n            const closeId = getParamValue('tensorArrayId', node, tensorMap, context);\r\n            const closeTensorArray = context.getTensorArray(closeId.id);\r\n            closeTensorArray.clearAndClose();\r\n            return [closeTensorArray.idTensor];\r\n        }\r\n        case 'TensorListSetItem': {\r\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\r\n            const index = getParamValue('index', node, tensorMap, context);\r\n            const writeTensor = getParamValue('tensor', node, tensorMap, context);\r\n            const tensorList = context.getTensorList(idTensor.id);\r\n            tensorList.setItem(index, writeTensor);\r\n            return [tensorList.idTensor];\r\n        }\r\n        case 'TensorListGetItem': {\r\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\r\n            const readIndex = getParamValue('index', node, tensorMap, context);\r\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\r\n            const elementDType = getParamValue('elementDType', node, tensorMap, context);\r\n            const tensorList = context.getTensorList(idTensor.id);\r\n            return [tensorList.getItem(readIndex, elementShape, elementDType)];\r\n        }\r\n        case 'TensorListScatterV2':\r\n        case 'TensorListScatter': {\r\n            const scatterIndices = getParamValue('indices', node, tensorMap, context);\r\n            const scatterTensor = getParamValue('tensor', node, tensorMap, context);\r\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\r\n            const numElements = getParamValue('numElements', node, tensorMap, context);\r\n            const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);\r\n            context.addTensorList(tensorList);\r\n            return [tensorList.idTensor];\r\n        }\r\n        case 'TensorListReserve': {\r\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\r\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\r\n            const numElements = getParamValue('numElements', node, tensorMap, context);\r\n            const tensorList = reserve(elementShape, elementDtype, numElements);\r\n            context.addTensorList(tensorList);\r\n            return [tensorList.idTensor];\r\n        }\r\n        case 'TensorListGather': {\r\n            const gatherId = getParamValue('tensorListId', node, tensorMap, context);\r\n            const gatherIndices = getParamValue('indices', node, tensorMap, context);\r\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\r\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\r\n            const tensorList = context.getTensorList(gatherId.id);\r\n            return [tensorList.gather(gatherIndices, elementDtype, elementShape)];\r\n        }\r\n        case 'TensorListStack': {\r\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\r\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\r\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\r\n            const numElements = getParamValue('numElements', node, tensorMap, context);\r\n            const tensorList = context.getTensorList(idTensor.id);\r\n            return [tensorList.stack(elementShape, elementDtype, numElements)];\r\n        }\r\n        case 'TensorListFromTensor': {\r\n            const tensor = getParamValue('tensor', node, tensorMap, context);\r\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\r\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\r\n            const tensorList = fromTensor(tensor, elementShape, elementDtype);\r\n            context.addTensorList(tensorList);\r\n            return [tensorList.idTensor];\r\n        }\r\n        case 'TensorListConcat': {\r\n            const concatId = getParamValue('tensorListId', node, tensorMap, context);\r\n            const tensorList = context.getTensorList(concatId.id);\r\n            const concatDtype = getParamValue('dtype', node, tensorMap, context);\r\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\r\n            return [tensorList.concat(concatDtype, elementShape)];\r\n        }\r\n        case 'TensorListPushBack': {\r\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\r\n            const writeTensor = getParamValue('tensor', node, tensorMap, context);\r\n            const tensorList = context.getTensorList(idTensor.id);\r\n            tensorList.pushBack(writeTensor);\r\n            return [tensorList.idTensor];\r\n        }\r\n        case 'TensorListPopBack': {\r\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\r\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\r\n            const elementDType = getParamValue('elementDType', node, tensorMap, context);\r\n            const tensorList = context.getTensorList(idTensor.id);\r\n            return [tensorList.popBack(elementShape, elementDType)];\r\n        }\r\n        case 'TensorListSplit': {\r\n            const splitTensor = getParamValue('tensor', node, tensorMap, context);\r\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\r\n            const lengths = getParamValue('lengths', node, tensorMap, context);\r\n            const tensorList = split(splitTensor, lengths, elementShape);\r\n            context.addTensorList(tensorList);\r\n            return [tensorList.idTensor];\r\n        }\r\n        default:\r\n            throw TypeError(`Node type ${node.op} is not implemented`);\r\n    }\r\n};\r\nexport const CATEGORY = 'control';\r\n//# sourceMappingURL=control_executor.js.map"]},"metadata":{},"sourceType":"module"}