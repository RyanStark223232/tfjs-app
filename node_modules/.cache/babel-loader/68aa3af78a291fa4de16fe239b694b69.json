{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\nimport { tensor } from './tensor';\n/**\r\n * Returns whether the targets are in the top K predictions.\r\n *\r\n * ```js\r\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\r\n * const targets = tf.tensor1d([2, 0]);\r\n * const precision = await tf.inTopKAsync(predictions, targets);\r\n * precision.print();\r\n * ```\r\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\r\n *     at least `k`.\r\n * @param targets 1-D or higher `tf.Tensor`.\r\n * @param k Optional Number of top elements to look at for computing precision,\r\n *     default to 1.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\r\n */\n\nfunction inTopKAsync_(_x, _x2) {\n  return _inTopKAsync_.apply(this, arguments);\n}\n\nfunction _inTopKAsync_() {\n  _inTopKAsync_ = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(predictions, targets) {\n    var k,\n        $predictions,\n        $targets,\n        lastDim,\n        predictionsVals,\n        targetsVals,\n        batch,\n        size,\n        precision,\n        b,\n        offset,\n        vals,\n        valAndInd,\n        i,\n        _i,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            k = _args.length > 2 && _args[2] !== undefined ? _args[2] : 1;\n            $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n            $targets = convertToTensor(targets, 'targets', 'inTopK');\n            assert($predictions.rank > 1, function () {\n              return 'inTopK() expects the predictions to be of rank 2 or higher, ' + \"but got \".concat($predictions.rank);\n            });\n            assert($predictions.rank - 1 === $targets.rank, function () {\n              return \"predictions rank should be 1 larger than \" + \"targets rank, but got predictions rank \" + \"\".concat($predictions.rank, \" and targets rank \").concat($targets.rank);\n            });\n            assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, \"predictions's shape should be align with the targets' shape, \" + 'except the last dimension.');\n            lastDim = $predictions.shape[$predictions.shape.length - 1];\n            assert(k > 0 && k <= lastDim, function () {\n              return \"'k' passed to inTopK() must be > 0 && <= the predictions last \" + \"dimension (\".concat(lastDim, \"), but got \").concat(k);\n            });\n            _context.next = 10;\n            return $predictions.data();\n\n          case 10:\n            predictionsVals = _context.sent;\n            _context.next = 13;\n            return $targets.data();\n\n          case 13:\n            targetsVals = _context.sent;\n            // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n            // and look up topK along lastDim.\n            batch = predictionsVals.length / lastDim, size = lastDim;\n            precision = getTypedArrayFromDType('bool', batch);\n            b = 0;\n\n          case 17:\n            if (!(b < batch)) {\n              _context.next = 35;\n              break;\n            }\n\n            offset = b * size;\n            vals = predictionsVals.subarray(offset, offset + size);\n            valAndInd = [];\n\n            for (i = 0; i < vals.length; i++) {\n              valAndInd.push({\n                value: vals[i],\n                index: i\n              });\n            }\n\n            valAndInd.sort(function (a, b) {\n              return b.value - a.value;\n            });\n            precision[b] = 0;\n            _i = 0;\n\n          case 25:\n            if (!(_i < k)) {\n              _context.next = 32;\n              break;\n            }\n\n            if (!(valAndInd[_i].index === targetsVals[b])) {\n              _context.next = 29;\n              break;\n            }\n\n            precision[b] = 1;\n            return _context.abrupt(\"break\", 32);\n\n          case 29:\n            _i++;\n            _context.next = 25;\n            break;\n\n          case 32:\n            b++;\n            _context.next = 17;\n            break;\n\n          case 35:\n            if (predictions !== $predictions) {\n              $predictions.dispose();\n            }\n\n            if (targets !== $targets) {\n              $targets.dispose();\n            } // Output precision has the same shape as targets.\n\n\n            return _context.abrupt(\"return\", tensor(precision, $targets.shape, 'bool'));\n\n          case 38:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _inTopKAsync_.apply(this, arguments);\n}\n\nexport var inTopKAsync = inTopKAsync_;","map":{"version":3,"sources":["../../src/ops/in_top_k.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;;;AAeG;AAGH,SAAQ,eAAR,QAA8B,oBAA9B;AAEA,SAAQ,MAAR,EAAgB,iBAAhB,EAAmC,sBAAnC,QAAgE,SAAhE;AACA,SAAQ,MAAR,QAAqB,UAArB;AAEA;;;;;;;;;;;;;;;;AAgBG;;SACY,Y;;;;;2EAAf,iBACI,WADJ,EAC+B,OAD/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACsD,YAAA,CADtD,2DAC0D,CAD1D;AAEQ,YAAA,YAFR,GAEuB,eAAe,CAAC,WAAD,EAAc,aAAd,EAA6B,QAA7B,CAFtC;AAGQ,YAAA,QAHR,GAGmB,eAAe,CAAC,OAAD,EAAU,SAAV,EAAqB,QAArB,CAHlC;AAKE,YAAA,MAAM,CACF,YAAY,CAAC,IAAb,GAAoB,CADlB,EAEF;AAAA,qBAAM,mFACS,YAAY,CAAC,IADtB,CAAN;AAAA,aAFE,CAAN;AAIA,YAAA,MAAM,CACF,YAAY,CAAC,IAAb,GAAoB,CAApB,KAA0B,QAAQ,CAAC,IADjC,EAEF;AAAA,qBAAM,oGAEC,YAAY,CAAC,IAFd,+BAEuC,QAAQ,CAAC,IAFhD,CAAN;AAAA,aAFE,CAAN;AAKA,YAAA,iBAAiB,CACb,YAAY,CAAC,KAAb,CAAmB,KAAnB,CAAyB,CAAzB,EAA4B,YAAY,CAAC,KAAb,CAAmB,MAAnB,GAA4B,CAAxD,CADa,EAEb,QAAQ,CAAC,KAFI,EAGb,kEACI,4BAJS,CAAjB;AAKM,YAAA,OAnBR,GAmBkB,YAAY,CAAC,KAAb,CAAmB,YAAY,CAAC,KAAb,CAAmB,MAAnB,GAA4B,CAA/C,CAnBlB;AAoBE,YAAA,MAAM,CACF,CAAC,GAAG,CAAJ,IAAS,CAAC,IAAI,OADZ,EAEF;AAAA,qBAAM,wFACY,OADZ,wBACiC,CADjC,CAAN;AAAA,aAFE,CAAN;AApBF;AAAA,mBAyBgC,YAAY,CAAC,IAAb,EAzBhC;;AAAA;AAyBQ,YAAA,eAzBR;AAAA;AAAA,mBA0B4B,QAAQ,CAAC,IAAT,EA1B5B;;AAAA;AA0BQ,YAAA,WA1BR;AA4BE;AACA;AACO,YAAA,KA9BT,GA8ByB,eAAe,CAAC,MAAhB,GAAyB,OA9BlD,EA8BgB,IA9BhB,GA8B2D,OA9B3D;AA+BQ,YAAA,SA/BR,GA+BoB,sBAAsB,CAAC,MAAD,EAAS,KAAT,CA/B1C;AAiCW,YAAA,CAjCX,GAiCe,CAjCf;;AAAA;AAAA,kBAiCkB,CAAC,GAAG,KAjCtB;AAAA;AAAA;AAAA;;AAkCU,YAAA,MAlCV,GAkCmB,CAAC,GAAG,IAlCvB;AAmCU,YAAA,IAnCV,GAmCiB,eAAe,CAAC,QAAhB,CAAyB,MAAzB,EAAiC,MAAM,GAAG,IAA1C,CAnCjB;AAoCU,YAAA,SApCV,GAoC6D,EApC7D;;AAqCI,iBAAS,CAAT,GAAa,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,MAAzB,EAAiC,CAAC,EAAlC,EAAsC;AACpC,cAAA,SAAS,CAAC,IAAV,CAAe;AAAC,gBAAA,KAAK,EAAE,IAAI,CAAC,CAAD,CAAZ;AAAiB,gBAAA,KAAK,EAAE;AAAxB,eAAf;AACD;;AACD,YAAA,SAAS,CAAC,IAAV,CAAe,UAAC,CAAD,EAAI,CAAJ;AAAA,qBAAU,CAAC,CAAC,KAAF,GAAU,CAAC,CAAC,KAAtB;AAAA,aAAf;AAEA,YAAA,SAAS,CAAC,CAAD,CAAT,GAAe,CAAf;AACS,YAAA,EA3Cb,GA2CiB,CA3CjB;;AAAA;AAAA,kBA2CoB,EAAC,GAAG,CA3CxB;AAAA;AAAA;AAAA;;AAAA,kBA4CU,SAAS,CAAC,EAAD,CAAT,CAAa,KAAb,KAAuB,WAAW,CAAC,CAAD,CA5C5C;AAAA;AAAA;AAAA;;AA6CQ,YAAA,SAAS,CAAC,CAAD,CAAT,GAAe,CAAf;AA7CR;;AAAA;AA2C2B,YAAA,EAAC,EA3C5B;AAAA;AAAA;;AAAA;AAiC6B,YAAA,CAAC,EAjC9B;AAAA;AAAA;;AAAA;AAmDE,gBAAI,WAAW,KAAK,YAApB,EAAkC;AAChC,cAAA,YAAY,CAAC,OAAb;AACD;;AACD,gBAAI,OAAO,KAAK,QAAhB,EAA0B;AACxB,cAAA,QAAQ,CAAC,OAAT;AACD,aAxDH,CA0DE;;;AA1DF,6CA2DS,MAAM,CAAC,SAAD,EAAY,QAAQ,CAAC,KAArB,EAA4B,MAA5B,CA3Df;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AA8DA,OAAO,IAAM,WAAW,GAAG,YAApB","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { convertToTensor } from '../tensor_util_env';\r\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\r\nimport { tensor } from './tensor';\r\n/**\r\n * Returns whether the targets are in the top K predictions.\r\n *\r\n * ```js\r\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\r\n * const targets = tf.tensor1d([2, 0]);\r\n * const precision = await tf.inTopKAsync(predictions, targets);\r\n * precision.print();\r\n * ```\r\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\r\n *     at least `k`.\r\n * @param targets 1-D or higher `tf.Tensor`.\r\n * @param k Optional Number of top elements to look at for computing precision,\r\n *     default to 1.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\r\n */\r\nasync function inTopKAsync_(predictions, targets, k = 1) {\r\n    const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\r\n    const $targets = convertToTensor(targets, 'targets', 'inTopK');\r\n    assert($predictions.rank > 1, () => 'inTopK() expects the predictions to be of rank 2 or higher, ' +\r\n        `but got ${$predictions.rank}`);\r\n    assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than ` +\r\n        `targets rank, but got predictions rank ` +\r\n        `${$predictions.rank} and targets rank ${$targets.rank}`);\r\n    assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, ` +\r\n        'except the last dimension.');\r\n    const lastDim = $predictions.shape[$predictions.shape.length - 1];\r\n    assert(k > 0 && k <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` +\r\n        `dimension (${lastDim}), but got ${k}`);\r\n    const predictionsVals = await $predictions.data();\r\n    const targetsVals = await $targets.data();\r\n    // Reshape predictionsVals into a 2d tensor [batch, lastDim]\r\n    // and look up topK along lastDim.\r\n    const [batch, size] = [predictionsVals.length / lastDim, lastDim];\r\n    const precision = getTypedArrayFromDType('bool', batch);\r\n    for (let b = 0; b < batch; b++) {\r\n        const offset = b * size;\r\n        const vals = predictionsVals.subarray(offset, offset + size);\r\n        const valAndInd = [];\r\n        for (let i = 0; i < vals.length; i++) {\r\n            valAndInd.push({ value: vals[i], index: i });\r\n        }\r\n        valAndInd.sort((a, b) => b.value - a.value);\r\n        precision[b] = 0;\r\n        for (let i = 0; i < k; i++) {\r\n            if (valAndInd[i].index === targetsVals[b]) {\r\n                precision[b] = 1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (predictions !== $predictions) {\r\n        $predictions.dispose();\r\n    }\r\n    if (targets !== $targets) {\r\n        $targets.dispose();\r\n    }\r\n    // Output precision has the same shape as targets.\r\n    return tensor(precision, $targets.shape, 'bool');\r\n}\r\nexport const inTopKAsync = inTopKAsync_;\r\n//# sourceMappingURL=in_top_k.js.map"]},"metadata":{},"sourceType":"module"}