{"ast":null,"code":"import _slicedToArray from \"C:/Users/wongh/Documents/GitHub/tfjs-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { FromPixels } from '@tensorflow/tfjs-core';\nimport { TextureUsage } from '../tex_util';\nimport { FromPixelsProgram } from './FromPixels_utils/from_pixels_gpu';\nimport { FromPixelsPackedProgram } from './FromPixels_utils/from_pixels_packed_gpu';\nexport var fromPixelsConfig = {\n  kernelName: FromPixels,\n  backendName: 'webgl',\n  kernelFunc: fromPixels\n};\nvar fromPixels2DContext;\n\nfunction fromPixels(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var pixels = inputs.pixels;\n  var numChannels = attrs.numChannels;\n  var isVideo = typeof HTMLVideoElement !== 'undefined' && pixels instanceof HTMLVideoElement;\n  var isImage = typeof HTMLImageElement !== 'undefined' && pixels instanceof HTMLImageElement;\n\n  var _ref = isVideo ? [pixels.videoWidth, pixels.videoHeight] : [pixels.width, pixels.height],\n      _ref2 = _slicedToArray(_ref, 2),\n      width = _ref2[0],\n      height = _ref2[1];\n\n  var texShape = [height, width];\n  var outShape = [height, width, numChannels];\n\n  if (isImage || isVideo) {\n    if (fromPixels2DContext == null) {\n      fromPixels2DContext = document.createElement('canvas').getContext('2d');\n    }\n\n    fromPixels2DContext.canvas.width = width;\n    fromPixels2DContext.canvas.height = height;\n    fromPixels2DContext.drawImage(pixels, 0, 0, width, height);\n    pixels = fromPixels2DContext.canvas;\n  }\n\n  var tempPixelHandle = backend.makeTensorInfo(texShape, 'int32'); // This is a byte texture with pixels.\n\n  backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;\n  backend.gpgpu.uploadPixelDataToTexture(backend.getTexture(tempPixelHandle.dataId), pixels);\n  var program = env().getBool('WEBGL_PACK') ? new FromPixelsPackedProgram(outShape) : new FromPixelsProgram(outShape);\n  var res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');\n  backend.disposeData(tempPixelHandle.dataId);\n  return res;\n}","map":{"version":3,"sources":["../../src/kernels/FromPixels.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,GAAR,QAAwD,uBAAxD;AACA,SAAQ,UAAR,QAA4D,uBAA5D;AAGA,SAAQ,YAAR,QAA2B,aAA3B;AAEA,SAAQ,iBAAR,QAAgC,oCAAhC;AACA,SAAQ,uBAAR,QAAsC,2CAAtC;AAEA,OAAO,IAAM,gBAAgB,GAAiB;AAC5C,EAAA,UAAU,EAAE,UADgC;AAE5C,EAAA,WAAW,EAAE,OAF+B;AAG5C,EAAA,UAAU,EAAE;AAHgC,CAAvC;AAMP,IAAI,mBAAJ;;AAEA,SAAS,UAAT,CAAoB,IAApB,EAIC;AAAA,MACQ,MADR,GACkC,IADlC,CACQ,MADR;AAAA,MACgB,OADhB,GACkC,IADlC,CACgB,OADhB;AAAA,MACyB,KADzB,GACkC,IADlC,CACyB,KADzB;AAAA,MAEM,MAFN,GAEgB,MAFhB,CAEM,MAFN;AAAA,MAGQ,WAHR,GAGuB,KAHvB,CAGQ,WAHR;AAKC,MAAM,OAAO,GAAG,OAAQ,gBAAR,KAA8B,WAA9B,IACZ,MAAM,YAAY,gBADtB;AAEA,MAAM,OAAO,GAAG,OAAQ,gBAAR,KAA8B,WAA9B,IACZ,MAAM,YAAY,gBADtB;;AAPD,aASyB,OAAO,GAC3B,CACG,MAA2B,CAAC,UAD/B,EAEG,MAA2B,CAAC,WAF/B,CAD2B,GAK3B,CAAC,MAAM,CAAC,KAAR,EAAe,MAAM,CAAC,MAAtB,CAdL;AAAA;AAAA,MASQ,KATR;AAAA,MASe,MATf;;AAgBC,MAAM,QAAQ,GAAqB,CAAC,MAAD,EAAS,KAAT,CAAnC;AACA,MAAM,QAAQ,GAAG,CAAC,MAAD,EAAS,KAAT,EAAgB,WAAhB,CAAjB;;AAEA,MAAI,OAAO,IAAI,OAAf,EAAwB;AACtB,QAAI,mBAAmB,IAAI,IAA3B,EAAiC;AAC/B,MAAA,mBAAmB,GAAG,QAAQ,CAAC,aAAT,CAAuB,QAAvB,EAAiC,UAAjC,CAA4C,IAA5C,CAAtB;AACD;;AAED,IAAA,mBAAmB,CAAC,MAApB,CAA2B,KAA3B,GAAmC,KAAnC;AACA,IAAA,mBAAmB,CAAC,MAApB,CAA2B,MAA3B,GAAoC,MAApC;AACA,IAAA,mBAAmB,CAAC,SAApB,CACI,MADJ,EACmD,CADnD,EACsD,CADtD,EACyD,KADzD,EACgE,MADhE;AAEA,IAAA,MAAM,GAAG,mBAAmB,CAAC,MAA7B;AACD;;AAED,MAAM,eAAe,GAAG,OAAO,CAAC,cAAR,CAAuB,QAAvB,EAAiC,OAAjC,CAAxB,CA/BD,CAgCC;;AACA,EAAA,OAAO,CAAC,OAAR,CAAgB,GAAhB,CAAoB,eAAe,CAAC,MAApC,EAA4C,KAA5C,GAAoD,YAAY,CAAC,MAAjE;AACA,EAAA,OAAO,CAAC,KAAR,CAAc,wBAAd,CACI,OAAO,CAAC,UAAR,CAAmB,eAAe,CAAC,MAAnC,CADJ,EACgD,MADhD;AAEA,MAAM,OAAO,GAAG,GAAG,GAAG,OAAN,CAAc,YAAd,IACZ,IAAI,uBAAJ,CAA4B,QAA5B,CADY,GAEZ,IAAI,iBAAJ,CAAsB,QAAtB,CAFJ;AAGA,MAAM,GAAG,GAAG,OAAO,CAAC,eAAR,CAAwB,OAAxB,EAAiC,CAAC,eAAD,CAAjC,EAAoD,OAApD,CAAZ;AACA,EAAA,OAAO,CAAC,WAAR,CAAoB,eAAe,CAAC,MAApC;AACA,SAAO,GAAP;AACD","sourceRoot":"","sourcesContent":["/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport { env } from '@tensorflow/tfjs-core';\r\nimport { FromPixels } from '@tensorflow/tfjs-core';\r\nimport { TextureUsage } from '../tex_util';\r\nimport { FromPixelsProgram } from './FromPixels_utils/from_pixels_gpu';\r\nimport { FromPixelsPackedProgram } from './FromPixels_utils/from_pixels_packed_gpu';\r\nexport const fromPixelsConfig = {\r\n    kernelName: FromPixels,\r\n    backendName: 'webgl',\r\n    kernelFunc: fromPixels,\r\n};\r\nlet fromPixels2DContext;\r\nfunction fromPixels(args) {\r\n    const { inputs, backend, attrs } = args;\r\n    let { pixels } = inputs;\r\n    const { numChannels } = attrs;\r\n    const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&\r\n        pixels instanceof HTMLVideoElement;\r\n    const isImage = typeof (HTMLImageElement) !== 'undefined' &&\r\n        pixels instanceof HTMLImageElement;\r\n    const [width, height] = isVideo ?\r\n        [\r\n            pixels.videoWidth,\r\n            pixels.videoHeight\r\n        ] :\r\n        [pixels.width, pixels.height];\r\n    const texShape = [height, width];\r\n    const outShape = [height, width, numChannels];\r\n    if (isImage || isVideo) {\r\n        if (fromPixels2DContext == null) {\r\n            fromPixels2DContext = document.createElement('canvas').getContext('2d');\r\n        }\r\n        fromPixels2DContext.canvas.width = width;\r\n        fromPixels2DContext.canvas.height = height;\r\n        fromPixels2DContext.drawImage(pixels, 0, 0, width, height);\r\n        pixels = fromPixels2DContext.canvas;\r\n    }\r\n    const tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');\r\n    // This is a byte texture with pixels.\r\n    backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;\r\n    backend.gpgpu.uploadPixelDataToTexture(backend.getTexture(tempPixelHandle.dataId), pixels);\r\n    const program = env().getBool('WEBGL_PACK') ?\r\n        new FromPixelsPackedProgram(outShape) :\r\n        new FromPixelsProgram(outShape);\r\n    const res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');\r\n    backend.disposeData(tempPixelHandle.dataId);\r\n    return res;\r\n}\r\n//# sourceMappingURL=FromPixels.js.map"]},"metadata":{},"sourceType":"module"}