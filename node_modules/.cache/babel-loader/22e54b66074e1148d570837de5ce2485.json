{"ast":null,"code":"/**\r\n * Validate sparseToDense inputs.\r\n *\r\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\r\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\r\n * placed.\r\n * @param sparseValues A 0-D or 1-D Tensor. Values\r\n * corresponding to each row of sparseIndices, or a scalar value to be used for\r\n * all sparse indices.\r\n * @param outputShape number[]. Shape of the dense output tensor.\r\n * @param validateIndices boolean. indice validation is not supported, error\r\n * will be thrown if it is set.\r\n */\nexport function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {\n  if (sparseIndices.dtype !== 'int32') {\n    throw new Error('tf.sparseToDense() expects the indices to be int32 type,' + \" but the dtype was \".concat(sparseIndices.dtype, \".\"));\n  }\n\n  if (sparseIndices.rank > 2) {\n    throw new Error('sparseIndices should be a scalar, vector, or matrix,' + \" but got shape \".concat(sparseIndices.shape, \".\"));\n  }\n\n  var numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n  var numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n\n  if (outputShape.length !== numDims) {\n    throw new Error('outputShape has incorrect number of elements:,' + \" \".concat(outputShape.length, \", should be: \").concat(numDims, \".\"));\n  }\n\n  var numValues = sparseValues.size;\n\n  if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {\n    throw new Error('sparseValues has incorrect shape ' + \"\".concat(sparseValues.shape, \", should be [] or [\").concat(numElems, \"]\"));\n  }\n\n  if (sparseValues.dtype !== defaultValues.dtype) {\n    throw new Error('sparseValues.dtype must match defaultValues.dtype');\n  }\n}","map":{"version":3,"sources":["../../src/ops/sparse_to_dense_util.ts"],"names":[],"mappings":"AAkBA;;;;;;;;;;;;AAYG;AACH,OAAM,SAAU,aAAV,CACF,aADE,EACqB,YADrB,EAC2C,WAD3C,EAEF,aAFE,EAEmB;AACvB,MAAI,aAAa,CAAC,KAAd,KAAwB,OAA5B,EAAqC;AACnC,UAAM,IAAI,KAAJ,CACF,0FACsB,aAAa,CAAC,KADpC,MADE,CAAN;AAGD;;AACD,MAAI,aAAa,CAAC,IAAd,GAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAI,KAAJ,CACF,kFACkB,aAAa,CAAC,KADhC,MADE,CAAN;AAGD;;AAED,MAAM,QAAQ,GAAG,aAAa,CAAC,IAAd,GAAqB,CAArB,GAAyB,aAAa,CAAC,KAAd,CAAoB,CAApB,CAAzB,GAAkD,CAAnE;AACA,MAAM,OAAO,GAAG,aAAa,CAAC,IAAd,GAAqB,CAArB,GAAyB,aAAa,CAAC,KAAd,CAAoB,CAApB,CAAzB,GAAkD,CAAlE;;AAEA,MAAI,WAAW,CAAC,MAAZ,KAAuB,OAA3B,EAAoC;AAClC,UAAM,IAAI,KAAJ,CACF,8DACI,WAAW,CAAC,MADhB,0BACsC,OADtC,MADE,CAAN;AAGD;;AAED,MAAM,SAAS,GAAG,YAAY,CAAC,IAA/B;;AACA,MAAI,EAAE,YAAY,CAAC,IAAb,KAAsB,CAAtB,IACA,YAAY,CAAC,IAAb,KAAsB,CAAtB,IAA2B,SAAS,KAAK,QAD3C,CAAJ,EAC0D;AACxD,UAAM,IAAI,KAAJ,CACF,gDACG,YAAY,CAAC,KADhB,gCAC2C,QAD3C,MADE,CAAN;AAGD;;AAED,MAAI,YAAY,CAAC,KAAb,KAAuB,aAAa,CAAC,KAAzC,EAAgD;AAC9C,UAAM,IAAI,KAAJ,CAAU,mDAAV,CAAN;AACD;AACF","sourceRoot":"","sourcesContent":["/**\r\n * Validate sparseToDense inputs.\r\n *\r\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\r\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\r\n * placed.\r\n * @param sparseValues A 0-D or 1-D Tensor. Values\r\n * corresponding to each row of sparseIndices, or a scalar value to be used for\r\n * all sparse indices.\r\n * @param outputShape number[]. Shape of the dense output tensor.\r\n * @param validateIndices boolean. indice validation is not supported, error\r\n * will be thrown if it is set.\r\n */\r\nexport function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {\r\n    if (sparseIndices.dtype !== 'int32') {\r\n        throw new Error('tf.sparseToDense() expects the indices to be int32 type,' +\r\n            ` but the dtype was ${sparseIndices.dtype}.`);\r\n    }\r\n    if (sparseIndices.rank > 2) {\r\n        throw new Error('sparseIndices should be a scalar, vector, or matrix,' +\r\n            ` but got shape ${sparseIndices.shape}.`);\r\n    }\r\n    const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\r\n    const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\r\n    if (outputShape.length !== numDims) {\r\n        throw new Error('outputShape has incorrect number of elements:,' +\r\n            ` ${outputShape.length}, should be: ${numDims}.`);\r\n    }\r\n    const numValues = sparseValues.size;\r\n    if (!(sparseValues.rank === 0 ||\r\n        sparseValues.rank === 1 && numValues === numElems)) {\r\n        throw new Error('sparseValues has incorrect shape ' +\r\n            `${sparseValues.shape}, should be [] or [${numElems}]`);\r\n    }\r\n    if (sparseValues.dtype !== defaultValues.dtype) {\r\n        throw new Error('sparseValues.dtype must match defaultValues.dtype');\r\n    }\r\n}\r\n//# sourceMappingURL=sparse_to_dense_util.js.map"]},"metadata":{},"sourceType":"module"}