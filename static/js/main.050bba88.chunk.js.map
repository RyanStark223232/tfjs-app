{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","props","loadVideo","event","url","URL","createObjectURL","target","files","setState","videoPath","video","document","getElementById","src","onloadeddata","play","load","exportToJson","objectData","filename","window","navigator","msSaveOrOpenBlob","blob","Blob","decodeURIComponent","encodeURI","JSON","stringify","type","a","createElement","download","href","encodeURIComponent","body","appendChild","click","removeChild","getArray","directory","value","dict","time","state","time_array","result","result_array","console","log","norm","lm1","lm2","sqrt","pow","reset_record","hand_array","sleep","milliseconds","Promise","resolve","setTimeout","inference","require","handpose","net","i","length","estimateHands","hand","forEach","prediction","ID","startAt","Date","now","canvasRef","React","createRef","bind","record_video","stop_record","this","Interval_ID","setInterval","concat_frame","current","width","videoWidth","height","videoHeight","getContext","drawImage","current_moment","img","toDataURL","onload","clearInterval","pause","className","id","crossOrigin","controls","onChange","onClick","ref","style","position","marginLeft","marginRight","left","right","textAlign","zindex","Component","Boolean","location","hostname","match","ReactDOM","render","StrictMode","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.050bba88.chunk.js","sourcesContent":["import React from \"react\";\nimport * as handpose from \"@tensorflow-models/handpose\";\nimport \"./App.css\";\nimport { sqrt, pow } from \"mathjs\"\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      ID:null,\n      hand_array:[],\n      time_array:[],\n      result_array:[],\n      startAt: Date.now(),\n    };\n    this.canvasRef = React.createRef(null);\n    this.sleep = this.sleep.bind(this);\n    this.inference = this.inference.bind(this);\n    this.norm = this.norm.bind(this);\n    this.getArray = this.getArray.bind(this);\n    this.exportToJson = this.exportToJson.bind(this);\n    this.record_video = this.record_video.bind(this);\n    this.stop_record = this.stop_record.bind(this);\n    this.reset_record = this.reset_record.bind(this);\n    require('@tensorflow/tfjs-backend-webgl');\n    this.net = null;\n  }\n\n  loadVideo = (event) =>{\n    var url = URL.createObjectURL(event.target.files[0]);\n    this.setState({videoPath:url});\n    var video = document.getElementById('user-video');\n    video.src = url;\n    video.onloadeddata = () =>{\n      video.play();\n    }\n    video.load();\n  };\n\n  async record_video(){\n    console.log(\"Start Recording\");\n    this.setState({startAt:Date.now()});\n    const Interval_ID = setInterval(() => {\n      this.concat_frame();\n    }, 50);\n    this.setState({ID:Interval_ID,});\n  }\n\n  async concat_frame() {\n    const video = document.getElementById(\"user-video\");\n    this.canvasRef.current.width = video.videoWidth;\n    this.canvasRef.current.height = video.videoHeight;\n    const ctx = this.canvasRef.current.getContext(\"2d\");\n    ctx.drawImage(video, 0, 0, this.canvasRef.current.width, this.canvasRef.current.height);\n    let current_moment = (Date.now() - this.state.startAt)/1000;\n    var img = document.createElement(\"img\");\n    img.src = this.canvasRef.current.toDataURL();\n    img.onload = function(){\n      this.setState({hand_array:[...this.state.hand_array, img],\n                     time_array:[...this.state.time_array, current_moment]});\n    }.bind(this)\n  }\n\n  async stop_record() {\n    console.log(\"Stop Recording\");\n    clearInterval(this.state.ID);\n    const video = document.getElementById(\"user-video\");\n    video.pause();\n    await this.inference();\n    console.log(\"Inference Finished\");\n  }\n\n  exportToJson = (objectData, filename) => {\n    let contentType = \"application/json;charset=utf-8;\";\n    if (window.navigator && window.navigator.msSaveOrOpenBlob) {\n      var blob = new Blob([decodeURIComponent(encodeURI(JSON.stringify(objectData)))], { type: contentType });\n      navigator.msSaveOrOpenBlob(blob, filename);\n    } else {\n      var a = document.createElement('a');\n      a.download = filename;\n      a.href = 'data:' + contentType + ',' + encodeURIComponent(JSON.stringify(objectData));\n      a.target = '_blank';\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n    }\n  }\n \n  getArray = () => {\n    const directory = document.getElementById(\"fname\").value;\n    let dict = {\n      time: this.state.time_array,\n      result: this.state.result_array,\n    }\n    console.log(dict);\n    this.exportToJson(dict, directory);\n  }\n\n  norm = (lm1, lm2) => {\n    return sqrt(pow(lm1[0]-lm2[0], 2)+pow(lm1[1]-lm2[1], 2))\n  }  \n\n  reset_record = async() =>{\n    console.log(\"Reseting Arrays\");\n    await this.setState({\n      hand_array:[],\n      time_array:[],\n      result_array:[],\n    });\n    this.sleep(100);\n    console.log(\"Hands: \", this.state.hand_array);\n    console.log(\"Result: \", this.state.result_array);\n  }\n\n  sleep = (milliseconds) => {\n    return new Promise(resolve => setTimeout(resolve, milliseconds))\n  }  \n\n  inference = async() =>{\n    this.sleep(300);\n    require('@tensorflow/tfjs-backend-webgl');\n    const net = await handpose.load();\n    console.log(\"Handpose model loaded.\");\n\n    // Run prediction on recorded tapping data\n    for (let i = 0; i<this.state.hand_array.length; i++){\n      const hand = await net.estimateHands(this.state.hand_array[i]);\n      if (hand.length > 0){\n        hand.forEach((prediction) => {\n          this.setState({result_array:[...this.state.result_array, prediction]});\n        });\n      }\n      else{\n        this.setState({result_array:[...this.state.result_array, null]});\n      }\n    }\n  }\n\n  /*\n  checkImg = (str) =>{\n    if (str.charAt(str.length - 1) === 'g' && \n    str.charAt(str.length - 2) === 'p' &&\n    str.charAt(str.length - 3) === 'j' ){\n      return true;\n    }\n  }\n\n  useRecord = async() =>{\n    require('@tensorflow/tfjs-backend-webgl');\n    const net = await handpose.load();\n    for (let j in this.state.urls) {\n      if (this.checkImg(this.state.urls[j])) {\n        await this.inference(this.state.urls[j], net);\n        await this.sleep(100);\n      }\n    }\n    console.log(\"FINISH\");\n    return true;\n  }\n\n  real_time_handpose = async() =>{\n    const Interval_ID = setInterval(() => {\n      this.paint();\n    }, 50);\n    this.setState({ID:Interval_ID});\n  } \n\n  runHandpose = async () => {\n    this.setState({urls:[]});\n    const $ = require('cheerio');\n    const rp = require('request-promise');\n    const directory = document.getElementById(\"fname\").value\n    const url = 'http://localhost:8000/' + directory;\n    console.log(\"Looking for image in: \", url);\n    const links = [];\n    rp(url).then(html => {\n        const linkObjects = $('a', html);\n        const total = linkObjects.length;\n        for(let i = 0; i < total; i++){\n            links.push({\n                href: directory+\"/\"+linkObjects[i].attribs.href,\n                title: linkObjects[i].attribs.title\n            });\n        }\n        for (let j in links) this.setState({urls:[...this.state.urls, links[j].href]});\n        this.state.urls.sort(function(x, y) {\n          x = x.split('/')[1].split('.')[0];\n          y = y.split('/')[1].split('.')[0];\n          let int_x = parseInt(x);\n          let int_y = parseInt(y);\n          if (int_x < int_y) {\n            return -1;\n          }\n          if (int_x > int_y) {\n            return 1;\n          }\n          return 0;\n        });\n        console.log(this.state.urls);\n    })\n    .catch(err => {\n        console.log(err); \n    })\n  };\n\n  load = async() =>{\n    this.net = await handpose.load();\n    console.log(\"Loaded Handpose\");\n  }\n\n  paint = async() => {\n    const video = document.getElementById(\"user-video\");\n    this.canvasRef.current.width = video.videoWidth;\n    this.canvasRef.current.height = video.videoHeight;\n    const ctx = this.canvasRef.current.getContext(\"2d\");\n    ctx.drawImage(video, 0, 0, this.canvasRef.current.width, this.canvasRef.current.height);\n    //const dataUrl = this.canvasRef.current.toDataURL();\n    const hand = await this.net.estimateHands(video);\n    if (hand.length > 0){\n      hand.forEach((prediction) => {\n        drawHand(hand, ctx);\n        this.setState({hand_array:[...this.state.hand_array, hand]});\n        const landmarks = prediction.landmarks\n        let pawn_dist = this.norm(landmarks[0], landmarks[2]);\n        let current_moment = (Date.now() - this.state.startAt)/1000\n        let index_dist = this.norm(landmarks[4], landmarks[8]);\n        let current_dist = index_dist/pawn_dist;\n        console.log(current_moment, current_dist);\n        if (this.state.index_passed === 0 && (current_dist - this.state.min_dist) > 0.5){\n          console.log(\"Up Pass\", current_moment);\n          this.setState({index_passed:1,\n            max_dist: current_dist});\n        }\n        if (this.state.index_passed === 1 && current_dist > this.state.max_dist){\n          this.setState({max_dist: current_dist});\n        }\n        if (this.state.index_passed === 1 && (this.state.max_dist - current_dist) > 0.5){\n          console.log(\"Down Pass\", current_moment);\n          this.setState({index_passed:0,\n            min_dist: current_dist,\n            tap_count:[...this.state.tap_count, current_moment]});\n        }\n        if (this.state.index_passed === 0 && current_dist < this.state.min_dist){\n          this.setState({min_dist: current_dist});\n        }\n      });\n    }\n  }\n  */\n\n  render(){\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\"></header>\n        <div>\n          <div>\n            <video id=\"user-video\" crossOrigin=\"anonymous\" controls=\"controls\">\n              <source id='source' type=\"video/mp4\"></source>\n            </video>\n          </div>\n          <div>\n            <input type=\"file\" id=\"videof\" onChange={this.loadVideo}/>\n          </div>\n          <button onClick={this.record_video}>1.Record</button>\n          <button onClick={this.stop_record}>2.Run Inference</button>\n          <button onClick={this.reset_record}>4.Reset Recording</button>\n          <div>\n            <input type=\"text\" id=\"fname\"/>\n            <button onClick={this.getArray}>3.Get Array</button>   \n          </div>\n        </div>\n        <div>\n          <canvas\n            ref={this.canvasRef}\n            style={{\n              position: \"absolute\",\n              marginLeft: \"auto\",\n              marginRight: \"auto\",\n              left: 0,\n              right: 0,\n              textAlign: \"center\",\n              zindex: 9,\n              width: \"auto\",\n              height: \"auto\",\n            }}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}